<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式之装饰器模式</title>
    <url>/2020/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">装饰器模式</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319302594594" target="_blank" rel="noopener">装饰器</a></p>
<blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来讲，相比生成子类更为灵活</p>
</blockquote>
<p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200313164100749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200215214741558"></p>
<ul>
<li><p><strong>Component(组件)：</strong>组件接口定义了全部组件实现类以及所有 <em>装饰器实现的行为。</em></p>
</li>
<li><p><strong>ConcreteComponent(具体组件实现类)：</strong>具体组件实现类实现了Component接口。通常情况下，具体组件实现类就是被装饰器装饰的原始对象，该类提供了 Component 接口中定义的最基本的功能，其它高级功能或后续添加的新功能，都是通过装饰器的方式添加到该类的对象之上。</p>
</li>
<li><p><strong>Decorator(装饰器)：</strong>所有装饰器的父类，它是一个实现了 Component 接口的<em>抽象类</em>，并在<em>其中封装了一个 Component 对象</em>，也就是被装饰的对象。而这个被装饰的对象只要是 Component 类型即可，这就实现了装饰器的组合和复用。</p>
</li>
<li><p><strong>ConcreteDecorator：</strong>具体的装饰器实现类，该实现类要向被装饰对象添加某些功能。</p>
</li>
</ul>
<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>

<p>Decorator模式有什么好处？<strong>它实际上把 <em>核心功能</em> 和 <em>附加功能</em> 给分开了</strong>。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造者模式</title>
    <url>/2020/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://juejin.im/post/5a23bdd36fb9a045272568a6" target="_blank" rel="noopener">人人都会设计模式—建造者模式–Builder</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319155793953#0" target="_blank" rel="noopener">生成器</a></p>
<blockquote>
<p>将一个复杂对象的构建过程与它的表示分离，从而使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>建造者模式将一个复杂对象的创建过程分成了一步步简单的步骤，用户只需要了解复杂对象的类型和内容，而无须关注复杂对象的具体构造过程，帮助用户屏蔽掉了复杂对象内部的具体构建细节。</p>
<a id="more"></a>

<p><img src="http://q6s1x2hw2.bkt.clouddn.com/10.png" alt="image-20200219114359493"></p>
<p>主要角色如下所述：</p>
<ul>
<li><strong>建造者(Builder)接口：</strong>Builder接口用于定义建造者构建产品对象的各部分行为</li>
<li><strong>具体建造者(ConcreteBuilder)角色：</strong>在建造者模式中，直接创建产品对象的是具体建造者。具体建造者类必须实现建造者接口所要求的两类方法：<ul>
<li>建造方法</li>
<li>获取构建好的产品对象方法</li>
</ul>
</li>
<li><strong>导演(Direct)角色：</strong>该角色会通过调用具体建造者，创建需要的产品对象</li>
<li><strong>产品(Product)角色：</strong>产品对象就是用户需要使用的复杂对象</li>
</ul>
<h2 id="一-什么是建造者模式"><a href="#一-什么是建造者模式" class="headerlink" title="一.什么是建造者模式"></a>一.什么是建造者模式</h2><h3 id="1-生活中的建造者模式"><a href="#1-生活中的建造者模式" class="headerlink" title="1.生活中的建造者模式"></a>1.生活中的建造者模式</h3><blockquote>
<p>1.盖房子</p>
</blockquote>
<p>我们在生活中盖房子，一般就是打地基，盖框架「用砖头或钢筋混凝土」，然后是粉刷。基本上就是这个路子。当然我们这些工作全部可以自己做，可也以找几个工人去干，当然还可以可以直接找一个设计师，直接说我就要这样的房子，然后就不管了，最后问设计师「设计师给一张纸给工人，工人就啪啪的干了」验收房子即可「至于你是如何建的过程我不关心，我只要结果」—这就是建造者模式</p>
<blockquote>
<p>2.组装电脑</p>
</blockquote>
<p>我们买的电脑都是由主板、内存、cpu、显卡等组成，如何把这些东西组装起来给用户这就是建造者模式的作用，不同的人对电脑的配置需求不一样的「打游戏的对显卡要求高」，但是电脑构成部件是固定的，我们找电脑城的装机人员把电脑装起来这一过程就是建造模式</p>
<blockquote>
<p>3.软件开发</p>
</blockquote>
<p>我们开发一款产品，需要技术主管、产品经理、苦逼的程序员。在这里，产品经理就是指挥者「Director」和客户沟通，了解产品需求，技术主管是抽象的建造者[Builder]，让猿们杂做就杂做，而程序员就是体力劳动者「即具体的建造者，按照技术主管下发的任务去做」</p>
<h3 id="2-程序中的建造者模式"><a href="#2-程序中的建造者模式" class="headerlink" title="2.程序中的建造者模式"></a>2.程序中的建造者模式</h3><blockquote>
<p>建造者模式的特点</p>
</blockquote>
<p>建造者模式是一种创建型模式，适用于那些流程固定【顺序不一定固定】，建造的目标对象会有所改变这种场景【比如画一条狗，这个目标不变，但是不同的是有黄狗，胖狗，瘦狗等】</p>
<p>还有一种场景就是替代 <strong>多参数构造器</strong></p>
<blockquote>
<p>建造者模式的作用</p>
</blockquote>
<ul>
<li>1、用户不知道对象的建造过程和细节就可以创建出复杂的对象「屏蔽了建造的具体细节」</li>
<li>2、用户只需给出复杂对象的内容和类型可以创建出对象</li>
<li>3、建造者模工按流程一步步的创建出复杂对象</li>
</ul>
<blockquote>
<p>建造者模式的结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>角色</th>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Builder</td>
<td>接口或抽象类</td>
<td>抽象的建造者，不是必须的</td>
</tr>
<tr>
<td>ConcreateBuilder</td>
<td>具体的建造者</td>
<td>可以有多个「因为每个建造风格可能不一样」</td>
</tr>
<tr>
<td>Product</td>
<td>普通的类</td>
<td>具体的产品「即被建造的对象」</td>
</tr>
<tr>
<td>Director</td>
<td>导演也叫指挥者</td>
<td>统一指挥建造者去建造目标，导演不是必须的</td>
</tr>
</tbody></table>
<h2 id="二-建造者模式的举例"><a href="#二-建造者模式的举例" class="headerlink" title="二 建造者模式的举例"></a>二 建造者模式的举例</h2><blockquote>
<p>1.组装电脑</p>
</blockquote>
<p>小明想组装一个台式电脑，小明对电脑配置一窍不通，就直接跑到电脑城给装机老板说我要一台打游戏非常爽的电脑，麻烦你给装一下「配置什么的你给我推荐一下吧」，于是老板就让它的员工「小美」按小明的要求装了一个性能灰常牛 B 的电脑，1 个小时后电脑装好了，小明交钱拿电脑走人。不一会儿小张又来了，要一个满足平时写文章就可以的电脑，老板针对小张的要求给不同的装机配置。不同的人有不同的配置方案「但是装机流程是一样的」，这就是一个典型的建造者模式</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/11.png" alt="组装电脑简单的 UML"></p>
<ul>
<li>创建被建造的对象电脑(产品类) — Computer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 产品类--被建造的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu ; <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hardDisk ; <span class="comment">//硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String mainBoard ; <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String memory ; <span class="comment">// 内存</span></span><br><span class="line">    ... 省略 getter 和 setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象的建造者 — Builder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 抽象的建造者，即装电脑的步骤</span></span><br><span class="line"><span class="comment"> * 至于安装什么型号的主板，不是我关心，而是具体的建造者关心的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 安装主板</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装 cpu</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createCpu</span><span class="params">(String cpu)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装硬盘</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createhardDisk</span><span class="params">(String hardDisk)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span> </span>;</span><br><span class="line">    <span class="comment">// 组成电脑</span></span><br><span class="line">    <span class="function">Computer <span class="title">createComputer</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体建造者，也就是装机工人小美 — AssemblerBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 具体的建造者，这里是商场的一个装机人员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssemblerBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer = <span class="keyword">new</span> Computer() ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createhardDisk</span><span class="params">(String hardDisk)</span> </span>&#123;</span><br><span class="line">        computer.setHardDisk(hardDisk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">        computer.setMainBoard(mainBoard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还有老板「”指手画脚的人”」安排装机工工作 — Direcror.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 声明一个导演类「指挥者，这里可以装电脑的老板」，用来指挥组装过程，也就是组装电脑的流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder ;</span><br><span class="line">	<span class="comment">// 使用多态，装机工非常多，我管你小美，小兰，小猪，我统统收了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Direcror</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 老板最后只想看到装成的成品---要交到客户手中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">(String cpu,String hardDisk,String mainBoard,String memory)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 具体的工作是装机工去做</span></span><br><span class="line">        <span class="keyword">this</span>.builder.createMainBoard(mainBoard);</span><br><span class="line">        <span class="keyword">this</span>.builder.createCpu(cpu) ;</span><br><span class="line">        <span class="keyword">this</span>.builder.createMemory(memory);</span><br><span class="line">        <span class="keyword">this</span>.builder.createhardDisk(hardDisk);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.builder.createComputer() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">// 装机员小美</span></span><br><span class="line">        Builder builder = <span class="keyword">new</span> AssemblerBuilder() ;</span><br><span class="line">        <span class="comment">// 老板把小明的需求转给小美</span></span><br><span class="line">        Direcror direcror = <span class="keyword">new</span> Direcror(builder) ;</span><br><span class="line">        <span class="comment">// 老板最后拿到成品机子，工作全由小美去做</span></span><br><span class="line">        Computer computer = direcror.createComputer(<span class="string">"Intel 酷睿i9 7900X"</span>,<span class="string">"三星M9T 2TB （HN-M201RAD）"</span>,<span class="string">"技嘉AORUS Z270X-Gaming 7"</span>,<span class="string">"科赋Cras II 红灯 16GB DDR4 3000"</span>) ;</span><br><span class="line">        System.out.println(<span class="string">"小明这台电脑使用的是：\n"</span>+computer.getMainBoard()+<span class="string">" 主板\n"</span>+computer.getCpu()+<span class="string">" CPU\n"</span>+computer.getHardDisk()+<span class="string">"硬盘\n"</span>+computer.getMainBoard()+<span class="string">" 内存\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.盖房子</p>
</blockquote>
<p>盖房子的基本步骤和流程是固定的无非就是打地基、盖框架、然后浇筑「至于盖平房、还是楼房那是每个客户的具体需求」。总体来说盖房子以有以三种方式：</p>
<ul>
<li>1、自己盖房子「没有办法有的人就是牛 B ,自己设计，自己动手，当然这属于小房子，你让一个人盖个32 层让我看看」</li>
<li>2、想盖房子的人是一个包工头，自己找一帮工人自己就把房子搞定了</li>
<li>3、想盖房子的人就是一个普通人，啥也不会，找一个设计师说“我就要盖个房子，南北通透，四秀常春”，设计师说没有问题，设计师把设计出来的图纸扔给包工头说：“就照这个样子盖”，包工头拿着图纸给工人们分工派活，最后完工</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/12.png" alt="盖房子建造者模式简单的 UML"></p>
<ul>
<li>房子对象 House.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 最终的产品---房子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="keyword">private</span> String foundation ;</span><br><span class="line">    <span class="comment">// 盖框架</span></span><br><span class="line">    <span class="keyword">private</span> String frame ;</span><br><span class="line">    <span class="comment">// 浇筑</span></span><br><span class="line">    <span class="keyword">private</span> String pouring ;</span><br><span class="line">    ... 省略 setter 和 getter </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象建造者「包工头」 HouseBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 盖框架</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 浇灌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 房子建成 </span></span><br><span class="line">    <span class="function">House <span class="title">getHouse</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体建造者「工人」–盖平房 PingFangBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 盖平房</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingFangBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> House house = <span class="keyword">new</span> House() ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFoundation(<span class="string">"盖平房的地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFrame(<span class="string">"盖平房的框架"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setPouring(<span class="string">"盖平房不用浇灌，直接人工手刷就可以"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体建造者「工人」–盖楼房 LouFangBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 盖楼房</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LouFangBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> House house = <span class="keyword">new</span> House() ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFoundation(<span class="string">"盖楼房的地基就打十米深"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFrame(<span class="string">"楼房的框架要使用非常坚固钢筋混凝土"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setPouring(<span class="string">"楼房拿个罐车把框架拿混凝土灌满即可"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指挥者「设计师」 HouseDirector.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 设计师</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指挥包工头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHouse</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        houseBuilder.doFoundation();</span><br><span class="line">        houseBuilder.doFrame();</span><br><span class="line">        houseBuilder.dpPouring();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试一下 Test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式一、客户自己盖房子，亲力亲为</span></span><br><span class="line">        System.out.println(<span class="string">"========客户自己建房子，必须知道盖房的细节========"</span>);</span><br><span class="line">        House house = <span class="keyword">new</span> House() ;</span><br><span class="line">        house.setFoundation(<span class="string">"用户自己建造房子：打地基"</span>);</span><br><span class="line">        house.setFrame(<span class="string">"用户自己建造房子：盖框架"</span>);</span><br><span class="line">        house.setPouring(<span class="string">"用户自己建造房子：浇筑"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(house.getFoundation());</span><br><span class="line">        System.out.println(house.getFrame());</span><br><span class="line">        System.out.println(house.getPouring());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二、客户找一个建造者盖房子「充当包工头角色」，但是要知道如何盖房子「调用建造者盖房子的顺序」</span></span><br><span class="line">        System.out.println(<span class="string">"========客户直接找盖房子的工人「建造者」，客户要调用建造者方法去盖房子，客户必须得知道房子如何造========"</span>);</span><br><span class="line"></span><br><span class="line">        HouseBuilder houseBuilder = <span class="keyword">new</span> PingFangBuilder() ;</span><br><span class="line">        houseBuilder.doFoundation();</span><br><span class="line">        houseBuilder.doFrame();</span><br><span class="line">        houseBuilder.dpPouring();</span><br><span class="line">        House house1 = houseBuilder.getHouse() ;</span><br><span class="line">        System.out.println(house1.getFoundation());</span><br><span class="line">        System.out.println(house1.getFrame());</span><br><span class="line">        System.out.println(house1.getPouring());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三、使用建造者模式，找一个设计师「设计师拉一帮建造者去干活」，告诉他我想要什么样的房子，最后客户只问设计师要房子即可</span></span><br><span class="line">        System.out.println(<span class="string">"========客户直接找一个设计师，设计师统一指挥建造者盖房子，房子杂盖，客户不关心，最后只是找设计师要房子即可========"</span>);</span><br><span class="line"></span><br><span class="line">        HouseBuilder pingFangBuilder = <span class="keyword">new</span> PingFangBuilder() ;</span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector() ;</span><br><span class="line">        houseDirector.buildHouse(pingFangBuilder);</span><br><span class="line">        House houseCreateByBuilder = pingFangBuilder.getHouse() ;</span><br><span class="line"></span><br><span class="line">        System.out.println(houseCreateByBuilder.getFoundation());</span><br><span class="line">        System.out.println(houseCreateByBuilder.getFrame());</span><br><span class="line">        System.out.println(houseCreateByBuilder.getPouring());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.替代多参数构造函数的建造者模式，以组装电脑为例</p>
</blockquote>
<p>前面我们说了<strong>在建造者模式中 Director 不是必须的</strong>，Director 的作用不是构造产品「建造产品是建造者的事情」而是指挥协调建造的步骤「当有一个新的建造者的时候直接实现抽象建造者，而不用关心具体的执行步骤，这就是 Director 干的事情」</p>
<ul>
<li>原始的 Computer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些可选配置</span></span><br><span class="line">    <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">    <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">    <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">    <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String graphicsCard,String mouse,String computerCase,String mousePad,String other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = mousePad ;</span><br><span class="line">        <span class="keyword">this</span>.other = other ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                    String graphicsCard,String mouse,String computerCase,String mousePad)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = mousePad ;</span><br><span class="line">    &#125;</span><br><span class="line">    ... 省略其它的构造方法和 setter 和 getter 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要调用这个类就得在构参数方法中传递“无数个参数”「如果有的参是一些可选项，我们还得重写构造方法」，要么就要调用多个 setter 方法，才能给一个对象赋值，方法虽然可行，但是也太扯淡了「谁能记住那些参数呀」，那么建造者模式可以解决多参数构造方法来建造对象</p>
<ul>
<li>使用建造者建立 ComputerB.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 替代多参构造方法--建造者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些可选配置</span></span><br><span class="line">    <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">    <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">    <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">    <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ComputerB 自己充当 Director </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComputerB</span><span class="params">(ComputerBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = builder.mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = builder.cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = builder.hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = builder.powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = builder.graphicsCard ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mouse = builder.mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = builder.computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = builder.mousePad ;</span><br><span class="line">        <span class="keyword">this</span>.other = builder.other ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 声明一个静态内存类 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一个电脑的必须配置</span></span><br><span class="line">        <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">        <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">        <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">        <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">        <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其它一些可选配置</span></span><br><span class="line">        <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">        <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">        <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">        <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里声明一些必须要传的参数「规定这些参数是必须传的，这里只是举例，再实中可能参数都是可选的」</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ComputerBuilder</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,String graphicsCard)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">            <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">            <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">            <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	... 其它的一些 setXXX() 方法</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 生成最终的产品</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerB <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComputerB(<span class="keyword">this</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码注释非常详细，乍一看好像和建造者模式没有毛关系，但是我们细细一分析这个确实是一个建造者模式，我们看一看：产品是–&gt;ComputerB,具体的建造者是一个静态内存类–&gt;ComputerBuilder,但是没有抽象的建造者和指挥者「其实 ComputerB 充当的就是指挥者的角色」，我们说过建造者模式中 <strong>指挥者</strong> 和 <strong>抽象建造者</strong> 都不是必须的，所以这是一个典型的建造者模式</p>
<ul>
<li>测试类 Test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用建造者模式</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(<span class="string">"主板"</span>,<span class="string">"cpu"</span>,<span class="string">"hd"</span>,<span class="string">"电源"</span>,<span class="string">"显卡"</span></span><br><span class="line">        ,<span class="string">"鼠标"</span>,<span class="string">"机箱"</span>,<span class="string">"鼠标垫"</span>) ;</span><br><span class="line">        System.out.println(<span class="string">"使用普通的构造方法组装电脑："</span>+computer.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用建造者模式</span></span><br><span class="line">        ComputerB computerB = <span class="keyword">new</span> ComputerB.ComputerBuilder(<span class="string">"主板"</span>,<span class="string">"cpu"</span>,<span class="string">"hd"</span>,<span class="string">"电源"</span>,<span class="string">"显卡"</span>)</span><br><span class="line">                .setMouse(<span class="string">"鼠标"</span>).setMousePad(<span class="string">"垫子"</span>).build() ;</span><br><span class="line">        System.out.println(<span class="string">"使用建造者模式组装电脑："</span>+computerB.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-建造者模式的优缺点"><a href="#三-建造者模式的优缺点" class="headerlink" title="三.建造者模式的优缺点"></a>三.建造者模式的优缺点</h2><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>1、使创建产品的步骤「把创建产品步骤放在不同的方法中，更加清晰直观」和产品本身分离，即使用相同的创建过程要吧创建出不同的产品</li>
<li>2、每个建造者都是独立的互不影响，这样就达到解耦的目的，所以如果想要替换现有的建造者那非常方便，添加一个实现即可。</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>1、只适用于产品具有相同的特点「过程和步骤」，如果产品之间差异非常大，则不适用「使用范围受限」</li>
<li>2、万一那天产品内部发生改变，那多个建造者都要修改，成本太大</li>
</ul>
<h2 id="四-建造者模式-VS-简单工厂模式"><a href="#四-建造者模式-VS-简单工厂模式" class="headerlink" title="四.建造者模式 VS 简单工厂模式"></a>四.建造者模式 VS 简单工厂模式</h2><blockquote>
<p>相似点</p>
</blockquote>
<p>它们都属于创建型模式【都是创建产品的】</p>
<blockquote>
<p>区别</p>
</blockquote>
<ul>
<li>1、创建对象的粒度不同</li>
</ul>
<p>工厂模式创建的对象都是一个鸟样子，而建造者模式创建的是一个复合产品，由各个复杂的部件组成，部件不同所构成的产品也不同</p>
<ul>
<li>2、关注点不同：</li>
</ul>
<p>工厂模式注重只要把这个对象创建出来就 o 了「不关心这个产品的组成部分」，而建造者模式不似要创造出这个产品，还有知道这个产品的组成部分</p>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>
<p>JavaMail的<code>MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code>MimeMessage</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">textpart.setContent(body, <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> ByteArrayDataSource(input, <span class="string">"application/octet-stream"</span>)));</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br><span class="line"></span><br><span class="line">MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">"me@example.com"</span>));</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(<span class="string">"xiaoming@somewhere.com"</span>));</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.setSubject(<span class="string">"Hello"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.setContent(multipart);</span><br></pre></td></tr></table></figure>

<p>很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(secure ? <span class="string">"https://"</span> : <span class="string">"http://"</span>)</span><br><span class="line">       .append(<span class="string">"www.liaoxuefeng.com"</span>)</span><br><span class="line">       .append(<span class="string">"/"</span>)</span><br><span class="line">       .append(<span class="string">"?t=0"</span>);</span><br><span class="line">String url = builder.toString();</span><br></pre></td></tr></table></figure>

<p>由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = URLBuilder.builder() <span class="comment">// 创建Builder</span></span><br><span class="line">        .setDomain(<span class="string">"www.liaoxuefeng.com"</span>) <span class="comment">// 设置domain</span></span><br><span class="line">        .setScheme(<span class="string">"https"</span>) <span class="comment">// 设置scheme</span></span><br><span class="line">        .setPath(<span class="string">"/"</span>) <span class="comment">// 设置路径</span></span><br><span class="line">        .setQuery(Map.of(<span class="string">"a"</span>, <span class="string">"123"</span>, <span class="string">"q"</span>, <span class="string">"K&amp;R"</span>)) <span class="comment">// 设置query</span></span><br><span class="line">        .build(); <span class="comment">// 完成build</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常量池</title>
    <url>/2020/03/13/Java%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/1450501" target="_blank" rel="noopener">Java常量池</a></p>
<p><a href="https://blog.csdn.net/zm13007310400/article/details/77534349" target="_blank" rel="noopener">Java中的常量池(字符串常量池、class常量池和运行时常量池)</a></p>
<p><a href="https://www.jianshu.com/p/c7f47de2ee80" target="_blank" rel="noopener">Java常量池理解与总结</a></p>
<p>Java 中的常量池主要分为 <strong>Class文件常量池</strong>，<strong>运行时常量池</strong>，<strong>全局字符串常量池</strong></p>
<h1 id="Class-文件常量池"><a href="#Class-文件常量池" class="headerlink" title="Class 文件常量池"></a>Class 文件常量池</h1><p>class 文件是一组以字节为单位的二进制数据流，在 java 在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 class文件中存在常量池（非运行时常量池），其在编译阶段就已经确定。</p>
<a id="more"></a>

<p>通过一个简单的例子说明情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0x101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> temp = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = temp + v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 javac 命令编译之后，用 javap -v 命令查看编译后的文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">developer</span>.<span class="title">es</span>.<span class="title">test</span>.<span class="title">demo</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#30         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #5.#31         // org/developer/es/test/demo.value:I</span><br><span class="line">   #3 = String             #32            // abc</span><br><span class="line">   #4 = Fieldref           #5.#33         // org/developer/es/test/demo.s:Ljava/lang/String;</span><br><span class="line">   #5 = Class              #34            // org/developer/es/test/demo</span><br><span class="line">   #6 = Class              #35            // java/lang/Object</span><br><span class="line">   #7 = Utf8               value</span><br><span class="line">   #8 = Utf8               I</span><br><span class="line">   #9 = Utf8               s</span><br><span class="line">  #10 = Utf8               Ljava/lang/String;</span><br><span class="line">  #11 = Utf8               f</span><br><span class="line">  #12 = Utf8               ConstantValue</span><br><span class="line">  #13 = Integer            257</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lorg/developer/es/test/demo;</span><br><span class="line">  #21 = Utf8               setValue</span><br><span class="line">  #22 = Utf8               (I)V</span><br><span class="line">  #23 = Utf8               v</span><br><span class="line">  #24 = Utf8               temp</span><br><span class="line">  #25 = Utf8               MethodParameters</span><br><span class="line">  #26 = Utf8               getValue</span><br><span class="line">  #27 = Utf8               ()I</span><br><span class="line">  #28 = Utf8               SourceFile</span><br><span class="line">  #29 = Utf8               demo.java</span><br><span class="line">  #30 = NameAndType        #14:#15        // "&lt;init&gt;":()V</span><br><span class="line">  #31 = NameAndType        #7:#8          // value:I</span><br><span class="line">  #32 = Utf8               abc</span><br><span class="line">  #33 = NameAndType        #9:#10         // s:Ljava/lang/String;</span><br><span class="line">  #34 = Utf8               org/developer/es/test/demo</span><br><span class="line">  #35 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>

<p>class 文件常量池主要存放两大常量：<strong>字面量和符号引用</strong></p>
<p>1) 字面量：字面量接近java语言层面的常量概念，主要包括：</p>
<ul>
<li><strong>文本字符串</strong>，也就是我们经常申明的： public String s = “abc”;中的”abc”</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#9 = Utf8               s</span><br><span class="line">#3 = String             #31            // abc</span><br><span class="line">#31 = Utf8              abc</span><br></pre></td></tr></table></figure>

<ul>
<li>用final修饰的成员变量，包括静态变量、实例变量和局部变量</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#11 = Utf8               f</span><br><span class="line"> #12 = Utf8               ConstantValue</span><br><span class="line"> #13 = Integer            257</span><br></pre></td></tr></table></figure>

<p>2) 符号引用 符号引用主要设涉及编译原理方面的概念，包括下面三类常量:</p>
<ul>
<li>类和接口的全限定名，也就是java/lang/String;这样，将类名中原来的”.”替换为”/“得到的，主要用于在运行时解析得到类的直接引用，像上面</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#5 = Class              #33            // JavaBasicKnowledge/JavaBean</span><br><span class="line"> #33 = Utf8               JavaBasicKnowledge/JavaBean</span><br></pre></td></tr></table></figure>

<ul>
<li>字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量和实例级的变量</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I</span><br><span class="line"> #5 = Class              #33            // JavaBasicKnowledge/JavaBean</span><br><span class="line"> #32 = NameAndType       #7:#8          // value:I</span><br><span class="line"></span><br><span class="line"> #7 = Utf8               value</span><br><span class="line"> #8 = Utf8               I</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这两个是局部变量，值保留字段名称</span></span><br><span class="line"> #23 = Utf8               v</span><br><span class="line"> #24 = Utf8               temp</span><br></pre></td></tr></table></figure>

<p>可以看到，对于方法中的局部变量名，class文件的常量池仅仅保存字段名。</p>
<ul>
<li>方法中的名称和描述符，也即参数类型+返回值</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#21 = Utf8               setValue</span><br><span class="line"> #22 = Utf8               (I)V</span><br><span class="line"></span><br><span class="line"> #25 = Utf8               getValue</span><br><span class="line"> #26 = Utf8               ()I</span><br></pre></td></tr></table></figure>

<p><strong><em>什么时字面量和符号引用</em></strong></p>
<ul>
<li>字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量</li>
<li>符号引用：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符</li>
</ul>
<h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过<strong>加载、链接（验证、准备、解析）、初始化</strong>，在第一步加载的时候需要完成：</p>
<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class，它作为方法区这个类的各种数据访问的入口。</li>
</ul>
<p>类对象和普通对象是不同的，类对象是在类加载的时候完成的，是jvm创建的并且是单例的，作为这个类和外界交互的入口， 而普通的对象一般是在调用new之后创建。</p>
<p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下<strong>不同的类共用一个运行时常量池</strong>，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。</p>
<p>运行时常量池的作用是存储java class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p>
<p>运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。</p>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>常量池</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题汇总</title>
    <url>/2020/03/12/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="1-如果一条sql执行时间过长，如何优化…"><a href="#1-如果一条sql执行时间过长，如何优化…" class="headerlink" title="1.如果一条sql执行时间过长，如何优化…"></a>1.如果一条sql执行时间过长，如何优化…</h1><p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312230201.png" alt="img"></p>
<a id="more"></a>

<p>1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）</p>
<p>2、涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合</p>
<p>3、如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度</p>
<p>4、针对数量大的表进行历史表分离（如交易流水表）</p>
<p>5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</p>
<p>6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等</p>
<p>7、查看mysql执行日志，看看是否有其他方面的问题</p>
<h1 id="2-前端通过http请求后端的详细过程"><a href="#2-前端通过http请求后端的详细过程" class="headerlink" title="2.前端通过http请求后端的详细过程"></a>2.前端通过http请求后端的详细过程</h1><p>参考：</p>
<p><a href="https://juejin.im/post/5c3b21e4e51d455231347349#heading-6" target="_blank" rel="noopener">浅析一次HTTP请求</a></p>
<p><a href="https://www.jianshu.com/p/c1d6a294d3c0" target="_blank" rel="noopener">一次完整的HTTP请求与响应涉及了哪些知识？真的讲得好很细</a></p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232201.png" alt="img"></p>
<ul>
<li>Http 请求是依托于 TCP/IP 连接的，第一次连接的时候会进行 TCP 的三次握手</li>
<li>HTTP 通过 Keep-Alive 来进行持久连接，通过定时发送一个心跳包，来告诉服务端自己还活跃</li>
<li>HTTP 连接的断开也会导致TCP的四次挥手，但是如果服务器判断满足条件，会合并 ACK 和 FIN 信号，进而转化为三次挥手。</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232501.png" alt="img"></p>
<p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）</p>
<p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。</p>
<p>通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232701.png" alt="img"></p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="Http是什么？"><a href="#Http是什么？" class="headerlink" title="Http是什么？"></a>Http是什么？</h3><p>通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p>
<p><strong>四个基于：</strong></p>
<p><strong>请求与响应：</strong>客户端发送请求，服务器端响应数据</p>
<p><strong>无状态的：</strong>协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</p>
<p><strong>应用层：</strong>Http是属于应用层的协议，配合TCP/IP使用。</p>
<p><strong>TCP/IP：</strong>Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</p>
<p><strong>针对无状态的一些解决策略：</strong></p>
<p>有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。</p>
<p>HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。<br> 等等还有很多。。。。。。</p>
<p>下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。</p>
<p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/1.png" alt="img"></p>
<h3 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.请求行</h3><p>请求行分为三个部分：请求方法、请求地址和协议版本</p>
<p><strong>请求方法</strong></p>
<p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p>
<p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p>
<p><strong>请求地址</strong></p>
<p>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</p>
<p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</p>
<p><strong>端口和路径有时可以省略（HTTP默认端口号是80）</strong></p>
<p>如下例：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/2.png" alt="img"></p>
<p>有时会带参数，GET请求</p>
<p><strong>协议版本</strong></p>
<p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<h3 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.请求头部</h3><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p>
<p>常见请求头如下：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/3.png" alt="img"></p>
<p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p>
<h3 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.请求数据</h3><p>可选部分，比如GET请求就没有请求数据。</p>
<p>下面是一个POST方法的请求报文：</p>
<blockquote>
<p>POST 　/index.php　HTTP/1.1                                                                　　 请求行<br> Host: localhost<br> User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头<br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br> Accept-Language: zh-cn,zh;q=0.5<br> Accept-Encoding: gzip, deflate<br> Connection: keep-alive<br> Referer: <a href="https://link.jianshu.com?t=http://localhost/" target="_blank" rel="noopener">http://localhost/</a><br> Content-Length：25<br> Content-Type：application/x-www-form-urlencoded<br> 　空行<br> username=aa&amp;password=1234　　请求数据</p>
</blockquote>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p><img src="http://q6s1x2hw2.bkt.clouddn.com/4.png" alt="img"></p>
<p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p>
<h3 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h3><p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p>
<p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p>
<p><strong>状态码</strong></p>
<p>状态代码为3位数字。<br> 1xx：指示信息–表示请求已接收，继续处理。<br> 2xx：成功–表示请求已被成功接收、理解、接受。<br> 3xx：重定向–要完成请求必须进行更进一步的操作。<br> 4xx：客户端错误–请求有语法错误或请求无法实现。<br> 5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>下面列举几个常见的：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/5.png" alt="img"></p>
<h3 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2.响应头部"></a>2.响应头部</h3><p>与请求头部类似，为响应报文添加了一些附加信息</p>
<p>常见响应头部如下：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/6.png" alt="img"></p>
<h3 id="3-响应数据"><a href="#3-响应数据" class="headerlink" title="3.响应数据"></a>3.响应数据</h3><p>用于存放需要返回给客户端的数据信息。</p>
<p>下面是一个响应报文的实例：</p>
<blockquote>
<p>HTTP/1.1 200 OK　　状态行</p>
</blockquote>
<p>Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部<br> Server: Apache/2.2.8 (Win32) PHP/5.2.5<br> X-Powered-By: PHP/5.2.5<br> Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/<br> Expires: Thu, 19 Nov 1981 08:52:00 GMT<br> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br> Pragma: no-cache<br> Content-Length: 4393<br> Keep-Alive: timeout=5, max=100<br> Connection: Keep-Alive<br> Content-Type: text/html; charset=utf-8</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">空行</span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span>&gt;</span>　　响应数据</span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP响应示例<span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> Hello HTTP!</span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于请求头部和响应头部的知识点很多，这里只是简单介绍。</p>
<p>通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接</p>
<h1 id="递归算-n-的阶乘"><a href="#递归算-n-的阶乘" class="headerlink" title="递归算 n 的阶乘"></a>递归算 n 的阶乘</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Sytem.out.print(rec(m) + <span class="string">" "</span>);</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">rec</span><span class="params">(Integer m)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        m = m * rec( m - <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂模式</title>
    <url>/2020/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>参考：<a href="https://juejin.im/entry/58f5e080b123db2fa2b3c4c6" target="_blank" rel="noopener">工厂模式</a></p>
<p>工厂模式分为三种：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<blockquote>
<p>设计模式只是思想，没有固定的代码</p>
</blockquote>
<a id="more"></a>

<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式其实并不是一种设计模式，更多的是一种编程习惯</p>
<blockquote>
<p>定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或者接口</p>
</blockquote>
<p><strong>适用场景</strong></p>
<p>其实由定义也大概能推测出其使用场景，首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>shape.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圆形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"CircleShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"draw: CircleShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正方形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RectShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(  <span class="string">"RectShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(  <span class="string">"draw: RectShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriangleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"TriangleShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"draw: TriangleShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是工厂类的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ShapeFactory"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Shape shape = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"circle"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> CircleShape();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"rect"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> RectShape();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"triangle"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> TriangleShape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在这个工厂类中通过传入不同的type可以new不同的形状，<strong>返回结果为Shape 类型</strong>，这个就是简单工厂核心的地方了。</p>
<p>客户端调用</p>
<p>画圆形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"circle"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>

<p>画正方形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"rect"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>

<p>画三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"triangle"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式是简单工厂的进一步深化，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说<strong>每个对象都有一个与之对应的工厂</strong>。</p>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
</blockquote>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>现在需要设计一个这样的图片加载类，它具有多个图片加载器，用来加载jpg，png，gif格式的图片，每个加载器都有一个 read() 方法，用于读取图片。下面我们完成这个图片加载类。</p>
<p>首先完成图片加载器的设计，编写一个加载器的公共接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reader 里面只有一个read（）方法，然后完成各个图片加载器的代码。</p>
<p>Jpg图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read jpg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Png图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PngReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read png"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gif图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GifReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read gif"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们按照定义所说定义一个抽象的工厂接口ReaderFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Reader <span class="title">getReader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面有一个getReader（）方法返回我们的Reader 类，接下来我们把上面定义好的每个图片加载器都提供一个工厂类，这些工厂类实现了ReaderFactory 。</p>
<p>Jpg加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpgReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Png加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PngReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PngReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gif加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GifReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GifReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个工厂类中我们都通过复写的getReader（）方法返回各自的图片加载器对象。</p>
<p>客户端使用</p>
<p>读取Jpg</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> JpgReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>

<p>读取Png</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> PngReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>

<p>读取Gif</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> GifReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<p>（1）客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了创建过程。<br>（2）客户端可以通过子类来指定创建对应的对象。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式是一个比较复杂的创建型模式</p>
<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应多个实际工厂，每个实际工厂负责创建多个实际产品。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                ┌────────┐</span><br><span class="line">                             ─ &gt;│ProductA│</span><br><span class="line">┌────────┐    ┌─────────┐   │   └────────┘</span><br><span class="line">│ Client │─ ─&gt;│ Factory │─ ─</span><br><span class="line">└────────┘    └─────────┘   │   ┌────────┐</span><br><span class="line">                   ▲         ─ &gt;│ProductB│</span><br><span class="line">           ┌───────┴───────┐    └────────┘</span><br><span class="line">           │               │</span><br><span class="line">      ┌─────────┐     ┌─────────┐</span><br><span class="line">      │Factory1 │     │Factory2 │</span><br><span class="line">      └─────────┘     └─────────┘</span><br><span class="line">           │   ┌─────────┐ │   ┌─────────┐</span><br><span class="line">            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│</span><br><span class="line">           │   └─────────┘ │   └─────────┘</span><br><span class="line">               ┌─────────┐     ┌─────────┐</span><br><span class="line">           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│</span><br><span class="line">               └─────────┘     └─────────┘</span><br></pre></td></tr></table></figure>

<p>为形状创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实现接口的实体类。</p>
<p><em>Rectangle.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为颜色创建一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Red::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Green::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Blue::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"RED"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"GREEN"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"BLUE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"COLOR"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状工厂</span></span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色工厂</span></span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      Color color1 = colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      Color color2 = colorFactory.getColor(<span class="string">"Green"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">      Color color3 = colorFactory.getColor(<span class="string">"BLUE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合AOP记录接口访问日志</title>
    <url>/2020/03/12/SpringBoot%E6%95%B4%E5%90%88AOP%E8%AE%B0%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/technology/aop_log" target="_blank" rel="noopener">SpringBoot整合AOP</a></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><blockquote>
<p>AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程，通过 <strong>预编译</strong> 方式和 <strong>运行期动态代理</strong> 实现程序功能的统一维护的一种技术。利用 AOP 可以对业务逻辑的个部分进行隔离，从而从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
</blockquote>
<a id="more"></a>

<h2 id="AOP的相关术语"><a href="#AOP的相关术语" class="headerlink" title="AOP的相关术语"></a>AOP的相关术语</h2><h3 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知(Advice)"></a>通知(Advice)</h3><p>通知描述了切面要完成的工作以及何时执行。比如我们的日志切面需要记录每个接口调用时长，就需要在接口调用前后分别记录当前时间，再取差值。</p>
<ul>
<li>前置通知（Before）：在目标方法调用前调用通知功能；</li>
<li>后置通知（After）：在目标方法调用之后调用通知功能，不关心方法的返回结果；</li>
<li>返回通知（AfterReturning）：在目标方法成功执行之后调用通知功能；</li>
<li>异常通知（AfterThrowing）：在目标方法抛出异常后调用通知功能；</li>
<li>环绕通知（Around）：通知包裹了目标方法，在目标方法调用之前和之后执行自定义的行为。</li>
</ul>
<h3 id="连接点-JoinPoint"><a href="#连接点-JoinPoint" class="headerlink" title="连接点(JoinPoint)"></a>连接点(JoinPoint)</h3><p>通知功能被应用的时机，比如接口方法被调用的时候就是日志切面的连接点</p>
<h3 id="切点-Pointcut"><a href="#切点-Pointcut" class="headerlink" title="切点(Pointcut)"></a>切点(Pointcut)</h3><p>切点定义了通知功能被应用的范围。比如日志切面的应用范围就是所有接口，即所有controller层的接口方法。</p>
<h3 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h3><p>切面是通知和切点的结合，定义了何时，何地应用通知功能</p>
<h3 id="引入-Introduction"><a href="#引入-Introduction" class="headerlink" title="引入(Introduction)"></a>引入(Introduction)</h3><p>在无需修改现有类的情况下，向现有的类添加新方法或属性。</p>
<h3 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h3><p>把切面应用到目标对象并创建新的代理对象的过程。</p>
<h2 id="Spring中使用注解创建切面"><a href="#Spring中使用注解创建切面" class="headerlink" title="Spring中使用注解创建切面"></a>Spring中使用注解创建切面</h2><h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a><a href="http://www.macrozheng.com/#/technology/aop_log?id=相关注解" target="_blank" rel="noopener">相关注解</a></h3><ul>
<li>@Aspect：用于定义切面</li>
<li>@Before：通知方法会在目标方法调用之前执行</li>
<li>@After：通知方法会在目标方法返回或抛出异常后执行</li>
<li>@AfterReturning：通知方法会在目标方法返回后执行</li>
<li>@AfterThrowing：通知方法会在目标方法抛出异常后执行</li>
<li>@Around：通知方法会将目标方法封装起来</li>
<li>@Pointcut：定义切点表达式</li>
</ul>
<h3 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a><a href="http://www.macrozheng.com/#/technology/aop_log?id=切点表达式" target="_blank" rel="noopener">切点表达式</a></h3><p>指定了通知被应用的范围，表达式格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(方法修饰符 返回类型 方法所属的包.类名.方法名称(方法参数)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.macro.mall.tiny.controller包中所有类的public方法都应用切面里的通知</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.macro.mall.tiny.controller.*.*(..))</span><br><span class="line"><span class="comment">//com.macro.mall.tiny.service包及其子包下所有类中的所有方法都应用切面里的通知</span></span><br><span class="line">execution(* com.macro.mall.tiny.service..*.*(..))</span><br><span class="line"><span class="comment">//com.macro.mall.tiny.service.PmsBrandService类中的所有方法都应用切面里的通知</span></span><br><span class="line">execution(* com.macro.mall.tiny.service.PmsBrandService.*(..))</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>添加日志信息封装类 WebLog</p>
<blockquote>
<p>用于封装需要记录的日志信息，包括操作的描述、时间、消耗时间、url、请求参数和返回结果等信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.dto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller层的日志封装类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLog</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消耗时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer spendTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IP地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求返回的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加切面类 WebLogAspect</p>
<blockquote>
<p>定义了一个日志切面，在环绕通知中获取日志需要的信息，并应用到controller层中所有的public方法中去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 统一日志处理切面</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/12 17:22</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WebLogAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * org.developer.es.api.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"webLog()"</span>, returning = <span class="string">"ret"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知=前置 + 目标方法执行 + 后置通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取当前请求对象</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        <span class="comment">//记录请求信息</span></span><br><span class="line">        WebLog webLog = <span class="keyword">new</span> WebLog();</span><br><span class="line">        <span class="comment">//proceed 方法就是用于启动目标方法执行</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="comment">//获取被调用的签名</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="comment">//转换为方法签名</span></span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        <span class="comment">//获取 controller 的方法</span></span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        <span class="comment">//如果存在 ApiOperation 注解，获取描述的值</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(ApiOperation<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">            ApiOperation apiOperation = method.getAnnotation(ApiOperation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            webLog.setDescription(apiOperation.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        String urlStr = request.getRequestURL().toString();</span><br><span class="line">        webLog.setBasePath(StrUtil.removeSuffix(urlStr, URLUtil.url(urlStr).getPath()));</span><br><span class="line">        webLog.setIp(request.getRemoteUser());</span><br><span class="line">        webLog.setMethod(request.getMethod());</span><br><span class="line">        webLog.setParameter(getParameter(method, joinPoint.getArgs()));</span><br><span class="line">        webLog.setResult(result);</span><br><span class="line">        webLog.setSpendTime((<span class="keyword">int</span>) (endTime - startTime));</span><br><span class="line">        webLog.setStartTime(startTime);</span><br><span class="line">        webLog.setUri(request.getRequestURI());</span><br><span class="line">        webLog.setUrl(request.getRequestURL().toString());</span><br><span class="line">        logger.info(<span class="string">"&#123;&#125; \n"</span>, JSONUtil.parse(webLog));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据方法和传入的参数获取请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getParameter</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; argList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取方法的参数</span></span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将 RequestBody 注解修饰的参数作为请求参数</span></span><br><span class="line">            RequestBody requestBody = parameters[i].getAnnotation(RequestBody<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(requestBody != <span class="keyword">null</span>)&#123;</span><br><span class="line">                argList.add(args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 RequestParam 注解修饰的参数作为请求参数</span></span><br><span class="line">            RequestParam requestParam = parameters[i].getAnnotation(RequestParam<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (requestParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                String key = parameters[i].getName();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(requestParam.value())) &#123;</span><br><span class="line">                    key = requestParam.value();</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(key, args[i]);</span><br><span class="line">                argList.add(map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> argList.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> argList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200313101900106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313101627277"></p>
<p><img src="https://img-blog.csdnimg.cn/2020031310191371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313101704157"></p>
<p>当执行遇到错误的时候，就会有以下信息</p>
<p><img src="https://img-blog.csdnimg.cn/20200313102657103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313102544808"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>SpringBoot 官方建议使用 logback-spring.xml</strong></p>
<p>logback.xml：应用启动时会直接被日志框架 logback 识别而被使用，不经过 SpringBoot</p>
<p>logback-spring.xml：logback日志框架就不能直接识别到，而会由 Spring Boot 解析此日志配置文件</p>
<h3 id="SpringBoot-加载-logback-spring-xml"><a href="#SpringBoot-加载-logback-spring-xml" class="headerlink" title="SpringBoot 加载 logback-spring.xml"></a>SpringBoot 加载 logback-spring.xml</h3><p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/27874182" target="_blank" rel="noopener">Spring Boot中logback配置文件加载过程</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.logging.logback.LogbackLoggingSystem</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getStandardConfigLocations() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"logback-test.groovy"</span>, <span class="string">"logback-test.xml"</span>, <span class="string">"logback.groovy"</span>,</span><br><span class="line">                         <span class="string">"logback.xml"</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这里可以看到spring boot中支持的logback配置文件格式，就是在logback自配置文件（logback-test.xml, logback.xml等）基础上文件名后面加了“-spring”，如logback-test-spring, logback-spring等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the spring config locations for this system. By default this method returns</span></span><br><span class="line"><span class="comment"> * a set of locations based on &#123;<span class="doctag">@link</span> #getStandardConfigLocations()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the spring config locations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getSpringInitializationConfig()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String[] getSpringConfigLocations() &#123;</span><br><span class="line">    String[] locations = getStandardConfigLocations();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">        String extension = StringUtils.getFilenameExtension(locations[i]);</span><br><span class="line">        locations[i] = locations[i].substring(<span class="number">0</span>,</span><br><span class="line">                                              locations[i].length() - extension.length() - <span class="number">1</span>) + <span class="string">"-spring."</span></span><br><span class="line">            + extension;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> locations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>重点关注org.springframework.boot.logging.logback.LogbackLoggingSystem</em></strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020Java技术栈</title>
    <url>/2020/03/12/2020Java%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<p>回想飞逝而去的2019，在学生和职场人身份之间的转换，一切匆匆。好像自己的技术栈也没有提升和丰富多少，最近也不断在思考，到底哪里出了问题…..</p>
<p>所以先暂时参考下尚硅谷的2020的学习路线吧！</p>
<a id="more"></a>

<p><img src="http://q6s1x2hw2.bkt.clouddn.com/18884a1af98c92fcd05324b2c9bc7938c2676bdf.jpg" alt="预览图"></p>
<p>数据的路线</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/1991c1c3921161f01d991cc2b3a0b6a851b9ae52.jpg" alt="img"></p>
<p>目前就暂时以这个标准作为学习的方向吧！奥利给，加油！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像加速地址</title>
    <url>/2020/03/11/Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>由于最近想入门 ELK 框架，所以找到一篇<a href="[http://www.macrozheng.com/#/technology/mall_tiny_elk?id=%e5%88%9b%e5%bb%ba%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%ad%98%e6%94%be%e7%9b%ae%e5%bd%95%e5%b9%b6%e4%b8%8a%e4%bc%a0%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%88%b0%e8%af%a5%e7%9b%ae%e5%bd%95](http://www.macrozheng.com/#/technology/mall_tiny_elk?id=创建配置文件存放目录并上传配置文件到该目录)">大神的文章</a>来练练手。</p>
<p>可是 Docker 的 pull 镜像的速度差点让我吐血了 orz；</p>
<p>后面通过神奇的谷歌搜索，找到了<a href="http://einverne.github.io/post/2018/03/docker-mirror.html" target="_blank" rel="noopener">一篇很不错的文章</a></p>
<a id="more"></a>

<blockquote>
<h2 id="使用-registry-mirrors"><a href="#使用-registry-mirrors" class="headerlink" title="使用 registry mirrors"></a>使用 registry mirrors</h2></blockquote>
<p>手动修改 Docker 配置 <code>/etc/docker/daemon.json</code> 文件增加 docker registry 镜像：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"加速地址"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"insecure-registries"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改其中的 <code>加速地址</code>，不同的服务提供的镜像加速地址不一样。</p>
<p>记得修改配置之后 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p> 重启 docker。下面就总结一下国内的 Docker 镜像站点。</p>
<p>修改后使用 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>

<p> 来检查配置是否生效。</p>
<p>如果下方公开的镜像速度不佳的话，尝试阿里云的镜像，需要开发者账号。</p>
<h3 id="Docker-cn"><a href="#Docker-cn" class="headerlink" title="Docker cn"></a>Docker cn</h3><p>Docker 官方提供的镜像：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>

<h3 id="Azure"><a href="#Azure" class="headerlink" title="Azure"></a>Azure</h3><p>Azure <a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">中国镜像</a> 包括 Docker Hub、GCR、Quay。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//dockerhub.azk8s.cn</span></span><br></pre></td></tr></table></figure>

<h3 id="网易-亲测真的非常有效"><a href="#网易-亲测真的非常有效" class="headerlink" title="网易(亲测真的非常有效)"></a>网易(亲测真的非常有效)</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//hub-mirror.c.163.com</span></span><br></pre></td></tr></table></figure>

<h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>腾讯只能在腾讯云上使用：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//mirror.ccs.tencentyun.com</span></span><br></pre></td></tr></table></figure>

<h3 id="科大镜像-ustc"><a href="#科大镜像-ustc" class="headerlink" title="科大镜像 ustc"></a>科大镜像 ustc</h3><p><a href="https://mirrors.ustc.edu.cn/help/dockerhub.html" target="_blank" rel="noopener">科大</a> 包括 Docker Hub、GCR、Quay。<a href="http://einverne.github.io/post/2018/03/docker-mirror.html#fn:ustc" target="_blank" rel="noopener">1</a></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//docker.mirrors.ustc.edu.cn</span></span><br></pre></td></tr></table></figure>

<h3 id="七牛"><a href="#七牛" class="headerlink" title="七牛"></a>七牛</h3><p><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//<span class="keyword">reg</span>-mirror.qiniu.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>

<h3 id="DaoCloud"><a href="#DaoCloud" class="headerlink" title="DaoCloud"></a>DaoCloud</h3><p>DaoCloud <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">提供</a> 的加速地址：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//6ce28dce.m.daocloud.io</span></span><br></pre></td></tr></table></figure>

<p>这个地址不同用户看起开不一样，可以使用我的，也可以自己注册。</p>
<p>这个地址不知道是不是长久地址，不过失效，可以到他的官方<a href="http://6ce28dce.m.daocloud.io/" target="_blank" rel="noopener">网站</a> 查看。</p>
<h3 id="Docker-cn-1"><a href="#Docker-cn-1" class="headerlink" title="Docker cn"></a>Docker cn</h3><p>也可以使用 Docker 官方提供的镜像</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>

<p>官网<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">地址</a></p>
<h3 id="个人维护的镜像"><a href="#个人维护的镜像" class="headerlink" title="个人维护的镜像"></a>个人维护的镜像</h3><p><a href="https://mritd.me/2017/03/21/private-maintenance-docker-mirror-registry/" target="_blank" rel="noopener">mritd</a> 反向代理了主流的三大仓库（Docker Hub，gcr.io，quay.io）。</p>
<h2 id="docker-registries"><a href="#docker-registries" class="headerlink" title="docker registries"></a>docker registries</h2><p>不得不说的 hub.docker.com，官方提供</p>
<h3 id="daocloud-hub"><a href="#daocloud-hub" class="headerlink" title="daocloud hub"></a>daocloud hub</h3><p>这是国内 DaoCloud 公司提供的</p>
<ul>
<li><a href="https://hub.daocloud.io/" target="_blank" rel="noopener">https://hub.daocloud.io/</a></li>
</ul>
<h3 id="gcr-io"><a href="#gcr-io" class="headerlink" title="gcr.io"></a>gcr.io</h3><p>可以通过下面的链接查看 gcr.io 中存在镜像，类似于直接在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 中搜索查看。</p>
<ul>
<li><a href="https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers" target="_blank" rel="noopener">https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers</a></li>
</ul>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>这里是阿里云提供的镜像托管服务</p>
<ul>
<li><a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></li>
</ul>
<p>然后<a href="http://dockone.io/question/1216" target="_blank" rel="noopener">有人</a> 把 <code>gcr.io/google-containers</code> 下所有的 Docker 镜像都同步到了中央库</p>
<ul>
<li><a href="https://hub.docker.com/u/googlecontainer/" target="_blank" rel="noopener">https://hub.docker.com/u/googlecontainer/</a></li>
</ul>
<p>更多的 registry 可以参考<a href="https://github.com/veggiemonk/awesome-docker#registry" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Velocity总结</title>
    <url>/2020/03/11/Velocity%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h1><p>参考：<a href="https://blog.csdn.net/fyyyr/article/details/84839595" target="_blank" rel="noopener">https://blog.csdn.net/fyyyr/article/details/84839595</a></p>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--velocity模板引擎依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写一个模板代码</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package $&#123;package&#125;.controller</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class $&#123;className&#125;Controller&#123;</span><br><span class="line"></span><br><span class="line">    public void get$&#123;Object&#125;()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set$&#123;Object&#125;()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VelocityEngine ve = <span class="keyword">new</span> VelocityEngine();</span><br><span class="line"><span class="comment">//设置资源路径</span></span><br><span class="line">ve.setProperty(RuntimeConstants.RESOURCE_LOADER,<span class="string">"classpath"</span>);</span><br><span class="line">ve.setProperty(<span class="string">"classpath.resource.loader.class"</span>, ClasspathResourceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">ve.init();</span><br><span class="line"></span><br><span class="line"><span class="comment">//载入模板</span></span><br><span class="line">Template t = ve.getTemplate(<span class="string">"templates/controller.java.vm"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义替换规则</span></span><br><span class="line">VelocityContext context = <span class="keyword">new</span> VelocityContext();</span><br><span class="line">context.put(<span class="string">"package"</span>,<span class="string">"org.developer.velocity.api"</span>);</span><br><span class="line">context.put(<span class="string">"className"</span>,<span class="string">"velocityDemo"</span>);</span><br><span class="line">context.put(<span class="string">"Object"</span>,<span class="string">"Value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储合并后的结果</span></span><br><span class="line">StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">t.merge(context,sw);</span><br><span class="line">String r = sw.toString();</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"##r:   \n"</span> +r);</span><br></pre></td></tr></table></figure>

<p>生成结果：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package org.developer.velocity.api.controller</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.<span class="keyword">annotation</span>.<span class="title">RestController</span>;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">velocityDemoController</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    public void getValue()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200311004417510.png" alt="image-20200311004417510"></p>
]]></content>
      <categories>
        <category>Velocity</category>
      </categories>
      <tags>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title>h-g源码解析</title>
    <url>/2020/03/10/h-g%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<ol>
<li><p>capitalizeFully 通过指定的符号将所有分隔的字母的首字母大写</p>
</li>
<li><p>java.util.Properties 继承自hashtable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>IOUtils.closeQuietly(out)</p>
<p>参考：<a href="https://www.jianshu.com/p/4edd1775b983" target="_blank" rel="noopener">commons.io-2.6 closeQuietly()</a></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeable.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>简化了流的关闭操作</em></strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>疫情下的影响</title>
    <url>/2020/03/10/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<p>2020 年伊始，新冠肺炎的汹涌来袭，我相信对于很多人来说的都是触不及防。</p>
<p>不出意外，我也成了这次疫情的 “受害者”。</p>
<p>2020农历新年才过几天，我就收到了前公司的主管的电话，当时兴奋的以为是转正的事宜，没想到的是解聘的通知…,在电话里，公司以 “莫须有” 的罪名把我裁了。很不幸，刚出社会就体验到了生活的冷暖，还记得那天是艳阳高照，春天还未到来，寒风依然猖獗，温暖的阳光照在身上，可是我却感受不到任何温度。</p>
<p>同样的我对几个朋友和同事也进行了交流，以下是他们对这次疫情的反映。</p>
<a id="more"></a>

<ul>
<li>朋友A</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192432.jpg" alt="image"></p>
<ul>
<li>朋友B</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192445.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192445.jpg"></p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192449.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192449.jpg"></p>
<ul>
<li>朋友C</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192453.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192453.jpg"></p>
<p>其实每个人的境遇差不多，在疫情面前，大家都是平等的，只有严守才能最终战胜疫情。</p>
<p>希望等到夏日炎炎的时候，大家都可以约好一起吃雪糕！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎ElasticSearch</title>
    <url>/2020/03/09/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticSearch/</url>
    <content><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>参考：<a href="https://mp.weixin.qq.com/s/stC_xMP1n3aQ-0ZNAc3eQA" target="_blank" rel="noopener">elasticsearch基础</a></p>
<blockquote>
<p>Elasticsearch 为开源的、分布式、基于 Restful API、支持 PB 甚至更高数量级的搜索引擎工具。</p>
</blockquote>
<p>文档主要还是参考 es 的官方文档，已经解释说明的非常详尽。<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html</a></p>
<p>Elasticsearch 使用 JavaScript Object Notation（或者 <a href="http://en.wikipedia.org/wiki/Json" target="_blank" rel="noopener"><em>JSON</em></a>）作为文档的序列化格式。JSON 序列化为大多数编程语言所支持，并且已经成为 NoSQL 领域的标准格式。 它简单、简洁、易于阅读。</p>
<table>
<thead>
<tr>
<th>ElasticSearch</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>index 索引</td>
<td>database 数据库</td>
</tr>
<tr>
<td>type 类型</td>
<td>table 表</td>
</tr>
<tr>
<td>document 文档</td>
<td>Row 行</td>
</tr>
<tr>
<td>field 属性</td>
<td>Column 字段</td>
</tr>
</tbody></table>
<a id="more"></a>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjXcNvIDv32BMwkVKqicrC8Tk3iciaUjfVTJtYAM9x1CSH2mwBEtlGPmh1L1icpOCbO46RTSqDj4Owjmzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>从上表中可以看出：</p>
<ol>
<li>MySQL 中的数据库（DataBase），等价于 ES 中的索引（Index）。</li>
<li>MySQL 中一个数据库下面有 N 张表（Table），等价于1个索引 Index 下面有 N 多类型（Type）。</li>
<li>MySQL 中一个数据库表（Table）下的数据由多行（Row）多列（column，属性）组成，等价于1个 Type 由多个文档（Document）和多 Field 组成。</li>
<li>MySQL 中定义表结构、设定字段类型等价于 ES 中的 Mapping。举例说明，在一个关系型数据库里面，Schema 定义了表、每个表的字段，还有表和字段之间的关系。与之对应的，在 ES 中，Mapping 定义索引下的 Type 的字段处理规则，即索引如何建立、索引类型、是否保存原始索引 JSON 文档、是否压缩原始 JSON 文档、是否需要分词处理、如何进行分词处理等。</li>
<li>MySQL 中的增 insert、删 delete、改 update、查 search 操作等价于 ES 中的增 PUT/POST、删 Delete、改 _update、查 GET。其中的修改指定条件的更新 update 等价于 ES 中的 update_by_query，指定条件的删除等价于 ES 中的 delete_by_query。</li>
<li>MySQL 中的 group by、avg、sum 等函数类似于 ES 中的 Aggregations 的部分特性。</li>
<li>MySQL 中的去重 distinct 类似 ES 中的 cardinality 操作。</li>
<li>MySQL 中的数据迁移等价于 ES 中的 reindex 操作。</li>
</ol>
<p>如下是传统的关系型数据库（如Oracle、MySQL）、非关系型的数据库（如 Mongo）所做不到的：</p>
<p>1.传统的关系型数据库虽然能支持类型“like 待检索词”模糊语句匹配，但无法进行全文检索（分词检索）。</p>
<p>这里的全文检索，举例如下。</p>
<p>“text”：”公路局正在治理解放大道路面积水问题”，对于这段待检索的文字，经过细粒度分词后能得出如下的分词结果：</p>
<blockquote>
<p>公路局、公路、路局、路、局正、正在、正、治理、治、理解、理、解放、解、放大、大道、大、道路、道、路面、路、面积、面、积水、积、水、问题</p>
</blockquote>
<p>如果进行全文检索，是针对以上分词后的结果逐个进行匹配，并由得分的高低快速的返回匹配结果。</p>
<p>这点，传统数据库几乎不可能做到。</p>
<p>2.非关系型数据库 Mongo 虽能进行简单的全文检索，但对中文支持的不好、数据量大性能会有问题，这点是在实际应用中总结出的。</p>
<p>查询最简单的语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/1</span><br></pre></td></tr></table></figure>

<p>语法：GET /index/type/id</p>
<p>其实还有许多更复杂的搜索，例如：轻量搜索，高亮搜索，全文搜索等等。</p>
<h3 id="bulk增删改操作"><a href="#bulk增删改操作" class="headerlink" title="bulk增删改操作"></a>bulk增删改操作</h3><blockquote>
<p>bulk api 对 json 的语法，有严格的要求，每个 json 串不能换行，只能放一行，同时一个 json 串和一个 json 串之间，必须有一个换行</p>
</blockquote>
<p>语法如下：</p>
<p>bulk每一个操作要两个json串(delete语法除外)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"action"</span>:<span class="string">"&#123;metadata&#125;"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"data"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"index"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"jluzh"</span>,<span class="attr">"_type"</span>:<span class="string">"person"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"张三"</span>,<span class="attr">"age"</span>:<span class="number">20</span>,<span class="attr">"mail"</span>:<span class="string">"111@qq.com"</span>,<span class="attr">"hobby"</span>:<span class="string">"羽毛球，兵乓球，足球"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>如果查询的结果中有 should 字段，则得分会更加高，也就是相似度更高。</p>
<blockquote>
<p>bool 查询会为每个文档计算相关度评分 _score, 再将所有匹配的 must 和 should 语句的分数 _score 求和，最后除以 must 和 should 语句的总数</p>
<p>must_not 语句不会影响评分；它的作用只是将不相关的文档排除</p>
</blockquote>
<h2 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h2><p>参考：<a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=mall整合elasticsearch实现商品搜索" target="_blank" rel="noopener">mall整合Elasticsearch实现商品搜索</a></p>
<p>示例出自上面这位大神</p>
<h3 id="知识点铺垫"><a href="#知识点铺垫" class="headerlink" title="知识点铺垫"></a>知识点铺垫</h3><p>由于SpringBoot 与 elasticsearch 需进行整合，所以不得不提到 Spring Data Elasticsearch</p>
<blockquote>
<p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，它可以避免编写大量的样板代码。</p>
</blockquote>
<p>常用的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标示映射到Elasticsearch文档上的领域对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Document &#123;</span><br><span class="line">    <span class="comment">//索引库名次，mysql中数据库的概念</span></span><br><span class="line">    <span class="function">String <span class="title">indexName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//文档类型，mysql中表的概念</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//默认分片数</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">shards</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line">    <span class="comment">//默认副本数量</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">replicas</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=id" target="_blank" rel="noopener">@Id</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示是文档的id，文档可以认为是mysql中表行的概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=field" target="_blank" rel="noopener">@Field</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Field &#123;</span><br><span class="line">  <span class="comment">//文档中字段的类型</span></span><br><span class="line">    <span class="function">FieldType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FieldType.Auto</span>;</span><br><span class="line">  <span class="comment">//是否建立倒排索引</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">index</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  <span class="comment">//是否进行存储</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">store</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  <span class="comment">//分词器名次</span></span><br><span class="line">    <span class="function">String <span class="title">analyzer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="comment">//为文档自动指定元数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FieldType &#123;</span><br><span class="line">    Text,<span class="comment">//会进行分词并建了索引的字符类型</span></span><br><span class="line">    Integer,</span><br><span class="line">    Long,</span><br><span class="line">    Date,</span><br><span class="line">    Float,</span><br><span class="line">    Double,</span><br><span class="line">    Boolean,</span><br><span class="line">    Object,</span><br><span class="line">    Auto,<span class="comment">//自动判断字段类型</span></span><br><span class="line">    Nested,<span class="comment">//嵌套对象类型</span></span><br><span class="line">    Ip,</span><br><span class="line">    Attachment,</span><br><span class="line">    Keyword<span class="comment">//不会进行分词建立索引的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=sping-data方式的数据操作" target="_blank" rel="noopener">Sping Data方式的数据操作</a></p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=继承elasticsearchrepository接口可以获得常用的数据操作方法" target="_blank" rel="noopener">继承ElasticsearchRepository接口可以获得常用的数据操作方法</a></p>
<p><img src="http://www.macrozheng.com/images/arch_screen_31.png" alt="img"></p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=可以使用衍生查询" target="_blank" rel="noopener">可以使用衍生查询</a></p>
<blockquote>
<p>在接口中直接指定查询方法名称便可查询，无需进行实现，如商品表中有商品名称、标题和关键字，直接定义以下查询，就可以对这三个字段进行全文搜索。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索查询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name              商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subTitle          商品标题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keywords          商品关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page              分页信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;EsProduct&gt; <span class="title">findByNameOrSubTitleOrKeywords</span><span class="params">(String name, String subTitle, String keywords, Pageable page)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在idea中直接会提示对应字段</p>
</blockquote>
<p><img src="http://www.macrozheng.com/images/arch_screen_32.png" alt="img"></p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>引入相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Elasticsearch相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!--Swagger-UI API文档生产工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">repositories:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">elasticsearch</span> <span class="comment"># es集群的名称</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure>

<p><strong><em>添加商品文档对象 EsProduct</em></strong></p>
<blockquote>
<p>不需要中文分词的字段设置成@Field(type = FieldType.Keyword)类型，需要中文分词的设置成@Field(analyzer = “ik_max_word”,type = FieldType.Text)类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.nosql.elasticsearch.document;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索中的商品信息</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/6/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"pms"</span>, type = <span class="string">"product"</span>,shards = <span class="number">1</span>,replicas = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsProduct</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String productSn;</span><br><span class="line">    <span class="keyword">private</span> Long brandId;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line">    <span class="keyword">private</span> Long productCategoryId;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String productCategoryName;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String subTitle;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String keywords;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer sale;</span><br><span class="line">    <span class="keyword">private</span> Integer newStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer recommandStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="keyword">private</span> Integer promotionType;</span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line">    <span class="meta">@Field</span>(type =FieldType.Nested)</span><br><span class="line">    <span class="keyword">private</span> List&lt;EsProductAttributeValue&gt; attrValueList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了所有getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=添加esproductrepository接口用于操作elasticsearch" target="_blank" rel="noopener">添加EsProductRepository接口用于操作Elasticsearch</a></p>
<blockquote>
<p>继承ElasticsearchRepository接口，这样就拥有了一些基本的Elasticsearch数据操作方法，同时定义了一个衍生查询方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.nosql.elasticsearch.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.nosql.elasticsearch.document.EsProduct;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品ES操作类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/6/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EsProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">EsProduct</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name              商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subTitle          商品标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keywords          商品关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page              分页信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Page&lt;EsProduct&gt; <span class="title">findByNameOrSubTitleOrKeywords</span><span class="params">(String name, String subTitle, String keywords, Pageable page)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它请参照大神的项目：<a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-06" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-06</a></p>
<p>具体流程：</p>
<p>模拟搜索商品的业务流程，先将数据库中所有的商品信息导入到es中，再通过es的分词方法，通过keyword 快速找到商品的相应的信息。</p>
<h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><p>可以把 Logstash 理解成流入，流出 Elasticsearch 的传送带</p>
<p>支持：不同类型的数据或实施数据流经过 Logstash 写入 ES 或者从 ES 中读出写入文件或对应的实施数据流。</p>
<p>包括但不限于：</p>
<ul>
<li>本地或远程文件；</li>
<li>Kafka 实时数据流——核心插件有 logstashinputkafka/logstashoutputkafka；</li>
<li>MySQL、Oracle 等关系型数据库——核心插件有 logstashinputjdbc/logstashouputjdbc；</li>
<li>Mongo 非关系型数据库——核心插件有 logstashinputmongo/logstashoutputmongo；</li>
<li>Redis 数据流；</li>
<li>……</li>
</ul>
<h1 id="Kibana-认知"><a href="#Kibana-认知" class="headerlink" title="Kibana 认知"></a>Kibana 认知</h1><blockquote>
<p>Kibana 是 ES 大数据的图形化展示工具。集成了 DSL 命令行查看、数据处理插件、继承了 x-pack（收费）安全管理插件等。</p>
</blockquote>
<h1 id="Beats-轻量型数据采集器"><a href="#Beats-轻量型数据采集器" class="headerlink" title="Beats(轻量型数据采集器)"></a>Beats(轻量型数据采集器)</h1><blockquote>
<p>Beats 平台集合了多种单一用途采集器，它们从成百上千台机器和系统向 Logstash 或 Elasticsearch 发送数据</p>
</blockquote>
<p>数据流程图</p>
<p><img src="https://images2018.cnblogs.com/blog/874963/201808/874963-20180808170444229-5723261.png" alt="img"></p>
<p>Beats 的组件</p>
<p><img src="D:%5Ctypora%5Cnotes%5Casset%5Cimage-20200309215925095.png" alt="image-20200309215925095"></p>
<h2 id="FileBeat"><a href="#FileBeat" class="headerlink" title="FileBeat"></a>FileBeat</h2><p>轻量型日志采集器</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>LongStream实现Fibonacci数列</title>
    <url>/2020/03/09/LongStream%E5%AE%9E%E7%8E%B0Fibonacci%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322655160467490" target="_blank" rel="noopener">创建Stream</a></p>
<p>在学习 Java8 的 Stream 的时候，发现廖雪峰的网站上有一道题挺有意思，顺便可以练练手。</p>
<ul>
<li>编写一个能输出斐波拉契数列（Fibonacci）的<code>LongStream</code>：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, ...</span><br></pre></td></tr></table></figure>

<p>最后捣鼓出来的答案：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Learn Java from https://www.liaoxuefeng.com/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mikelv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		LongStream fib = LongStream.generate(<span class="keyword">new</span> FibSupplier());</span><br><span class="line">		<span class="comment">// 打印Fibonacci数列：1，1，2，3，5，8，13，21...</span></span><br><span class="line">		fib.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibSupplier</span> <span class="keyword">implements</span> <span class="title">LongSupplier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAsLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sum = x + y;</span><br><span class="line">		x = y;</span><br><span class="line">		y = sum;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比之前网上的常用的实现方法确实简洁了不少，而且更易于理解。代码地址：<a href="https://gitee.com/mikeLv01/stream-fibonacci-demo" target="_blank" rel="noopener">https://gitee.com/mikeLv01/stream-fibonacci-demo</a></p>
<p>转载：<a href="https://blog.csdn.net/blue_hh/article/details/75453603" target="_blank" rel="noopener">大龙湖畔</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.homework.lhh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"斐波那契数列前20项的值如下："</span>);</span><br><span class="line">        System.out.print(num[<span class="number">0</span>]+<span class="string">" "</span>+num[<span class="number">1</span>]+<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            num[i] = num[i - <span class="number">1</span>] + num[i - <span class="number">2</span>];</span><br><span class="line">            System.out.print(num[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><blockquote>
<h3 id="基于-Supplier"><a href="#基于-Supplier" class="headerlink" title="基于 Supplier"></a>基于 Supplier</h3></blockquote>
<p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>

<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> NatualSupplier());</span><br><span class="line">        <span class="comment">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class="line">        natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NatualSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>如果用<code>List</code>表示，即便在<code>int</code>范围内，也会占用巨大的内存，而<code>Stream</code>几乎不占用空间，<strong><em>因为每个元素都是实时计算出来的，用的时候再算</em></strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8-Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性</title>
    <url>/2020/03/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口(Functional Interface)就是一个<strong><em>有且仅有一个抽象方法</em></strong>，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为 lambda 表达式。方法引用是 lambda 表达式的另一种表现形式</p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>参考：</p>
<p><a href="https://www.jianshu.com/p/8b4e578ecf58" target="_blank" rel="noopener">Lambda表达式学习（一）为什么使用Lambda表达式？</a></p>
<p><a href="https://www.cnblogs.com/WJ5888/p/4667086.html" target="_blank" rel="noopener">Java 8 Lambda实现原理分析</a></p>
<p>代码简介程度：外部类 &gt; 内部类 &gt; 匿名内部类 &gt; lambda &gt; 方法引用</p>
<p>这里不得不提及下 <strong><em>匿名内部类</em></strong></p>
<p>参考自：<a href="https://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="noopener">java提高篇(十)—–详解匿名内部类</a></p>
<blockquote>
<p>省去了实现类，直接<strong>new 接口名(){…}</strong> 没有实现类名，实际就是实现且创建了一个接口对象。</p>
<p>匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类</p>
<p>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。</p>
</blockquote>
<p>Lambad 表达式首先会被编译为一个 <strong>私有的静态函数</strong></p>
<p>其后，会生成一个 <strong>内部类</strong></p>
<a id="more"></a>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>转载：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889" target="_blank" rel="noopener">使用Stream</a></p>
<p>Java8 开始，不但引入 Lambada 表达式，还引入了一个全新的流式 API：<strong>Stream API</strong>。它位于 <code>java.util.stream</code> 包中。</p>
<p><em>划重点</em>：这个<code>Stream</code>不同于<code>java.io</code>的<code>InputStream</code>和<code>OutputStream</code>，它代表的是<strong><em>任意Java对象的序列</em></strong>。两者对比如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">java.io</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储</td>
<td align="left">顺序读写的<code>byte</code>或<code>char</code></td>
<td>顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">序列化至文件或网络</td>
<td>内存计算／业务逻辑</td>
</tr>
</tbody></table>
<p><em>再次划重点</em>：这个<code>Stream</code>和<code>List</code>也不一样，<code>List</code>存储的每个元素都是已经存储在内存中的某个Java对象，而<code>Stream</code>输出的元素可能并没有预先存储在内存中，而是实时计算出来的。</p>
<p>换句话说，<code>List</code>的用途是操作一组已存在的Java对象，而<code>Stream</code>实现的是惰性计算，两者对比如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">java.util.List</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">元素</td>
<td align="left">已分配并存储在内存</td>
<td>可能未分配，实时计算</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">操作一组已存在的Java对象</td>
<td>惰性计算</td>
</tr>
</tbody></table>
<p><code>Stream</code>看上去有点不好理解，但我们举个例子就明白了。</p>
<p>如果我们要表示一个全体自然数的集合，显然，用<code>List</code>是不可能写出来的，因为自然数是无限的，内存再大也没法放到<code>List</code>中：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;BigInteger&gt; <span class="built_in">list</span> = ??? <span class="comment">// 全体自然数?</span></span><br></pre></td></tr></table></figure>

<p>但是，用<code>Stream</code>可以做到。写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br></pre></td></tr></table></figure>

<p>我们先不考虑<code>createNaturalStream()</code>这个方法是如何实现的，我们看看如何使用这个<code>Stream</code>。</p>
<p>首先，我们可以对每个自然数做一个平方，这样我们就把这个<code>Stream</code>转换成了另一个<code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br><span class="line">Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); <span class="comment">// 全体自然数的平方</span></span><br></pre></td></tr></table></figure>

<p>因为这个<code>streamNxN</code>也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用<code>limit()</code>方法截取前100个元素，最后用<code>forEach()</code>处理每个元素，这样，我们就打印出了前100个自然数的平方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream();</span><br><span class="line">naturals.map(n -&gt; n.multiply(n)) <span class="comment">// 1, 4, 9, 16, 25...</span></span><br><span class="line">        .limit(<span class="number">100</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>我们总结一下<code>Stream</code>的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>
<p><code>Stream</code>的另一个特点是，一个<code>Stream</code>可以轻易地转换为另一个<code>Stream</code>，而不是修改原<code>Stream</code>本身。</p>
<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s3 = s2.limit(<span class="number">100</span>); <span class="comment">// 不计算</span></span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure>

<p>惰性计算的特点是：一个<code>Stream</code>转换为另一个<code>Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</p>
<p>例如，创建一个全体自然数的<code>Stream</code>，不会进行计算，把它转换为上述<code>s2</code>这个<code>Stream</code>，也不会进行计算。再把<code>s2</code>这个无限<code>Stream</code>转换为<code>s3</code>这个有限的<code>Stream</code>，也不会进行计算。只有最后，调用<code>forEach</code>确实需要<code>Stream</code>输出的元素时，才进行计算。我们通常把<code>Stream</code>的操作写成链式操作，代码更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">createNaturalStream()</span><br><span class="line">    .map(BigInteger::multiply)</span><br><span class="line">    .limit(<span class="number">100</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>因此，Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result = createNaturalStream() <span class="comment">// 创建Stream</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Stream API的特点是：</p>
<ul>
<li>Stream API提供了一套新的流式处理的抽象序列；</li>
<li>Stream API支持函数式编程和链式操作；</li>
<li>Stream可以表示无限序列，并且大多数情况下是惰性求值的。</li>
</ul>
<h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><p>要使用<code>Stream</code>，就必须现创建它。创建<code>Stream</code>有很多种方法，我们来一一介绍。</p>
<h4 id="Stream-of"><a href="#Stream-of" class="headerlink" title="Stream.of()"></a>Stream.of()</h4><p>创建<code>Stream</code>最简单的方式是直接用<code>Stream.of()</code>静态方法，传入可变参数即创建了一个能输出确定元素的<code>Stream</code>：</p>
<p><code>import java.util.stream.Stream;</code> Run</p>
<p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p>
<h4 id="基于数组或Collection"><a href="#基于数组或Collection" class="headerlink" title="基于数组或Collection"></a>基于数组或Collection</h4><p>第二种创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者<code>Collection</code>持有的元素：</p>
<p><code>import java.util.*; import java.util.stream.*;</code> Run</p>
<p>把数组变成<code>Stream</code>使用<code>Arrays.strem()</code>方法。对于<code>Collection</code>（<code>List</code>、<code>Set</code>、<code>Queue</code>等），直接调用<code>stream()</code>方法就可以获得<code>Stream</code>。</p>
<p>上述创建<code>Stream</code>的方法都是把一个现有的序列变为<code>Stream</code>，它的元素是固定的。</p>
<h4 id="基于Supplier"><a href="#基于Supplier" class="headerlink" title="基于Supplier"></a>基于Supplier</h4><p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; s = <span class="built_in">Stream</span>.generate(Supplier&lt;<span class="keyword">String</span>&gt; sp);</span><br></pre></td></tr></table></figure>

<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>
<p><code>import java.util.function.*; import java.util.stream.*;</code> Run</p>
<p>上述代码我们用一个<code>Supplier</code>模拟了一个无限序列（当然受<code>int</code>范围限制不是真的无限大）。如果用<code>List</code>表示，即便在<code>int</code>范围内，也会占用巨大的内存，而<code>Stream</code>几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>
<p>对于无限序列，如果直接调用<code>forEach()</code>或者<code>count()</code>这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用<code>limit()</code>方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用<code>forEach()</code>或者<code>count()</code>操作就没有问题。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p>
<p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"/path/to/file.txt"</span>))) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法对于按行遍历文本文件十分有用。</p>
<p>另外，正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"\\s+"</span>);</span><br><span class="line">Stream&lt;String&gt; s = p.splitAsStream(<span class="string">"The quick brown fox jumps over the lazy dog"</span>);</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>因为Java的范型不支持基本类型，所以我们无法用<code>Stream</code>这样的类型，会发生编译错误。为了保存<code>int</code>，只能使用<code>String</code>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>，它们的使用方法和范型<code>Stream</code>没有大的区别，设计这三个<code>Stream</code>的目的是提高运行效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int[]数组变为IntStream:</span></span><br><span class="line">IntStream is = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class="line">LongStream ls = List.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure>

<p>创建<code>Stream</code>的方法有 ：</p>
<ul>
<li>通过指定元素、指定数组、指定<code>Collection</code>创建<code>Stream</code>；</li>
<li>通过<code>Supplier</code>创建<code>Stream</code>，可以是无限序列；</li>
<li>通过其他类的相关方法创建。</li>
</ul>
<p>基本类型的<code>Stream</code>有<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code></p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>转载：</p>
<p><a href="https://www.runoob.com/java/java8-method-references.html" target="_blank" rel="noopener">Java 8 方法引用</a></p>
<p>方法引用通过方法的名字来指向一个方法</p>
<p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>方法引用使用一对冒号 <strong>::</strong> 。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collided "</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Following the "</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>构造器引用：</strong>它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"> cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>方法引用一般都是调用静态方法，如果是类对象调用的话，就需要进行传参处理，将该对象传递过去</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>Java 8 新增了接口的默认方法。</p>
<p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>
<p>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件RabbitMQ</title>
    <url>/2020/03/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li><p>大多应用中，可通过消息服务中间件来提升系统异步通信，扩展解耦能力</p>
</li>
<li><p>消息服务中两个重要概念：</p>
<p>​    <strong>消息代理(message broker) 和 目的地(destination)</strong>,当消息发送者发送消息以后，将有消息代理接管，消息代理保证消息传递到指定目的地</p>
</li>
<li><p>消息队列主要有两种形式的目的地</p>
<ol>
<li>队列(queue): 点对点消息通信</li>
<li>主题(topic): 发布(publish)/订阅(subscribe) 消息通信</li>
</ol>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200309155537186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ 是一个由 erlang 开发的 AMQP(Advanced Message Queue Protocol) 的开源实现</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><blockquote>
<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4></blockquote>
<p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key(路由键) , priority，delivery-mode</p>
<blockquote>
<h4 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h4></blockquote>
<p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
<blockquote>
<h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4></blockquote>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<p>Exchange 有4种类型：</p>
<ul>
<li>direct(默认)</li>
<li>fanout</li>
<li>topic</li>
<li>headers</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155601426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Direct 模型</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155616695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>fanout模型(广播模型)</li>
<li>topic(模式匹配模式)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155629666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<h4 id="routeKey"><a href="#routeKey" class="headerlink" title="routeKey"></a>routeKey</h4></blockquote>
<p>路由Key键，交换器根据这个 key 键将 message 转发到对应的队列中</p>
<h2 id="RabbitListener-和-RabbitHandler"><a href="#RabbitListener-和-RabbitHandler" class="headerlink" title="@RabbitListener 和 @RabbitHandler"></a>@RabbitListener 和 @RabbitHandler</h2><p>转载：<a href="https://www.jianshu.com/p/911d987b5f11" target="_blank" rel="noopener">RabbitMQ：@RabbitListener 与 @RabbitHandler 及 消息序列化</a></p>
<ul>
<li>RabbitMQ 的序列化是指 Message 的 body 属性，即我们真正需要传输的内容，<strong>RabbitMQ 抽象出一个 MessageConvert 接口处理消息的序列化</strong>，其实现有 SimpleMessageConverter（默认）、Jackson2JsonMessageConverter 等</li>
<li>当调用了 convertAndSend 方法时会使用 MessageConvert 进行消息的序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"consumer_queue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(<span class="keyword">byte</span>[] message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 @RabbitListener 注解标记方法，当监听到队列中有消息时则会进行接收并处理</p>
</li>
<li><p>@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用</p>
</li>
<li><p>@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型</p>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>消息处理方法参数是由 MessageConverter 转化，若使用自定义 MessageConverter 则需要在 RabbitListenerContainerFactory 实例中去设置（默认 Spring 使用的实现是 SimpleRabbitListenerContainerFactory）</li>
<li>消息的 content_type 属性表示消息 body 数据以什么数据格式存储，接收消息除了使用 Message 对象接收消息（包含消息属性等信息）之外，还可直接使用对应类型接收消息 body 内容，但若方法参数类型不正确会抛异常：<ul>
<li><strong>application/octet-stream</strong>：二进制字节数组存储，使用 byte[]</li>
<li><strong>application/x-java-serialized-object</strong>：java 对象序列化格式存储，使用 Object、相应类型（反序列化时类型应该同包同名，否者会抛出找不到类异常）</li>
<li><strong>text/plain</strong>：文本数据类型存储，使用 String</li>
<li><strong>application/json</strong>：JSON 格式，使用 Object、相应类型</li>
</ul>
</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/9434708-77b9d3222ae376cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="死信队列-dead-message-queue"><a href="#死信队列-dead-message-queue" class="headerlink" title="死信队列(dead-message-queue)"></a>死信队列(dead-message-queue)</h2><p>转载自: <a href="https://blog.csdn.net/zhangcongyi420/article/details/100126666" target="_blank" rel="noopener">rabbitmq死信队列详解与使用</a></p>
<p>死信,顾名思义就是无法被消费的消息。</p>
<p>一般来说，producer 将消息投递到 broker 或者直接到 queue 里，consumer 从queue 取出消息进行消费，但某些时候由于特定的原因无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列；</p>
<p><strong><em>产生的原因</em></strong></p>
<ul>
<li>消息被拒绝<strong>(basic.reject或basic.nack)并且requeue=false.</strong></li>
<li>消息 TTL 过期</li>
<li>队列达到最大长度（队列满了，无法再添加数据到mq中）</li>
</ul>
<p><strong><em>处理方式</em></strong></p>
<ol>
<li>丢弃，如果不是很重要，可以选择丢弃</li>
<li>记录死信入库，然后做后续的业务分析或处理</li>
<li>通过死信队列，由负责监听死信的应用程序进行处理</li>
</ol>
<h2 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h2><p>参考：</p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_09" target="_blank" rel="noopener">http://www.macrozheng.com/#/architect/mall_arch_09</a></p>
<p>1.添加关键依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息队列相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.application.yml 关键配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># rabbitmq的连接地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># rabbitmq的连接端口号</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">/mall</span> <span class="comment"># rabbitmq的虚拟host</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的用户名</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的密码</span></span><br><span class="line">        <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#如果对异步消息需要回调必须设置为true</span></span><br></pre></td></tr></table></figure>

<p>3.配置消息队列基本信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消息队列枚举配置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:35</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> QueueEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_ORDER_CANCEL(<span class="string">"mall.order.direct"</span>, <span class="string">"mall.order.cancel"</span>, <span class="string">"mall.order.cancel"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知ttl队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_TTL_ORDER_CANCEL(<span class="string">"mall.order.direct.ttl"</span>, <span class="string">"mall.order.cancel.ttl"</span>, <span class="string">"mall.order.cancel.ttl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey;</span><br><span class="line"></span><br><span class="line">    QueueEnum(String exchange, String name, String routeKey) &#123;</span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.routeKey = routeKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.消息队列的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消息队列配置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:38</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单消息实际消费队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">orderDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">orderTtlDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单实际消费队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QueueEnum.QUEUE_ORDER_CANCEL.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列(死信队列)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderTtlQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getName())</span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-exchange"</span>,QueueEnum.QUEUE_ORDER_CANCEL.getExchange())<span class="comment">//到期后转发的交换机</span></span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-routing-key"</span>, QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey())<span class="comment">//到期后转发的路由键</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">orderBinding</span><span class="params">(DirectExchange orderDirect, Queue orderQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderQueue)</span><br><span class="line">                .to(orderDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单延迟队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">orderTtlBinding</span><span class="params">(DirectExchange orderTtlDirect,Queue orderTtlQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderTtlQueue)</span><br><span class="line">                .to(orderTtlDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.取消订单消息的发出者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取消订单消息的发出者</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 12:06</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(CancelOrderSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Long orderId,<span class="keyword">final</span> <span class="keyword">long</span> delayTimes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//给延迟队列发送消息,配置交换器和路由key和队列，自动序列化发送的消息</span></span><br><span class="line">        amqpTemplate.convertAndSend(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange(), QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey(), orderId, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">                <span class="comment">//给消息设置延迟毫秒值</span></span><br><span class="line">                message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LOGGER.info(<span class="string">"send delay message orderId:&#123;&#125;"</span>,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.取消订单消息的处理者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取消订单消息的处理者</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:56</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//RabbitListener 监听队列 mall.order.cancel</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"mall.order.cancel"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CancelOrderReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OmsPortalOrderService portalOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当该类有消息需要处理时，即交给该方法处理</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Long orderId)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"receive delay message orderId:&#123;&#125;"</span>,orderId);</span><br><span class="line">        portalOrderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它可参考大神的项目：<a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-08" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-08</a></p>
<ul>
<li>具体流程</li>
</ul>
<p>是模拟订单下单，下单完成后开启一个延迟消息(<em>sendDelayMessageCancelOrder()</em>)，用于当用户没有付款时取消订单(orderId应该在下单后生成)。 CancelOrderSender 给延迟队列发送消息,配置交换器和路由key和队列(<em>sendMessage()</em>)，自动序列化发送的消息。CancelOrderReceiver 监听消息队列(<u>mall.order.cancel</u>),当有消息的时候接收并消费该消息(<em>cancelOrder()</em>)。</p>
<ul>
<li>运行截图如下所示</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020030915571585.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Swagger</title>
    <url>/2020/03/07/SpringBoot%E6%95%B4%E5%90%88Swagger/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_02" target="_blank" rel="noopener">SpringBoot整合Swagger</a></p>
<h2 id="添加项目依赖"><a href="#添加项目依赖" class="headerlink" title="添加项目依赖"></a>添加项目依赖</h2><blockquote>
<p>在pom.xml中新增Swagger-UI相关依</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Swagger-UI API文档生产工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="添加Swagger-UI的配置"><a href="#添加Swagger-UI的配置" class="headerlink" title="添加Swagger-UI的配置"></a><a href="http://www.macrozheng.com/#/architect/mall_arch_02?id=添加swagger-ui的配置" target="_blank" rel="noopener">添加Swagger-UI的配置</a></h3><blockquote>
<p>添加Swagger-UI的Java配置文件</p>
</blockquote>
<p>注意：Swagger对生成API文档的范围有三种不同的选择</p>
<ul>
<li>生成指定包下面的类的API文档</li>
<li>生成有指定注解的类的API文档</li>
<li>生成有指定注解的方法的API文档</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger2API文档的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            <span class="comment">//为当前包下controller生成API文档</span></span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">"org.developer.es.api.controller"</span>))</span><br><span class="line">            <span class="comment">//为有@Api注解的Controller生成API文档</span></span><br><span class="line">            <span class="comment">//                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span></span><br><span class="line">            <span class="comment">//为有@ApiOperation注解的方法生成API文档</span></span><br><span class="line">            <span class="comment">//                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span></span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            .title(<span class="string">"SwaggerUI演示"</span>)</span><br><span class="line">            .description(<span class="string">"es-demo"</span>)</span><br><span class="line">            .contact(<span class="string">"mikelv"</span>)</span><br><span class="line">            .version(<span class="string">"1.0"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot多数据源切换学习总结</title>
    <url>/2020/03/05/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>主要参考：<a href="https://www.cnblogs.com/shihaiming/p/11067623.html" target="_blank" rel="noopener">SpringBoot之多数据源动态切换数据源</a></p>
<p>其它参考：</p>
<p><a href="https://blog.csdn.net/catoop/article/details/50575038" target="_blank" rel="noopener">Spring Boot 动态数据源(多数据源自动切换)</a></p>
<p><a href="https://blog.csdn.net/qq_37502106/article/details/91044952" target="_blank" rel="noopener">spring boot使用AbstractRoutingDataSource实现动态数据源切换</a></p>
<p><a href="https://www.jianshu.com/p/b158476dd33c" target="_blank" rel="noopener">AbstractRoutingDataSource – Spring提供的轻量级数据源切换方式</a></p>
<p><a href="https://www.jianshu.com/p/a042ff2ee2ae" target="_blank" rel="noopener">【Spring】使用Spring的AbstractRoutingDataSource实现多数据源切换</a></p>
<p><a href="https://www.jianshu.com/p/3c5d7f09dfbd" target="_blank" rel="noopener">ThreadLocal</a></p>
<p><a href="https://juejin.im/post/5ac2eb52518825555e5e06ee" target="_blank" rel="noopener">ThreadLocal就是这么简单</a></p>
<p><a href="https://blog.csdn.net/rainbow702/article/details/52185827" target="_blank" rel="noopener">Spring AOP @Before @Around @After 等 advice 的执行顺序</a></p>
<p><a href="https://blog.csdn.net/u010502101/article/details/78823056" target="_blank" rel="noopener">AspectJ 切面注解中五种通知注解：@Before、@After、@AfterRunning、@AfterThrowing、@Around</a></p>
<p><a href="https://www.xiefayang.com/2019/04/01/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Spring Boot 2.0源码解析-配置绑定</a></p>
<p><a href="http://blog.didispace.com/Spring-Boot-2-0-feature-1-relaxed-binding-2/" target="_blank" rel="noopener">Spring Boot 2.0 新特性（一）：配置绑定 2.0 全解析</a></p>
<p><a href="https://www.cnblogs.com/aheizi/p/7071181.html" target="_blank" rel="noopener">Java注解–实现动态数据源切换</a></p>
<p><a href="https://webfuse.cn/2017/08/10/%E5%88%A9%E7%94%A8Spring%E7%9A%84AbstractRoutingDataSource%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">利用Spring的AbstractRoutingDataSource解决多数据源的问题</a></p>
<a id="more"></a>

<blockquote>
<h3 id="数据源定义"><a href="#数据源定义" class="headerlink" title="数据源定义"></a>数据源定义</h3></blockquote>
<p>Java中的数据源就是连接到数据库的一条路径，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接。DataSource的创建可以有不同的实现。DataSource通常被称为数据源，它包含连接池 和连接池管理 两部分，习惯上也经常把DataSource称为连接池</p>
<blockquote>
<h3 id="SpringBoot-读取配置文件方式"><a href="#SpringBoot-读取配置文件方式" class="headerlink" title="SpringBoot 读取配置文件方式"></a>SpringBoot 读取配置文件方式</h3></blockquote>
<p>SpringBoot2.x 开始推荐读取配置文件的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Binder binder = Binder.get(environment);<span class="comment">//简单绑定</span></span><br><span class="line"><span class="keyword">this</span>.defaultDataSourceProperties = binder.bind(<span class="string">"spring.datasource.master"</span>,Map<span class="class">.<span class="keyword">class</span>).<span class="title">get</span>()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>推荐使用 Binder 读取配置文件</strong></p>
<h2 id="AbstractRoutingDataSource"><a href="#AbstractRoutingDataSource" class="headerlink" title="AbstractRoutingDataSource"></a>AbstractRoutingDataSource</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object defaultTargetDataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lenientFallback = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> DataSourceLookup dataSourceLookup = <span class="keyword">new</span> JndiDataSourceLookup();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRoutingDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetDataSources</span><span class="params">(Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDataSources = targetDataSources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTargetDataSource</span><span class="params">(Object defaultTargetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultTargetDataSource = defaultTargetDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLenientFallback</span><span class="params">(<span class="keyword">boolean</span> lenientFallback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lenientFallback = lenientFallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceLookup</span><span class="params">(@Nullable DataSourceLookup dataSourceLookup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSourceLookup = (DataSourceLookup)(dataSourceLookup != <span class="keyword">null</span> ? dataSourceLookup : <span class="keyword">new</span> JndiDataSourceLookup());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.targetDataSources == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'targetDataSources' is required"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resolvedDataSources = <span class="keyword">new</span> HashMap(<span class="keyword">this</span>.targetDataSources.size());</span><br><span class="line">            <span class="keyword">this</span>.targetDataSources.forEach((key, value) -&gt; &#123;</span><br><span class="line">                Object lookupKey = <span class="keyword">this</span>.resolveSpecifiedLookupKey(key);</span><br><span class="line">                DataSource dataSource = <span class="keyword">this</span>.resolveSpecifiedDataSource(value);</span><br><span class="line">                <span class="keyword">this</span>.resolvedDataSources.put(lookupKey, dataSource);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultTargetDataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resolvedDefaultDataSource = <span class="keyword">this</span>.resolveSpecifiedDataSource(<span class="keyword">this</span>.defaultTargetDataSource);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">resolveSpecifiedLookupKey</span><span class="params">(Object lookupKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookupKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">resolveSpecifiedDataSource</span><span class="params">(Object dataSource)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> DataSource) &#123;</span><br><span class="line">            <span class="keyword">return</span> (DataSource)dataSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.dataSourceLookup.getDataSource((String)dataSource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal data source value - only [javax.sql.DataSource] and String supported: "</span> + dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>) ? <span class="keyword">this</span> : <span class="keyword">this</span>.determineTargetDataSource().unwrap(iface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>) || <span class="keyword">this</span>.determineTargetDataSource().isWrapperFor(iface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">        Object lookupKey = <span class="keyword">this</span>.determineCurrentLookupKey();</span><br><span class="line">        DataSource dataSource = (DataSource)<span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractRoutingDataSource是spring-jdbc包提供的一个了AbstractDataSource的抽象类，它<strong>实现了DataSource接口</strong>的用于获取数据库连接的方法。</p>
<p>可以看到源码中也是通过 determineTargetDataSource() 获取到 datasource 对象，再从这个配置好的 datasource 获取到数据库连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection(username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看 <strong>determineTargetDataSource()方法代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">    Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">    DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法的返回值就是项目中所要用的DataSource的key值，拿到该key后就可以在resolvedDataSource中取出对应的DataSource，如果key找不到对应的DataSource就使用默认的数据源。</span></span><br></pre></td></tr></table></figure>

<p><strong>determineCurrentLookupKey 用于在获得数据库连接之前执行，以便在出现多数据源的情况下，由该方法确定调用哪个数据源key。且每切换一次数据源就会被调用一次</strong></p>
<p>总结：</p>
<p>SpringBoot 提供了 AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样在执行查询之前，设置使用的数据源。实现可动态路由的数据源，在每次数据库查询操作前执行。通过它的抽象方法 <strong><em>determineCurrentLookupKey()</em></strong> 获取到数据源对应的key，<strong><em>determineTargetDataSource()</em></strong> 拿到该key后就可以在resolvedDataSource中取出对应的DataSource。</p>
<h2 id="MutablePropertyValues"><a href="#MutablePropertyValues" class="headerlink" title="MutablePropertyValues"></a>MutablePropertyValues</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title">PropertyValues</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>用过类的实现关系可知 <strong>MutablePropertyValues</strong> 实现了 <strong><em>PropertyValues接口</em></strong> </p>
<ul>
<li>PropertyValues 源码</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306132937475.png" alt="image-20200306132937475"></p>
<p>由图可知，PropertyValues接口类 包含了许多对属性的基本操作：迭代，分割，获取，等</p>
<ul>
<li>MutablePropertyValues源码</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306133216584.png" alt="image-20200306133216584"></p>
<p>可见 MutablePropertyValues 丰富了 PropertyValues 对属性值的操作</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306134129694.png" alt="image-20200306134129694"></p>
<p>且通过类的继承关系可以发现，PropertyValues 只有一个实现类：*<em>MutablePropertyValues *</em></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306143529330.png" alt="image-20200306143529330"></p>
<p>Threadlocal 是一个线程内部的 <strong>存储类</strong>，可以在指定内存存储数据，数据存储以后，<strong>只有指定的线程可以得到存储数据</strong></p>
<p>ThreadLocal 提供了线程的局部变量，每个线程都可以通过 <code>set()</code> 和 <code>get()</code> 来对这个局部变量进行操作，但不会和其它线程的局部变量进行冲突，<strong>实现了线程的数据隔离</strong></p>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....很长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码可知，ThreadLocalMap 是 ThreadLocal 的一个内部类。用 Entry 类来进行存储。</p>
<p>先来看 set()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的<strong>值都是存储到这个 Map 上的，key 是当前 ThreadLocal 对象</strong></p>
<p><strong>Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象</strong></p>
<p>有了上面的基础，我们看get()方法就一点都不难理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote>
<ol>
<li>每个Thread维护着一个ThreadLocalMap的引用</li>
<li>ThreadLocalMap是ThreadLocal的内部类，用<strong>Entry</strong>来进行存储</li>
<li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li>
<li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li>
<li><strong>ThreadLocal本身并不存储值</strong>，它只是<strong>作为一个key来让线程从ThreadLocalMap获取value</strong>。</li>
</ol>
<blockquote>
<h3 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h3></blockquote>
<p>我们来看一下ThreadLocal的对象关系引用图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC80LzMvMTYyODk2YWIxYTFkMWUyZQ?x-oss-process=image/format,png" alt="img"></p>
<p>ThreadLocal内存泄漏的根源是：<strong>由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用</strong>。</p>
<p>想要避免内存泄露就要<strong>手动remove()掉</strong>！</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面<strong>相匹配的 Bean 创建代理</strong>。</p>
<p>在切面类中需要定义切面方法用于响应响应的目标方法，切面方法即为通知方法，通知方法需要用注解标识，AspectJ 支持 5 种类型的通知注解:</p>
<ul>
<li><strong>@Before</strong>: 前置通知, 在方法执行之前执行</li>
<li><strong>@After</strong>: 后置通知, 在方法执行之后执行 。</li>
<li><strong>@AfterRunning</strong>: 返回通知, 在方法返回结果之后执行</li>
<li><strong>@AfterThrowing</strong>: 异常通知, 在方法抛出异常之后</li>
<li><strong>@Around</strong>: 环绕通知, 围绕着方法执行</li>
</ul>
<p>以上5种类型的通知注解的值可以为 <strong><em>@annotation</em></strong>表示标注了某个注解的所有方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span></span><br></pre></td></tr></table></figure>

<p>执行的顺序如下：</p>
<p><strong>正常情况：</strong><br><img src="https://img-blog.csdn.net/20160811192425854" alt="one-ok"></p>
<hr>
<p><strong>异常情况：</strong><br><img src="https://img-blog.csdn.net/20160811192446479" alt="one-exception"></p>
<h3 id="JoinPoint"><a href="#JoinPoint" class="headerlink" title="JoinPoint"></a>JoinPoint</h3><p>JoinPoint 对象封装了 SpringAop 中<strong>切面方法的信息</strong>，在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    String dsId = ds.value();</span><br><span class="line">    <span class="keyword">if</span>(DynamicDataSourceContextHolder.dataSourceIds.contains(dsId))&#123;</span><br><span class="line">        <span class="comment">//当日志级别为 debug 时输出</span></span><br><span class="line">        <span class="comment">//point.getSignature() 获取切入点的方法名</span></span><br><span class="line">        logger.debug(<span class="string">"Use DataSourceKey :&#123;&#125; &gt;"</span>, dsId, point.getSignature());</span><br><span class="line">        <span class="comment">//设置数据源的 key</span></span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceRouterKey(dsId);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//point.getSignature() 获取切入点的方法名</span></span><br><span class="line">        logger.info(<span class="string">"数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&#123;&#125;"</span>, dsId, point.getSignature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><p>在编程中尽量用 Logger(org.slf4j.Logger) 来输出信息，避免使用 sout</p>
<p>因为 Logger 提供了 5 种日志级别的输出：</p>
<ol>
<li><strong>error</strong></li>
<li><strong>warn</strong></li>
<li><strong>info</strong></li>
<li><strong>debug</strong></li>
<li><strong>trace</strong></li>
</ol>
<p>可在 application.yml 等配置日志输出级别，实现输出不同级别的日志信息按照需求输出，不像 sout 无法控制</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    String dsId = ds.value();</span><br><span class="line">    <span class="keyword">if</span>(DynamicDataSourceContextHolder.dataSourceIds.contains(dsId))&#123;</span><br><span class="line">        logger.debug(<span class="string">"Use DataSourceKey :&#123;&#125; &gt;"</span>, dsId, point.getSignature());</span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceRouterKey(dsId);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&#123;&#125;"</span>, dsId, point.getSignature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    logger.debug(<span class="string">"Revert DataSourceKey : "</span> + ds.value() + <span class="string">" &gt; "</span> + point.getSignature());</span><br><span class="line">    <span class="comment">//移除 ThreadLocalMap 中存储的 ThreadLocal对象和值，避免内存溢出</span></span><br><span class="line">    DynamicDataSourceContextHolder.removeDataSourceRouterKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个输出级别：debug 和 info</p>
<p>当在 application.yml 中配置 logging.level.root=info 时，info级别的日志得到输出，debug同理</p>
<p><img src="https://img-blog.csdnimg.cn/20200306232559114.png" alt="image-20200306154105726"></p>
<h2 id="DataSourceBuilder"><a href="#DataSourceBuilder" class="headerlink" title="DataSourceBuilder"></a>DataSourceBuilder</h2><p>示例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">customize.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/blue?serverTimezone=UTC</span></span><br><span class="line"><span class="meta">customize.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">customize.datasource.password</span>=<span class="string">wan4380797</span></span><br><span class="line"><span class="meta">customize.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp2.BasicDataSource;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2DataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"myDbcp2DataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"customize.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().type(BasicDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>对于 Binder，只要会用就差不多了，等功力达到以后再深入源码</p>
<blockquote>
<h3 id="示例1-简单类型"><a href="#示例1-简单类型" class="headerlink" title="示例1 简单类型"></a>示例1 简单类型</h3></blockquote>
<p>假设在propertes配置中有这样一个配置：<code>com.didispace.foo=bar</code></p>
<p>我们为它创建对应的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"com.didispace"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String foo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，通过最新的<code>Binder</code>就可以这样来拿配置信息了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Binder binder = Binder.get(context.getEnvironment());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定简单配置</span></span><br><span class="line">        FooProperties foo = binder.bind(<span class="string">"com.didispace"</span>, Bindable.of(FooProperties<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">        System.out.println(foo.getFoo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="示例2-List类型"><a href="#示例2-List类型" class="headerlink" title="示例2 List类型"></a>示例2 List类型</h3></blockquote>
<p>如果配置内容是List类型呢？比如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">com.didispace.post[0]</span>=<span class="string">Why Spring Boot</span></span><br><span class="line"><span class="meta">com.didispace.post[1]</span>=<span class="string">Why Spring Cloud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">com.didispace.posts[0].title</span>=<span class="string">Why Spring Boot</span></span><br><span class="line"><span class="meta">com.didispace.posts[0].content</span>=<span class="string">It is perfect!</span></span><br><span class="line"><span class="meta">com.didispace.posts[1].title</span>=<span class="string">Why Spring Cloud</span></span><br><span class="line"><span class="meta">com.didispace.posts[1].content</span>=<span class="string">It is perfect too!</span></span><br></pre></td></tr></table></figure>

<p>要获取这些配置依然很简单，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">Binder binder = Binder.get(context.getEnvironment());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定List配置</span></span><br><span class="line">List&lt;String&gt; post = binder.bind(<span class="string">"com.didispace.post"</span>, Bindable.listOf(String<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">System.out.println(post);</span><br><span class="line"></span><br><span class="line">List&lt;PostInfo&gt; posts = binder.bind(<span class="string">"com.didispace.posts"</span>, Bindable.listOf(PostInfo<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">System.out.println(posts)</span><br></pre></td></tr></table></figure>

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>里面 bind() 方法有许多重载，重点关注这个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">    Assert.notNull(target, <span class="string">"Target must not be null"</span>);</span><br><span class="line">    handler = handler != <span class="keyword">null</span> ? handler : <span class="keyword">this</span>.defaultBindHandler;</span><br><span class="line">    Binder.Context context = <span class="keyword">new</span> Binder.Context();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bind(name, target, handler, context, <span class="keyword">false</span>, create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还不是真正的绑定阶段，但有两个点需要说明：</p>
<ul>
<li>参数<strong>ConfigurationPropertyName</strong>：是对前面传入的配置前缀 prefix 进行一些基本校验和处理</li>
<li>返回值<strong>BindResult</strong>：里面有<code>of()</code>, <code>get()</code>, <code>isBound()</code>, <code>orElse()</code>等</li>
<li><strong>Context</strong>：在这里是绑定上下文, 由前面说过的<code>BindHandler</code>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BindContext</span> </span>&#123;</span><br><span class="line">    <span class="function">Binder <span class="title">getBinder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterable&lt;ConfigurationPropertySource&gt; <span class="title">getSources</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConfigurationProperty <span class="title">getConfigurationProperty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着代码往下，看 Binder 中的下一个bind() 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    context.clearConfigurationProperty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bindable&lt;T&gt; replacementTarget = handler.onStart(name, target, context);</span><br><span class="line">        <span class="keyword">if</span> (replacementTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleBindResult(name, target, handler, context, (Object)<span class="keyword">null</span>, create);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object bound = <span class="keyword">this</span>.bindObject(name, replacementTarget, handler, context, allowRecursiveBinding);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleBindResult(name, replacementTarget, handler, context, bound, create);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handleBindError(name, target, handler, context, var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>留意 onStart ，这里就有一个 BindHandler 回调接口中的一个方法，也就是绑定的开始但还未完成阶段</p>
<p>接下来在<code>Binder</code>中, 会陆续看到其它几个阶段的方法</p>
<p>再来看返回, 是通过<code>handleBindResult()</code>和<code>handleBindError()</code>来处理的.</p>
<p>点开这两个handleBindXXX()能看到在里面进行了onSuccess, onFinish, onFailure的调用</p>
<ul>
<li>handleBindResult() 源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">handleBindResult</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, Object result, <span class="keyword">boolean</span> create)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = handler.onSuccess(name, target, context, result);</span><br><span class="line">        result = context.getConverter().convert(result, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; create) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.create(target, context);</span><br><span class="line">        result = handler.onCreate(name, target, context, result);</span><br><span class="line">        result = context.getConverter().convert(result, target);</span><br><span class="line">        Assert.state(result != <span class="keyword">null</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unable to create instance for "</span> + target.getType();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler.onFinish(name, target, context, result);</span><br><span class="line">    <span class="keyword">return</span> context.getConverter().convert(result, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>handleBindError() 源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">handleBindError</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, Exception error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object result = handler.onFailure(name, target, context, error);</span><br><span class="line">        <span class="keyword">return</span> context.getConverter().convert(result, target);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var7 <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BindException)var7;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindException(name, target, context.getConfigurationProperty(), var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来看 <strong><em>bindObject()</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Object <span class="title">bindObject</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">    ConfigurationProperty property = <span class="keyword">this</span>.findProperty(name, context);</span><br><span class="line">    <span class="keyword">if</span> (property == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsNoDescendantOf(context.getSources(), name) &amp;&amp; context.depth != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AggregateBinder&lt;?&gt; aggregateBinder = <span class="keyword">this</span>.getAggregateBinder(target, context);</span><br><span class="line">        <span class="keyword">if</span> (aggregateBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bindAggregate(name, target, handler, context, aggregateBinder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.bindProperty(target, context, property);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConverterNotFoundException var10) &#123;</span><br><span class="line">                Object instance = <span class="keyword">this</span>.bindDataObject(name, target, handler, context, allowRecursiveBinding);</span><br><span class="line">                <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bindDataObject(name, target, handler, context, allowRecursiveBinding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里过程比较多，可以分为 2 个部分</p>
<p><strong>Part1</strong>：寻找属性和匹配的过程</p>
<p>开头的<code>findProperty()</code>和一个匹配方法:<code>containsNoDescendantOf()</code>, 它们的参数都有<code>context</code></p>
<p>上面说过了–&gt;提供绑定的上下文信息</p>
<p><strong>Part2</strong>：绑定过程</p>
<p>接下来是 bindXXX 这三个私有方法：</p>
<ul>
<li><p><code>bindAggregate()</code>: 从注释上看出, 主要是负责处理Map, Collections, Array的绑定策略, 及完成多层属性的递归</p>
</li>
<li><p><code>bindProperty()</code>: 是返回属性值的过程(其中包含类型转换)</p>
<p>例如属性资源文件中配置的<code>name=thank</code> -&gt; <code>java.lang.String thank</code></p>
</li>
<li><p><code>bindBean()</code>: 会继续调用另外一个私有的重载函数<code>bindBean()</code></p>
</li>
</ul>
<p>重点看看这个方法 — bindDataObject()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">bindDataObject</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isUnbindableBean(name, target, context)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; type = target.getType().resolve(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!allowRecursiveBinding &amp;&amp; context.isBindingDataObject(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DataObjectPropertyBinder propertyBinder = (propertyName, propertyTarget) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.bind(name.append(propertyName), propertyTarget, handler, context, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> context.withDataObject(type, () -&gt; &#123;</span><br><span class="line">                Iterator var5 = <span class="keyword">this</span>.dataObjectBinders.iterator();</span><br><span class="line"></span><br><span class="line">                Object instance;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!var5.hasNext()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DataObjectBinder dataObjectBinder = (DataObjectBinder)var5.next();</span><br><span class="line">                    instance = dataObjectBinder.bind(name, target, context, propertyBinder);</span><br><span class="line">                &#125; <span class="keyword">while</span>(instance == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面又调用了上层的<code>Binder.bind()</code>, 递归完成绑定</p>
<p>终止条件是上面提到过的<code>containsNoDescendantOf()</code>和另外一个判断<code>isUnbindableBean()</code></p>
<p>关注一下最终的返回结果, 是调用了另外一个类: <code>JavaBeanBinder</code>的<code>bind</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;BeanBinder&gt; BEAN_BINDERS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        List&lt;BeanBinder&gt; binders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        binders.add(<span class="keyword">new</span> JavaBeanBinder());</span><br><span class="line">        BEAN_BINDERS = Collections.unmodifiableList(binders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h5><p>进入<code>JavaBeanBinder#bind()</code>之后看到继续调用了另一个私有的重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">bind</span><span class="params">(BeanPropertyBinder propertyBinder, Bean&lt;T&gt; bean, BeanSupplier&lt;T&gt; beanSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BeanProperty&gt; entry : bean.getProperties().entrySet()) &#123;</span><br><span class="line">        bound |= bind(beanSupplier, propertyBinder, entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面会迭代该配置bean中的所有属性, 调试模式下随便取一个来看看:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">0 = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7470</span>&#125; <span class="string">"name"</span> -&gt; </span><br><span class="line">  key = <span class="string">"name"</span></span><br><span class="line">  value = &#123;JavaBeanBinder<span class="variable">$BeanProperty</span><span class="variable">@7475</span>&#125; </span><br><span class="line">    name = <span class="string">"name"</span></span><br><span class="line">    declaringClassType = &#123;ResolvableType<span class="variable">@7481</span>&#125; <span class="string">"com.example.cache.config.CustomProperties"</span></span><br><span class="line">    getter = &#123;Method<span class="variable">@7482</span>&#125; <span class="string">"public java.lang.String com.example.cache.config.CustomProperties.getName()"</span></span><br><span class="line">    setter = &#123;Method<span class="variable">@7483</span>&#125; <span class="string">"public void com.example.cache.config.CustomProperties.setName(java.lang.String)"</span></span><br><span class="line">    field = &#123;Field<span class="variable">@7484</span>&#125; <span class="string">"private java.lang.String com.example.cache.config.CustomProperties.name"</span></span><br><span class="line"><span class="number">1</span> = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7471</span>&#125; <span class="string">"age"</span> -&gt; </span><br><span class="line"><span class="number">2</span> = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7472</span>&#125; <span class="string">"email"</span> -&gt;</span><br></pre></td></tr></table></figure>

<p>没错, 配置bean中: 的属性名, Setter和Getter 该有的都有了</p>
<p>下面来到<code>JavaBeanBinder</code>的最后一个重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">bind</span><span class="params">(BeanSupplier&lt;T&gt; beanSupplier, </span></span></span><br><span class="line"><span class="function"><span class="params">                         BeanPropertyBinder propertyBinder, BeanProperty property)</span> </span>&#123;</span><br><span class="line">    String propertyName = property.getName();</span><br><span class="line">    ResolvableType type = property.getType();</span><br><span class="line">    Supplier&lt;Object&gt; value = property.getValue(beanSupplier);</span><br><span class="line">    Annotation[] annotations = property.getAnnotations();</span><br><span class="line">    Object bound = propertyBinder.bindProperty(</span><br><span class="line">        propertyName, Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (bound == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (property.isSettable()) &#123;</span><br><span class="line">        property.setValue(beanSupplier, bound);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="keyword">null</span> || !bound.equals(value.get())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No setter found for property: "</span> + property.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就比较简单了, 分步拿到了配置Bean属性的定义和值:</p>
<ul>
<li><p>field: 即propertyName, e.g. <code>name</code></p>
</li>
<li><p>属性类型: type, e.g. <code>java.lang.String</code></p>
</li>
<li><p>getter and setter</p>
<p>e.g.<code>public void com.example.cache.config.CustomProperties.setName(java.lang.String)</code></p>
</li>
<li><p>以及调用<code>propertyBinder.bindProperty()</code>拿到了资源属性文件中的属性值<code>bound</code></p>
<p>该方法的作用前面也提到过(e.g. <code>thank</code> )</p>
</li>
</ul>
<p>然后调用了属性的<code>setValue()</code>方法: 执行<code>property.setValue(beanSupplier, bound);</code></p>
<p>至此, 看到了调用属性的set方法, 终于可以放心了!</p>
<p>从<code>ConfigurationPropertiesBindingPostProcessor</code>开始到调用setter结束, 完整的调用栈如下:</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">bind:85, JavaBeanBinder &#123;<span class="attribute">org.springframework.boot.context.properties.bind&#125;</span></span><br><span class="line"><span class="attribute">bind</span>:62, JavaBeanBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:54, JavaBeanBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">lambda$null$5:341, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">apply:-1, 1445225850 &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span><span class="variable">.Binder</span>$$Lambda$267&#125;</span><br><span class="line">accept:193, ReferencePipeline$3$1 &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">tryAdvance:1351, ArrayList$ArrayListSpliterator &#123;java<span class="variable">.util</span>&#125;</span><br><span class="line">forEachWithCancel:126, ReferencePipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">copyIntoWithCancel:498, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">copyInto:485, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">wrapAndCopyInto:471, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">evaluateSequential:152, FindOps$FindOp &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">evaluate:234, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">findFirst:464, ReferencePipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">lambda$bindBean$6:342, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">get:-1, 2008619427 &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span><span class="variable">.Binder</span>$$Lambda$266&#125;</span><br><span class="line">withIncreasedDepth:441, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">withBean:427, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">access$400:381, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bindBean:339, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bindObject:278, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:221, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:210, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:192, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:82, ConfigurationPropertiesBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br><span class="line">bind:107, ConfigurationPropertiesBindingPostProcessor &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br><span class="line">postProcessBeforeInitialization:93, ConfigurationPropertiesBindingPostProcessor &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>参考：</p>
<p><a href="https://blog.csdn.net/pange1991/article/details/81356594" target="_blank" rel="noopener">Spring @Import注解 —— 导入资源</a></p>
<p><a href="https://blog.csdn.net/tuoni123/article/details/80213050" target="_blank" rel="noopener">SpringBoot @Import 详解</a></p>
<p><a href="https://juejin.im/post/5c761c096fb9a049b41d2299" target="_blank" rel="noopener">Spring Boot 自动配置之@Enable* 与@Import注解</a></p>
<p>SpringBoot 的 @Import 用于将指定的类示例注入到 Spring IOC Container 中。</p>
<p>提供了三种方法：</p>
<ul>
<li>直接注入(@Import)</li>
<li>实现 ImportBeanDefinitionRegistrar 接口 注入</li>
<li>实现 ImportSelector 注入</li>
</ul>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://img-blog.csdnimg.cn/20200307165337725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>多数据源</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之BeanDefinitionRegistry</title>
    <url>/2020/03/04/Spring%E4%B9%8BBeanDefinitionRegistry/</url>
    <content><![CDATA[<p>Spring 的 Bean 是以 BeanDefinition 的形式存在的</p>
<h2 id="BeanDefinitionRegistry-源码"><a href="#BeanDefinitionRegistry-源码" class="headerlink" title="BeanDefinitionRegistry 源码"></a><em>BeanDefinitionRegistry 源码</em></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否存在 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition 名称</span></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition 的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bean 的名字是否被使用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>BeanDefinitionRegistry 是 BeanDefnition 的注册中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父子关系</span></span><br><span class="line">BeanDefinitionRegistry</span><br><span class="line">|</span><br><span class="line">--- SimpleBeanDefinitionRegistry</span><br><span class="line">|</span><br><span class="line">--- DefaultListableBeanFactory(核心)</span><br><span class="line">|</span><br><span class="line">--- GenericApplicationContext(核心)</span><br></pre></td></tr></table></figure>

<h2 id="SimpleBeanDefinitionRegistry-源码"><a href="#SimpleBeanDefinitionRegistry-源码" class="headerlink" title="SimpleBeanDefinitionRegistry 源码"></a><em>SimpleBeanDefinitionRegistry 源码</em></h2><p>SimpleBeanDefinitionRegistry 的源码看起来比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.hasText(beanName, <span class="string">"'beanName' must not be empty"</span>);</span><br><span class="line">        Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanDefinitionMap.remove(beanName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAlias(beanName) || containsBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DefaultListableBeanFactory-源码"><a href="#DefaultListableBeanFactory-源码" class="headerlink" title="DefaultListableBeanFactory 源码"></a><em>DefaultListableBeanFactory 源码</em></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; javaxInjectProviderClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaxInjectProviderClass =</span><br><span class="line">                ClassUtils.forName(<span class="string">"javax.inject.Provider"</span>, DefaultListableBeanFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// JSR-330 API not available - Provider interface simply not supported then.</span></span><br><span class="line">            javaxInjectProviderClass = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map from serialized id to factory instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Optional id for this factory, for serialization purposes. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> String serializationId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether to allow re-registration of a different definition with the same name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowBeanDefinitionOverriding = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether to allow eager class loading even for lazy-init beans. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowEagerClassLoading = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Optional OrderComparator for dependency Lists and arrays. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;Object&gt; dependencyComparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resolver to use for checking if a bean definition is an autowire candidate. */</span></span><br><span class="line">    <span class="keyword">private</span> AutowireCandidateResolver autowireCandidateResolver = <span class="keyword">new</span> SimpleAutowireCandidateResolver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map from dependency type to corresponding autowired value. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of singleton and non-singleton bean names, keyed by dependency type. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of singleton-only bean names, keyed by dependency type. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of bean definition names, in registration order. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of names of manually registered singletons, in registration order. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cached array of bean definition names in case of frozen configuration. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String[] frozenBeanDefinitionNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether bean definition metadata may be cached for all beans. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> configurationFrozen = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new DefaultListableBeanFactory with the given parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parentBeanFactory the parent BeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Specify an id for serialization purposes, allowing this BeanFactory to be</span></span><br><span class="line"><span class="comment">	 * deserialized from this id back into the BeanFactory object, if needed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSerializationId</span><span class="params">(@Nullable String serializationId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            serializableFactories.put(serializationId, <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            serializableFactories.remove(<span class="keyword">this</span>.serializationId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.serializationId = serializationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an id for serialization purposes, if specified, allowing this BeanFactory</span></span><br><span class="line"><span class="comment">	 * to be deserialized from this id back into the BeanFactory object, if needed.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSerializationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serializationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * If not, an exception will be thrown. This also applies to overriding aliases.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowBeanDefinitionOverriding</span><span class="params">(<span class="keyword">boolean</span> allowBeanDefinitionOverriding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowBeanDefinitionOverriding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowBeanDefinitionOverriding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether the factory is allowed to eagerly load bean classes</span></span><br><span class="line"><span class="comment">	 * even for bean definitions that are marked as "lazy-init".</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true". Turn this flag off to suppress class loading</span></span><br><span class="line"><span class="comment">	 * for lazy-init beans unless such a bean is explicitly requested.</span></span><br><span class="line"><span class="comment">	 * In particular, by-type lookups will then simply ignore bean definitions</span></span><br><span class="line"><span class="comment">	 * without resolved class name, instead of loading the bean classes on</span></span><br><span class="line"><span class="comment">	 * demand just to perform a type check.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> AbstractBeanDefinition#setLazyInit</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowEagerClassLoading</span><span class="params">(<span class="keyword">boolean</span> allowEagerClassLoading)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allowEagerClassLoading = allowEagerClassLoading;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether the factory is allowed to eagerly load bean classes</span></span><br><span class="line"><span class="comment">	 * even for bean definitions that are marked as "lazy-init".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowEagerClassLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowEagerClassLoading;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a &#123;<span class="doctag">@link</span> java.util.Comparator&#125; for dependency Lists and arrays.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.OrderComparator</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.annotation.AnnotationAwareOrderComparator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependencyComparator</span><span class="params">(@Nullable Comparator&lt;Object&gt; dependencyComparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependencyComparator = dependencyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the dependency comparator for this BeanFactory (may be &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparator&lt;Object&gt; <span class="title">getDependencyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dependencyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a custom autowire candidate resolver for this BeanFactory to use</span></span><br><span class="line"><span class="comment">	 * when deciding whether a bean definition should be considered as a</span></span><br><span class="line"><span class="comment">	 * candidate for autowiring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutowireCandidateResolver</span><span class="params">(<span class="keyword">final</span> AutowireCandidateResolver autowireCandidateResolver)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(autowireCandidateResolver, <span class="string">"AutowireCandidateResolver must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (autowireCandidateResolver <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(DefaultListableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.autowireCandidateResolver = autowireCandidateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the autowire candidate resolver for this BeanFactory (never &#123;<span class="doctag">@code</span> null&#125;).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AutowireCandidateResolver <span class="title">getAutowireCandidateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autowireCandidateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyConfigurationFrom</span><span class="params">(ConfigurableBeanFactory otherFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.copyConfigurationFrom(otherFactory);</span><br><span class="line">        <span class="keyword">if</span> (otherFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            DefaultListableBeanFactory otherListableFactory = (DefaultListableBeanFactory) otherFactory;</span><br><span class="line">            <span class="keyword">this</span>.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;</span><br><span class="line">            <span class="keyword">this</span>.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;</span><br><span class="line">            <span class="keyword">this</span>.dependencyComparator = otherListableFactory.dependencyComparator;</span><br><span class="line">            <span class="comment">// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware...</span></span><br><span class="line">            setAutowireCandidateResolver(BeanUtils.instantiateClass(getAutowireCandidateResolver().getClass()));</span><br><span class="line">            <span class="comment">// Make resolvable dependencies (e.g. ResourceLoader) available here as well...</span></span><br><span class="line">            <span class="keyword">this</span>.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of remaining BeanFactory methods</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBean(requiredType, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, @Nullable Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) resolved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanProvider(ResolvableType.forRawClass(requiredType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanObjectProvider&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                T resolved = resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resolved;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                T resolved = resolveBean(requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resolved;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.stream(getBeanNamesForTypedStream(requiredType))</span><br><span class="line">                    .map(name -&gt; (T) getBean(name))</span><br><span class="line">                    .filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Stream&lt;T&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String[] beanNames = getBeanNamesForTypedStream(requiredType);</span><br><span class="line">                Map&lt;String, T&gt; matchingBeans = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    Object beanInstance = getBean(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                        matchingBeans.put(beanName, (T) beanInstance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Stream&lt;T&gt; stream = matchingBeans.values().stream();</span><br><span class="line">                <span class="keyword">return</span> stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">resolveBean</span><span class="params">(ResolvableType requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> </span>&#123;</span><br><span class="line">        NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">        <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> namedBean.getBeanInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((DefaultListableBeanFactory) parent).resolveBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ObjectProvider&lt;T&gt; parentProvider = parent.getBeanProvider(requiredType);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> parentProvider.getObject(args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] getBeanNamesForTypedStream(ResolvableType requiredType) &#123;</span><br><span class="line">        <span class="keyword">return</span> BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of ListableBeanFactory interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        String[] frozenNames = <span class="keyword">this</span>.frozenBeanDefinitionNames;</span><br><span class="line">        <span class="keyword">if</span> (frozenNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> frozenNames.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(ResolvableType type) &#123;</span><br><span class="line">        Class&lt;?&gt; resolved = type.resolve();</span><br><span class="line">        <span class="keyword">if</span> (resolved != <span class="keyword">null</span> &amp;&amp; !type.hasGenerics()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getBeanNamesForType(resolved, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doGetBeanNamesForType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanNamesForType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isConfigurationFrozen() || type == <span class="keyword">null</span> || !allowEagerInit) &#123;</span><br><span class="line">            <span class="keyword">return</span> doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, String[]&gt; cache =</span><br><span class="line">            (includeNonSingletons ? <span class="keyword">this</span>.allBeanNamesByType : <span class="keyword">this</span>.singletonBeanNamesByType);</span><br><span class="line">        String[] resolvedBeanNames = cache.get(type);</span><br><span class="line">        <span class="keyword">if</span> (resolvedBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">        &#125;</span><br><span class="line">        resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCacheSafe(type, getBeanClassLoader())) &#123;</span><br><span class="line">            cache.put(type, resolvedBeanNames);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] doGetBeanNamesForType(ResolvableType type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check all bean definitions.</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            <span class="comment">// Only consider bean as eligible if the bean name</span></span><br><span class="line">            <span class="comment">// is not defined as alias for some other bean.</span></span><br><span class="line">            <span class="keyword">if</span> (!isAlias(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                    <span class="comment">// Only check bean definition if it is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">                                              (mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">                                              !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">                        <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">                        <span class="keyword">boolean</span> isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">                        BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">                        <span class="keyword">boolean</span> matchFound =</span><br><span class="line">                            (allowEagerInit || !isFactoryBean ||</span><br><span class="line">                             (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">                            (includeNonSingletons ||</span><br><span class="line">                             (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">                            isTypeMatch(beanName, type);</span><br><span class="line">                        <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">                            <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line">                            beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">                            matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">                            result.add(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (CannotLoadBeanClassException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (allowEagerInit) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Probably a class name with a placeholder: let's ignore it for type matching purposes.</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignoring bean class loading failure for bean '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    onSuppressedException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (allowEagerInit) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Probably some metadata with a placeholder: let's ignore it for type matching purposes.</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignoring unresolvable metadata in bean definition '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    onSuppressedException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check manually registered singletons too.</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.manualSingletonNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((includeNonSingletons || isSingleton(beanName)) &amp;&amp; isTypeMatch(beanName, type)) &#123;</span><br><span class="line">                        result.add(beanName);</span><br><span class="line">                        <span class="comment">// Match found for this bean: do not match FactoryBean itself anymore.</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// In case of FactoryBean, try to match FactoryBean itself next.</span></span><br><span class="line">                    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Match raw bean instance (might be raw FactoryBean).</span></span><br><span class="line">                <span class="keyword">if</span> (isTypeMatch(beanName, type)) &#123;</span><br><span class="line">                    result.add(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                <span class="comment">// Shouldn't happen - probably a result of circular reference resolution...</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Failed to check manually registered singleton with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the specified bean would need to be eagerly initialized</span></span><br><span class="line"><span class="comment">	 * in order to determine its type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> factoryBeanName a factory-bean reference that the bean definition</span></span><br><span class="line"><span class="comment">	 * defines a factory method for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether eager initialization is necessary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requiresEagerInitForType</span><span class="params">(@Nullable String factoryBeanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (factoryBeanName != <span class="keyword">null</span> &amp;&amp; isFactoryBean(factoryBeanName) &amp;&amp; !containsSingleton(factoryBeanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeansOfType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">        Map&lt;String, T&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object beanInstance = getBean(beanName);</span><br><span class="line">                <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                    result.put(beanName, (T) beanInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">                <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                    BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">                    String exBeanName = bce.getBeanName();</span><br><span class="line">                    <span class="keyword">if</span> (exBeanName != <span class="keyword">null</span> &amp;&amp; isCurrentlyInCreation(exBeanName)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                            logger.trace(<span class="string">"Ignoring match to currently created bean '"</span> + exBeanName + <span class="string">"': "</span> +</span><br><span class="line">                                         ex.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        onSuppressedException(ex);</span><br><span class="line">                        <span class="comment">// Ignore: indicates a circular reference when autowiring constructors.</span></span><br><span class="line">                        <span class="comment">// We want to find matches other than the currently created bean itself.</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!beanDefinition.isAbstract() &amp;&amp; findAnnotationOnBean(beanName, annotationType) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.manualSingletonNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.contains(beanName) &amp;&amp; findAnnotationOnBean(beanName, annotationType) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">        String[] beanNames = getBeanNamesForAnnotation(annotationType);</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            Object beanInstance = getBean(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                result.put(beanName, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Find a &#123;<span class="doctag">@link</span> Annotation&#125; of &#123;<span class="doctag">@code</span> annotationType&#125; on the specified</span></span><br><span class="line"><span class="comment">	 * bean, traversing its interfaces and super classes if no annotation can be</span></span><br><span class="line"><span class="comment">	 * found on the given class itself, as well as checking its raw bean class</span></span><br><span class="line"><span class="comment">	 * if not found on the exposed bean reference (e.g. in case of a proxy).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        A ann = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; beanType = getType(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ann = AnnotationUtils.findAnnotation(beanType, annotationType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ann == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            BeanDefinition bd = getMergedBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                AbstractBeanDefinition abd = (AbstractBeanDefinition) bd;</span><br><span class="line">                <span class="keyword">if</span> (abd.hasBeanClass()) &#123;</span><br><span class="line">                    Class&lt;?&gt; beanClass = abd.getBeanClass();</span><br><span class="line">                    <span class="keyword">if</span> (beanClass != beanType) &#123;</span><br><span class="line">                        ann = AnnotationUtils.findAnnotation(beanClass, annotationType);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ann;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of ConfigurableListableBeanFactory interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerResolvableDependency</span><span class="params">(Class&lt;?&gt; dependencyType, @Nullable Object autowiredValue)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(dependencyType, <span class="string">"Dependency type must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (autowiredValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(autowiredValue <span class="keyword">instanceof</span> ObjectFactory || dependencyType.isInstance(autowiredValue))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Value ["</span> + autowiredValue +</span><br><span class="line">                                                   <span class="string">"] does not implement specified dependency type ["</span> + dependencyType.getName() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.resolvableDependencies.put(dependencyType, autowiredValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, DependencyDescriptor descriptor)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span></span><br><span class="line"><span class="comment">	 * to be injected into other beans which declare a dependency of matching type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the bean should be considered as autowire candidate</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">        <span class="keyword">if</span> (containsBeanDefinition(beanDefinitionName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isAutowireCandidate(beanName, <span class="keyword">new</span> RootBeanDefinition(getType(beanName)), descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            <span class="comment">// No bean definition found in this factory -&gt; delegate to parent.</span></span><br><span class="line">            <span class="keyword">return</span> ((DefaultListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            <span class="comment">// If no DefaultListableBeanFactory, can't pass the resolver along.</span></span><br><span class="line">            <span class="keyword">return</span> ((ConfigurableListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span></span><br><span class="line"><span class="comment">	 * to be injected into other beans which declare a dependency of matching type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mbd the merged bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the bean should be considered as autowire candidate</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">        resolveBeanClass(mbd, beanDefinitionName);</span><br><span class="line">        <span class="keyword">if</span> (mbd.isFactoryMethodUnique &amp;&amp; mbd.factoryMethodToIntrospect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).resolveFactoryMethodIfPossible(mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolver.isAutowireCandidate(</span><br><span class="line">            <span class="keyword">new</span> BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">getBeanNamesIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompositeIterator&lt;String&gt; iterator = <span class="keyword">new</span> CompositeIterator&lt;&gt;();</span><br><span class="line">        iterator.add(<span class="keyword">this</span>.beanDefinitionNames.iterator());</span><br><span class="line">        iterator.add(<span class="keyword">this</span>.manualSingletonNames.iterator());</span><br><span class="line">        <span class="keyword">return</span> iterator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMetadataCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clearMetadataCache();</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configurationFrozen = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConfigurationFrozen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configurationFrozen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Considers all beans as eligible for metadata caching</span></span><br><span class="line"><span class="comment">	 * if the factory's configuration has been marked as frozen.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #freezeConfiguration()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isBeanEligibleForMetadataCaching</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.configurationFrozen || <span class="keyword">super</span>.isBeanEligibleForMetadataCaching(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">        <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                        <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                        <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                                        ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                                        getAccessControlContext());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                           ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                            getBean(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            Object singletonInstance = getSingleton(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">                <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of BeanDefinitionRegistry interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">        Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                       <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">                <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                                <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                                existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                                 <span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                                 <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                                 <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                                 <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">                <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                    List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                    updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                    updatedDefinitions.add(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                        Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                        updatedSingletons.remove(beanName);</span><br><span class="line">                        <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Still in startup registration phase</span></span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">            resetBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        Assert.hasText(beanName, <span class="string">"'beanName' must not be empty"</span>);</span><br><span class="line"></span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.remove(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.remove(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset all bean definition caches for the given bean,</span></span><br><span class="line"><span class="comment">	 * including the caches of beans that are derived from it.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Called after an existing bean definition has been replaced or removed,</span></span><br><span class="line"><span class="comment">	 * triggering &#123;<span class="doctag">@link</span> #clearMergedBeanDefinition&#125;, &#123;<span class="doctag">@link</span> #destroySingleton&#125;</span></span><br><span class="line"><span class="comment">	 * and &#123;<span class="doctag">@link</span> MergedBeanDefinitionPostProcessor#resetBeanDefinition&#125; on the</span></span><br><span class="line"><span class="comment">	 * given bean and on all bean definitions that have the given bean as parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean to reset</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #removeBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove the merged bean definition for the given bean, if already created.</span></span><br><span class="line">        clearMergedBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove corresponding bean from singleton cache, if any. Shouldn't usually</span></span><br><span class="line">        <span class="comment">// be necessary, rather just meant for overriding a context's default beans</span></span><br><span class="line">        <span class="comment">// (e.g. the default StaticMessageSource in a StaticApplicationContext).</span></span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify all post-processors that the specified bean definition has been reset.</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processor <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset all bean definitions that have the given bean as parent (recursively).</span></span><br><span class="line">        <span class="keyword">for</span> (String bdName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beanName.equals(bdName)) &#123;</span><br><span class="line">                BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(bdName);</span><br><span class="line">                <span class="keyword">if</span> (beanName.equals(bd.getParentName())) &#123;</span><br><span class="line">                    resetBeanDefinition(bdName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Only allows alias overriding if bean definition overriding is allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">allowAliasOverriding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAllowBeanDefinitionOverriding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.registerSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames.size() + <span class="number">1</span>);</span><br><span class="line">                    updatedSingletons.addAll(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.add(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.manualSingletonNames.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroySingletons();</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames.clear();</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Remove any assumptions about by-type mappings.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearByTypeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allBeanNamesByType.clear();</span><br><span class="line">        <span class="keyword">this</span>.singletonBeanNamesByType.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Dependency resolution functionality</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> namedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AutowireCapableBeanFactory) parent).resolveNamedBean(requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ResolvableType requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(requiredType, <span class="string">"Required type must not be null"</span>);</span><br><span class="line">        String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateNames.length);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">                    autowireCandidates.add(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">                candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">            String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object beanInstance = getBean(beanName);</span><br><span class="line">                    candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    candidates.put(beanName, getType(beanName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line">            <span class="keyword">if</span> (candidateName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidateName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object beanInstance = candidates.get(candidateName);</span><br><span class="line">                <span class="keyword">if</span> (beanInstance == <span class="keyword">null</span> || beanInstance <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!nonUniqueAsNull) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">        <span class="keyword">if</span> (Optional<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType() ||</span><br><span class="line">                 ObjectProvider<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">                descriptor, requestingBeanName);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> shortcut;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">            Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">                    BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">                                         getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">                    value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">                &#125;</span><br><span class="line">                TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">                    <span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">                    <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">                            converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                            converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">            <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> multipleBeans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String autowiredBeanName;</span><br><span class="line">            Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">                <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">                        <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">                        <span class="comment">// (before 4.3 in particular when we didn't even look for collection beans).</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We have exactly one match.</span></span><br><span class="line">                Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">                autowiredBeanName = entry.getKey();</span><br><span class="line">                instanceCandidate = entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result = instanceCandidate;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">                &#125;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            Stream&lt;Object&gt; stream = matchingBeans.keySet().stream()</span><br><span class="line">                .map(name -&gt; descriptor.resolveCandidate(name, type, <span class="keyword">this</span>))</span><br><span class="line">                .filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">            <span class="keyword">if</span> (((StreamDependencyDescriptor) descriptor).isOrdered()) &#123;</span><br><span class="line">                stream = stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = type.getComponentType();</span><br><span class="line">            ResolvableType resolvableType = descriptor.getResolvableType();</span><br><span class="line">            Class&lt;?&gt; resolvedArrayType = resolvableType.resolve(type);</span><br><span class="line">            <span class="keyword">if</span> (resolvedArrayType != type) &#123;</span><br><span class="line">                componentType = resolvableType.getComponentType().resolve();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (componentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">                Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">                <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Arrays.sort((Object[]) result, comparator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) &amp;&amp; <span class="title">type</span>.<span class="title">isInterface</span>()) </span>&#123;</span><br><span class="line">            Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</span><br><span class="line">            <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            Object result = converter.convertIfNecessary(matchingBeans.values(), type);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">                Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">                <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ((List&lt;?&gt;) result).sort(comparator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Map<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            ResolvableType mapType = descriptor.getResolvableType().asMap();</span><br><span class="line">            Class&lt;?&gt; keyType = mapType.resolveGeneric(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (String<span class="class">.<span class="keyword">class</span> !</span>= keyType) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; valueType = mapType.resolveGeneric(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (valueType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> matchingBeans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">(DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAutowireCandidateResolver().isRequired(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">indicatesMultipleBeans</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (type.isArray() || (type.isInterface() &amp;&amp;</span><br><span class="line">                                   (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) || <span class="title">Map</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>))))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Comparator&lt;Object&gt; <span class="title">adaptDependencyComparator</span><span class="params">(Map&lt;String, ?&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = getDependencyComparator();</span><br><span class="line">        <span class="keyword">if</span> (comparator <span class="keyword">instanceof</span> OrderComparator) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((OrderComparator) comparator).withSourceProvider(</span><br><span class="line">                createFactoryAwareOrderSourceProvider(matchingBeans));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> comparator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Comparator&lt;Object&gt; <span class="title">adaptOrderComparator</span><span class="params">(Map&lt;String, ?&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; dependencyComparator = getDependencyComparator();</span><br><span class="line">        OrderComparator comparator = (dependencyComparator <span class="keyword">instanceof</span> OrderComparator ?</span><br><span class="line">                                      (OrderComparator) dependencyComparator : OrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">return</span> comparator.withSourceProvider(createFactoryAwareOrderSourceProvider(matchingBeans));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderComparator.<span class="function">OrderSourceProvider <span class="title">createFactoryAwareOrderSourceProvider</span><span class="params">(Map&lt;String, ?&gt; beans)</span> </span>&#123;</span><br><span class="line">        IdentityHashMap&lt;Object, String&gt; instancesToBeanNames = <span class="keyword">new</span> IdentityHashMap&lt;&gt;();</span><br><span class="line">        beans.forEach((beanName, instance) -&gt; instancesToBeanNames.put(instance, beanName));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FactoryAwareOrderSourceProvider(instancesToBeanNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Find bean instances that match the required type.</span></span><br><span class="line"><span class="comment">	 * Called during autowiring for the specified bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean that is about to be wired</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the actual type of bean to look for</span></span><br><span class="line"><span class="comment">	 * (may be an array component type or collection element type)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a Map of candidate names and candidate instances that match</span></span><br><span class="line"><span class="comment">	 * the required type (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #autowireByType</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">findAutowireCandidates</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">            <span class="keyword">this</span>, requiredType, <span class="keyword">true</span>, descriptor.isEager());</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; classObjectEntry : <span class="keyword">this</span>.resolvableDependencies.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; autowiringType = classObjectEntry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">                Object autowiringValue = classObjectEntry.getValue();</span><br><span class="line">                autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">                <span class="keyword">if</span> (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">                    result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">                addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> multiple = indicatesMultipleBeans(requiredType);</span><br><span class="line">            <span class="comment">// Consider fallback matches if the first pass failed to find anything...</span></span><br><span class="line">            DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();</span><br><span class="line">            <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, fallbackDescriptor) &amp;&amp;</span><br><span class="line">                    (!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) &#123;</span><br><span class="line">                    addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.isEmpty() &amp;&amp; !multiple) &#123;</span><br><span class="line">                <span class="comment">// Consider self references as a final pass...</span></span><br><span class="line">                <span class="comment">// but in the case of a dependency collection, not the very same bean itself.</span></span><br><span class="line">                <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isSelfReference(beanName, candidate) &amp;&amp;</span><br><span class="line">                        (!(descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) || !beanName.equals(candidate)) &amp;&amp;</span><br><span class="line">                        isAutowireCandidate(candidate, fallbackDescriptor)) &#123;</span><br><span class="line">                        addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Add an entry to the candidate map: a bean instance if available or just the resolved</span></span><br><span class="line"><span class="comment">	 * type, preventing early bean initialization ahead of primary candidate selection.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCandidateEntry</span><span class="params">(Map&lt;String, Object&gt; candidates, String candidateName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   DependencyDescriptor descriptor, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) &#123;</span><br><span class="line">            Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                candidates.put(candidateName, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(candidateName) || (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor &amp;&amp;</span><br><span class="line">                                                      ((StreamDependencyDescriptor) descriptor).isOrdered())) &#123;</span><br><span class="line">            Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">            candidates.put(candidateName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            candidates.put(candidateName, getType(candidateName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the autowire candidate in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Looks for &#123;<span class="doctag">@code</span> <span class="doctag">@Primary</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@Priority</span>&#125; (in that order).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * that match the required type, as returned by &#123;<span class="doctag">@link</span> #findAutowireCandidates&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the target dependency to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the autowire candidate, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineAutowireCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; requiredType = descriptor.getDependencyType();</span><br><span class="line">        String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (primaryCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryCandidate;</span><br><span class="line">        &#125;</span><br><span class="line">        String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (priorityCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> priorityCandidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fallback</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> ((beanInstance != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.resolvableDependencies.containsValue(beanInstance)) ||</span><br><span class="line">                matchesBeanName(candidateName, descriptor.getDependencyName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidateName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the primary candidate in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * (or candidate classes if not created yet) that match the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the target dependency type to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the primary candidate, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isPrimary(String, Object)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determinePrimaryCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        String primaryBeanName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateBeanName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (isPrimary(candidateBeanName, beanInstance)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (primaryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> candidateLocal = containsBeanDefinition(candidateBeanName);</span><br><span class="line">                    <span class="keyword">boolean</span> primaryLocal = containsBeanDefinition(primaryBeanName);</span><br><span class="line">                    <span class="keyword">if</span> (candidateLocal &amp;&amp; primaryLocal) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                                                                  <span class="string">"more than one 'primary' bean found among candidates: "</span> + candidates.keySet());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (candidateLocal) &#123;</span><br><span class="line">                        primaryBeanName = candidateBeanName;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    primaryBeanName = candidateBeanName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primaryBeanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the candidate with the highest priority in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Based on &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.annotation.Priority&#125;. As defined by the related</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered&#125; interface, the lowest value has</span></span><br><span class="line"><span class="comment">	 * the highest priority.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * (or candidate classes if not created yet) that match the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the target dependency type to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the candidate with the highest priority,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPriority(Object)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineHighestPriorityCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        String highestPriorityBeanName = <span class="keyword">null</span>;</span><br><span class="line">        Integer highestPriority = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateBeanName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Integer candidatePriority = getPriority(beanInstance);</span><br><span class="line">                <span class="keyword">if</span> (candidatePriority != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (highestPriorityBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (candidatePriority.equals(highestPriority)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                                                                      <span class="string">"Multiple beans found with the same priority ('"</span> + highestPriority +</span><br><span class="line">                                                                      <span class="string">"') among candidates: "</span> + candidates.keySet());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (candidatePriority &lt; highestPriority) &#123;</span><br><span class="line">                            highestPriorityBeanName = candidateBeanName;</span><br><span class="line">                            highestPriority = candidatePriority;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        highestPriorityBeanName = candidateBeanName;</span><br><span class="line">                        highestPriority = candidatePriority;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> highestPriorityBeanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether the bean definition for the given bean name has been</span></span><br><span class="line"><span class="comment">	 * marked as a primary bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanInstance the corresponding bean instance (can be null)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the given bean qualifies as primary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">(String beanName, Object beanInstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getMergedLocalBeanDefinition(beanName).isPrimary();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">return</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory &amp;&amp;</span><br><span class="line">                ((DefaultListableBeanFactory) parent).isPrimary(beanName, beanInstance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the priority assigned for the given bean instance by</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@code</span> javax.annotation.Priority&#125; annotation.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation delegates to the specified</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> #setDependencyComparator dependency comparator&#125;, checking its</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> OrderComparator#getPriority method&#125; if it is an extension of</span></span><br><span class="line"><span class="comment">	 * Spring's common &#123;<span class="doctag">@link</span> OrderComparator&#125; - typically, an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.AnnotationAwareOrderComparator&#125;.</span></span><br><span class="line"><span class="comment">	 * If no such comparator is present, this implementation returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanInstance the bean instance to check (can be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the priority assigned to that bean or &#123;<span class="doctag">@code</span> null&#125; if none is set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">getPriority</span><span class="params">(Object beanInstance)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = getDependencyComparator();</span><br><span class="line">        <span class="keyword">if</span> (comparator <span class="keyword">instanceof</span> OrderComparator) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((OrderComparator) comparator).getPriority(beanInstance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given candidate name matches the bean name or the aliases</span></span><br><span class="line"><span class="comment">	 * stored in this bean definition.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesBeanName</span><span class="params">(String beanName, @Nullable String candidateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (candidateName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given beanName/candidateName pair indicates a self reference,</span></span><br><span class="line"><span class="comment">	 * i.e. whether the candidate points back to the original bean or to a factory method</span></span><br><span class="line"><span class="comment">	 * on the original bean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSelfReference</span><span class="params">(@Nullable String beanName, @Nullable String candidateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (beanName != <span class="keyword">null</span> &amp;&amp; candidateName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (beanName.equals(candidateName) || (containsBeanDefinition(candidateName) &amp;&amp;</span><br><span class="line">                                                    beanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName()))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException</span></span><br><span class="line"><span class="comment">	 * for an unresolvable dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">raiseNoMatchingBeanFound</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; type, ResolvableType resolvableType, DependencyDescriptor descriptor)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        checkBeanNotOfRequiredType(type, descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(resolvableType,</span><br><span class="line">                                                <span class="string">"expected at least 1 bean which qualifies as autowire candidate. "</span> +</span><br><span class="line">                                                <span class="string">"Dependency annotations: "</span> + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,</span></span><br><span class="line"><span class="comment">	 * i.e. if the target type of the bean would match but an exposed proxy doesn't.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkBeanNotOfRequiredType</span><span class="params">(Class&lt;?&gt; type, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            Class&lt;?&gt; targetType = mbd.getTargetType();</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; type.isAssignableFrom(targetType) &amp;&amp;</span><br><span class="line">                isAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) &#123;</span><br><span class="line">                <span class="comment">// Probably a proxy interfering with target type match -&gt; throw meaningful exception.</span></span><br><span class="line">                Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">                Class&lt;?&gt; beanType = (beanInstance != <span class="keyword">null</span> &amp;&amp; beanInstance.getClass() != NullBean<span class="class">.<span class="keyword">class</span> ?</span></span><br><span class="line">                                     beanInstance.getClass() : predictBeanType(beanName, mbd));</span><br><span class="line">                <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; !type.isAssignableFrom(beanType)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(beanName, type, beanType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            ((DefaultListableBeanFactory) parent).checkBeanNotOfRequiredType(type, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an &#123;<span class="doctag">@link</span> Optional&#125; wrapper for the specified dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;?&gt; createOptionalDependency(</span><br><span class="line">        DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName, <span class="keyword">final</span> Object... args) &#123;</span><br><span class="line"></span><br><span class="line">        DependencyDescriptor descriptorToUse = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :</span><br><span class="line">                        <span class="keyword">super</span>.resolveCandidate(beanName, requiredType, beanFactory));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object result = doResolveDependency(descriptorToUse, beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Optional ? (Optional&lt;?&gt;) result : Optional.ofNullable(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(ObjectUtils.identityToString(<span class="keyword">this</span>));</span><br><span class="line">        sb.append(<span class="string">": defining beans ["</span>);</span><br><span class="line">        sb.append(StringUtils.collectionToCommaDelimitedString(<span class="keyword">this</span>.beanDefinitionNames));</span><br><span class="line">        sb.append(<span class="string">"]; "</span>);</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"root of factory hierarchy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(<span class="string">"parent: "</span>).append(ObjectUtils.identityToString(parent));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Serialization support</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(<span class="string">"DefaultListableBeanFactory itself is not deserializable - "</span> +</span><br><span class="line">                                           <span class="string">"just a SerializedBeanFactoryReference is"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SerializedBeanFactoryReference(<span class="keyword">this</span>.serializationId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(<span class="string">"DefaultListableBeanFactory has no serialization id"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Minimal id reference to the factory.</span></span><br><span class="line"><span class="comment">	 * Resolved to the actual factory instance on deserialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedBeanFactoryReference</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SerializedBeanFactoryReference</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Reference&lt;?&gt; ref = serializableFactories.get(<span class="keyword">this</span>.id);</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object result = ref.get();</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lenient fallback: dummy factory in case of original factory not found...</span></span><br><span class="line">            DefaultListableBeanFactory dummyFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">            dummyFactory.serializationId = <span class="keyword">this</span>.id;</span><br><span class="line">            <span class="keyword">return</span> dummyFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor marker for nested elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedDependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">DependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NestedDependencyDescriptor</span><span class="params">(DependencyDescriptor original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">            increaseNestingLevel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor for a multi-element declaration with nested elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiElementDescriptor</span> <span class="keyword">extends</span> <span class="title">NestedDependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiElementDescriptor</span><span class="params">(DependencyDescriptor original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor marker for stream access to multiple elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">DependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StreamDependencyDescriptor</span><span class="params">(DependencyDescriptor original, <span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">            <span class="keyword">this</span>.ordered = ordered;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.ordered;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanObjectProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ObjectProvider</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyObjectProvider</span> <span class="keyword">implements</span> <span class="title">BeanObjectProvider</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DependencyDescriptor descriptor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> optional;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DependencyObjectProvider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor);</span><br><span class="line">            <span class="keyword">this</span>.optional = (<span class="keyword">this</span>.descriptor.getDependencyType() == Optional<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Object result = doResolveDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="keyword">this</span>.descriptor.getResolvableType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> beanFactory.getBean(beanName, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                Object result = doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="keyword">this</span>.descriptor.getResolvableType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@Nullable</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">resolveNotUnique</span><span class="params">(ResolvableType type, Map&lt;String, Object&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(descriptorToUse, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Stream&lt;Object&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolveStream(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Stream&lt;Object&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolveStream(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Stream&lt;Object&gt; <span class="title">resolveStream</span><span class="params">(<span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">            DependencyDescriptor descriptorToUse = <span class="keyword">new</span> StreamDependencyDescriptor(<span class="keyword">this</span>.descriptor, ordered);</span><br><span class="line">            Object result = doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Stream ? (Stream&lt;Object&gt;) result : Stream.of(result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Separate inner class for avoiding a hard dependency on the &#123;<span class="doctag">@code</span> javax.inject&#125; API.</span></span><br><span class="line"><span class="comment">	 * Actual &#123;<span class="doctag">@code</span> javax.inject.Provider&#125; implementation is nested here in order to make it</span></span><br><span class="line"><span class="comment">	 * invisible for Graal's introspection of DefaultListableBeanFactory's nested classes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Jsr330Factory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">createDependencyProvider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Provider(descriptor, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Jsr330Provider</span> <span class="keyword">extends</span> <span class="title">DependencyObjectProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Jsr330Provider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(descriptor, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * An &#123;<span class="doctag">@link</span> org.springframework.core.OrderComparator.OrderSourceProvider&#125; implementation</span></span><br><span class="line"><span class="comment">	 * that is aware of the bean metadata of the instances to sort.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Lookup for the method factory of an instance to sort, if any, and let the</span></span><br><span class="line"><span class="comment">	 * comparator retrieve the &#123;<span class="doctag">@link</span> org.springframework.core.annotation.Order&#125;</span></span><br><span class="line"><span class="comment">	 * value defined on it. This essentially allows for the following construct:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryAwareOrderSourceProvider</span> <span class="keyword">implements</span> <span class="title">OrderComparator</span>.<span class="title">OrderSourceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, String&gt; instancesToBeanNames;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FactoryAwareOrderSourceProvider</span><span class="params">(Map&lt;Object, String&gt; instancesToBeanNames)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.instancesToBeanNames = instancesToBeanNames;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getOrderSource</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            RootBeanDefinition beanDefinition = getRootBeanDefinition(<span class="keyword">this</span>.instancesToBeanNames.get(obj));</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Object&gt; sources = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            Method factoryMethod = beanDefinition.getResolvedFactoryMethod();</span><br><span class="line">            <span class="keyword">if</span> (factoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sources.add(factoryMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; targetType = beanDefinition.getTargetType();</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType != obj.getClass()) &#123;</span><br><span class="line">                sources.add(targetType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sources.toArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> RootBeanDefinition <span class="title">getRootBeanDefinition</span><span class="params">(@Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                BeanDefinition bd = getMergedBeanDefinition(beanName);</span><br><span class="line">                <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (RootBeanDefinition) bd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GenericApplicationContext-源码"><a href="#GenericApplicationContext-源码" class="headerlink" title="GenericApplicationContext 源码"></a><em>GenericApplicationContext 源码</em></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> customClassLoader = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean refreshed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the DefaultListableBeanFactory instance to use for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanFactory, <span class="string">"BeanFactory must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent the parent application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the DefaultListableBeanFactory instance to use for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent the parent application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory, ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(beanFactory);</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set the parent of this application context, also setting</span></span><br><span class="line"><span class="comment">	 * the parent of the internal BeanFactory accordingly.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setParent(parent);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setParentBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * If not, an exception will be thrown. Default is "true".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowBeanDefinitionOverriding</span><span class="params">(<span class="keyword">boolean</span> allowBeanDefinitionOverriding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether to allow circular references between beans - and automatically</span></span><br><span class="line"><span class="comment">	 * try to resolve them.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true". Turn this off to throw an exception when encountering</span></span><br><span class="line"><span class="comment">	 * a circular reference, disallowing them completely.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowCircularReferences</span><span class="params">(<span class="keyword">boolean</span> allowCircularReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setAllowCircularReferences(allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a ResourceLoader to use for this context. If set, the context will</span></span><br><span class="line"><span class="comment">	 * delegate all &#123;<span class="doctag">@code</span> getResource&#125; calls to the given ResourceLoader.</span></span><br><span class="line"><span class="comment">	 * If not set, default resource loading will apply.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The main reason to specify a custom ResourceLoader is to resolve</span></span><br><span class="line"><span class="comment">	 * resource paths (without URL prefix) in a specific fashion.</span></span><br><span class="line"><span class="comment">	 * The default behavior is to resolve such paths as class path locations.</span></span><br><span class="line"><span class="comment">	 * To resolve resource paths as file system locations, specify a</span></span><br><span class="line"><span class="comment">	 * FileSystemResourceLoader here.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;You can also pass in a full ResourcePatternResolver, which will</span></span><br><span class="line"><span class="comment">	 * be autodetected by the context and used for &#123;<span class="doctag">@code</span> getResources&#125;</span></span><br><span class="line"><span class="comment">	 * calls as well. Else, default resource pattern matching will apply.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getResource</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.DefaultResourceLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.FileSystemResourceLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.support.ResourcePatternResolver</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getResources</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ResourceLoader / ResourcePatternResolver override if necessary</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation delegates to this context's ResourceLoader if set,</span></span><br><span class="line"><span class="comment">	 * falling back to the default superclass behavior else.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getResource(location);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResource(location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation delegates to this context's ResourceLoader if it</span></span><br><span class="line"><span class="comment">	 * implements the ResourcePatternResolver interface, falling back to the</span></span><br><span class="line"><span class="comment">	 * default superclass behavior else.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ResourcePatternResolver) <span class="keyword">this</span>.resourceLoader).getResources(locationPattern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassLoader</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">this</span>.customClassLoader = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.customClassLoader) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementations of AbstractApplicationContext's template methods</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Do nothing: We hold a single internal BeanFactory and rely on callers</span></span><br><span class="line"><span class="comment">	 * to register beans through our public methods (or the BeanFactory's).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cancelRefresh</span><span class="params">(BeansException ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">super</span>.cancelRefresh(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Not much to do: We hold a single internal BeanFactory that will never</span></span><br><span class="line"><span class="comment">	 * get released.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the single internal BeanFactory held by this context</span></span><br><span class="line"><span class="comment">	 * (as ConfigurableListableBeanFactory).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the underlying bean factory of this context,</span></span><br><span class="line"><span class="comment">	 * available for registering bean definitions.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; You need to call &#123;<span class="doctag">@link</span> #refresh()&#125; to initialize the</span></span><br><span class="line"><span class="comment">	 * bean factory and its contained beans with application context semantics</span></span><br><span class="line"><span class="comment">	 * (autodetecting BeanFactoryPostProcessors, etc).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the internal bean factory (as DefaultListableBeanFactory)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> DefaultListableBeanFactory <span class="title">getDefaultListableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of BeanDefinitionRegistry</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.removeBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.isBeanNameInUse(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String beanName, String alias)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAlias</span><span class="params">(String alias)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.removeAlias(alias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlias</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.isAlias(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Convenient methods for registering individual beans</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, optionally customizing its</span></span><br><span class="line"><span class="comment">	 * bean definition metadata (typically declared as a lambda expression</span></span><br><span class="line"><span class="comment">	 * or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean (resolving a public constructor</span></span><br><span class="line"><span class="comment">	 * to be autowired, possibly simply the default constructor)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; beanClass, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line">        registerBean(<span class="keyword">null</span>, beanClass, <span class="keyword">null</span>, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean (resolving a public constructor</span></span><br><span class="line"><span class="comment">	 * to be autowired, possibly simply the default constructor)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String beanName, Class&lt;T&gt; beanClass, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registerBean(beanName, beanClass, <span class="keyword">null</span>, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> supplier a callback for creating an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;T&gt; beanClass, Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registerBean(<span class="keyword">null</span>, beanClass, supplier, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method can be overridden to adapt the registration mechanism for</span></span><br><span class="line"><span class="comment">	 * all &#123;<span class="doctag">@code</span> registerBean&#125; methods (since they all delegate to this one).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> supplier a callback for creating an instance of the bean (in case</span></span><br><span class="line"><span class="comment">	 * of &#123;<span class="doctag">@code</span> null&#125;, resolving a public constructor to be autowired instead)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(@Nullable String beanName, Class&lt;T&gt; beanClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassDerivedBeanDefinition beanDefinition = <span class="keyword">new</span> ClassDerivedBeanDefinition(beanClass);</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanDefinition.setInstanceSupplier(supplier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">            customizer.customize(beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String nameToUse = (beanName != <span class="keyword">null</span> ? beanName : beanClass.getName());</span><br><span class="line">        registerBeanDefinition(nameToUse, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> RootBeanDefinition&#125; marker subclass for &#123;<span class="doctag">@code</span> #registerBean&#125; based</span></span><br><span class="line"><span class="comment">	 * registrations with flexible autowiring for public constructors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDerivedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">RootBeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClassDerivedBeanDefinition</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(beanClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClassDerivedBeanDefinition</span><span class="params">(ClassDerivedBeanDefinition original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> Constructor&lt;?&gt;[] getPreferredConstructors() &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = getBeanClass();</span><br><span class="line">            Constructor&lt;?&gt; primaryCtor = BeanUtils.findPrimaryConstructor(clazz);</span><br><span class="line">            <span class="keyword">if</span> (primaryCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryCtor&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            Constructor&lt;?&gt;[] publicCtors = clazz.getConstructors();</span><br><span class="line">            <span class="keyword">if</span> (publicCtors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> publicCtors;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RootBeanDefinition <span class="title">cloneBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ClassDerivedBeanDefinition(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>todo: 未完待续…</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant知识点</title>
    <url>/2020/03/04/Vagrant%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-什么是vagrant"><a href="#1-什么是vagrant" class="headerlink" title="1.什么是vagrant"></a><strong>1.什么是vagrant</strong></h2><p>  vagrant 是一个通过命令行，来管理虚拟机的工具，vagrant 本身并没有提供虚拟化的功能，vagrant 可以用来管理virtualbox，可以通过vagrant 提供的命令创建，启动和关闭virtualbox里面的虚拟机</p>
<h2 id="2-为什么要使用vagrant"><a href="#2-为什么要使用vagrant" class="headerlink" title="2.为什么要使用vagrant"></a>2.<strong>为什么要使用vagrant</strong></h2><p> vagrant提供一个配置文件 vagrantfile,可以通过该配置文件快速创建或者复制一个虚拟机，同时是用命令行来管理虚拟机非常简单</p>
<h2 id="3-必须要有virtualbox才能正常安装vagrant"><a href="#3-必须要有virtualbox才能正常安装vagrant" class="headerlink" title="3.必须要有virtualbox才能正常安装vagrant"></a>3.<strong>必须要有virtualbox才能正常安装vagrant</strong></h2><a id="more"></a>

<h2 id="4-vagrant常用命令"><a href="#4-vagrant常用命令" class="headerlink" title="4.vagrant常用命令"></a>4.<strong>vagrant常用命令</strong></h2><ul>
<li><p>初始化vagrant工程</p>
<p>vagrant init ubuntu/trusty64：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">该命令会在当前目录下创建vagrantfile,并且指定所使用的<span class="built_in">box</span>为ubuntu/trusty64，该<span class="built_in">box</span>由Hashicorp官网提供。此时，vagrant发现<span class="built_in">box</span>的名字的格式为<span class="string">"用户名/box名"</span>,则会使用<span class="string">"https://atlas.hashicorp.com/用户名/box名"</span>来下载该<span class="built_in">box</span>.</span><br><span class="line">对于非官网提供的<span class="built_in">box</span>，可以通过以下命令创建：</span><br><span class="line">vagrant init my-<span class="built_in">box</span> https://boxes.company.com/my.<span class="built_in">box</span>(其中，my-<span class="built_in">box</span>为该<span class="built_in">box</span>的名字，后面的URL为该<span class="built_in">box</span>的下载地址。)</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant halt</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂起虚拟机(非常实用，节省内存)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant suspend</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒虚拟机</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vagrant resume</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看虚拟机状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant status</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant destroy</span><br><span class="line"></span><br><span class="line">注：vagrant destroy只会删除虚拟机本身，也即你在Virtualbox将看不到该虚拟机，但是不会删除该虚拟机所使用的box。</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出本地所有的box</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant box list</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除某个box</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant box remove boxname</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-provision"><a href="#4-provision" class="headerlink" title="4.provision"></a>4.provision</h2><p>Provisioner 是 Vagrant 中的一个概念，表示用户在 Vagrantfile 中所提供的自动或手动执行的虚拟机任务。任务的类型也有很多种，比如执行 Shell 脚本，文件拷贝等等。</p>
<p>vagrant 执行特定任务的通用语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant provision --provision-with &lt;provisioner&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Oracle VM VirtualBox + vagrant</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>shell</tag>
        <tag>vagrant</tag>
        <tag>快速部署</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2020/03/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="2020-03-03-22-17"><a href="#2020-03-03-22-17" class="headerlink" title="2020-03-03 22:17"></a>2020-03-03 22:17</h1><p>我的博客系统上线啦！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
