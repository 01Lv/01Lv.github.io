<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM知识点集合</title>
    <url>/2020/03/21/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="1"><a class="header-anchor" href="#1">¶</a>1</h2>
<p>JVM 内存可简单分为三个区：</p>
<ol>
<li><strong>堆区(heap)</strong>: 用于存放所有对象，是线程共享的</li>
<li><strong>栈区(stack)</strong>: 用于存放基本数据类型的数据和对象的引用，是线程私有的(分为：虚拟机栈和本地方法栈)</li>
<li><strong>方法区(method):</strong> 用于存放类信息，常量，静态变量，编译后的字节码等，是线程共享的(也被称为非堆，即None-Heap)</li>
</ol>
<p><strong>Java 的垃圾回收器(GC) 主要针对堆区</strong></p>
<a id="more"></a>
<h2 id="2"><a class="header-anchor" href="#2">¶</a>2</h2>
<p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="JVM-生命周期"><a class="header-anchor" href="#JVM-生命周期">¶</a>JVM 生命周期</h2>
<h3 id="虚拟机启动"><a class="header-anchor" href="#虚拟机启动">¶</a>虚拟机启动</h3>
<p>Java 虚拟机的启动是通过<strong>引导类加载器</strong>(bootstrap class loader)创建一个初始类(initial class)来完成，这个类是由虚拟机的具体实现指定的</p>
<h3 id="虚拟机的执行"><a class="header-anchor" href="#虚拟机的执行">¶</a>虚拟机的执行</h3>
<ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li>
<li>程序开始执行时他才运行，程序结束时就停止</li>
<li>执行一个所谓的Java程序的时候，真正在执行的是一个叫做Java虚拟机的进程</li>
</ul>
<h3 id="虚拟机退出"><a class="header-anchor" href="#虚拟机退出">¶</a>虚拟机退出</h3>
<p>有如下几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机终止</li>
<li>某线程调用Runtime类 或 System 类的exit方法，或halt方法</li>
</ul>
<h2 id="类加载器及类加载过程"><a class="header-anchor" href="#类加载器及类加载过程">¶</a>类加载器及类加载过程</h2>
<p><img src="https://img-blog.csdnimg.cn/20200321102825441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200208133950667"></p>
<ul>
<li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由 <strong>Execution Engine决定</strong></li>
<li>加载的类信息存放于一块称为 <strong>方法区的内存空间。<strong>除了类的信息外，方法区还会存放运行时</strong>常量池信息</strong>，可能还包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)</li>
</ul>
<h3 id="类加载器ClassLoader角色"><a class="header-anchor" href="#类加载器ClassLoader角色">¶</a>类加载器ClassLoader角色</h3>
<ol>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例</li>
<li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区</li>
<li>在 .class 文件 -&gt; JVM -&gt; 最终成为元数据模板，此过程就要一个 <strong>运输工具(类加载器 Class Loader)</strong> , 扮演一个<strong>快递员</strong>的角色</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020032110285062.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200208135633071"></p>
<h3 id="类加载过程"><a class="header-anchor" href="#类加载过程">¶</a>类加载过程</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321102910207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200208140055491"></p>
<h4 id="加载："><a class="header-anchor" href="#加载：">¶</a>加载：</h4>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的放嗯入口</li>
</ol>
<h4 id="链接："><a class="header-anchor" href="#链接：">¶</a>链接：</h4>
<p><img src="https://img-blog.csdnimg.cn/20200321102926237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200208140713449"></p>
<h4 id="初始化："><a class="header-anchor" href="#初始化：">¶</a>初始化：</h4>
<ul>
<li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程</li>
<li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li>&lt;clinit&gt;() 不同于类的构造器</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;() 方法在多线程下被同步加锁</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321102941718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211212324816"></p>
<h3 id="类加载器的分类"><a class="header-anchor" href="#类加载器的分类">¶</a>类加载器的分类</h3>
<ul>
<li>JVM 支持两种类加载器，分别为 <strong>引导类加载器(Bootstrap ClassLoader)</strong> 和 <strong>自定义类加载器(User-Defined ClassLoader)</strong></li>
<li>从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范没有这么定义，而是 <strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li>
</ul>
<h4 id="关于-Class-Loader"><a class="header-anchor" href="#关于-Class-Loader">¶</a>关于 Class Loader</h4>
<p>ClassLoader 类，它是一个<strong>抽象类</strong>，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器)</p>
<p><img src="https://img-blog.csdnimg.cn/20200321102957103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211215059187"></p>
<p>自定义类加载器源码</p>
<p>Launcher.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandlerFactory;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlContext;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.CodeSource;</span><br><span class="line"><span class="keyword">import</span> java.security.PermissionCollection;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedActionException;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedExceptionAction;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> sun.net.www.ParseUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandlerFactory factory = <span class="keyword">new</span> Launcher.Factory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandler fileHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Launcher.ExtClassLoader var1;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">        String var2 = System.getProperty(<span class="string">"java.security.manager"</span>);</span><br><span class="line">        <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SecurityManager var3 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">""</span>.equals(var2) &amp;&amp; !<span class="string">"default"</span>.equals(var2)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var3 = (SecurityManager)<span class="keyword">this</span>.loader.loadClass(var2).newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException var6) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var7) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassCastException var8) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var3 = <span class="keyword">new</span> SecurityManager();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create SecurityManager: "</span> + var2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.setSecurityManager(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URLClassPath <span class="title">getBootstrapClassPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Launcher.BootClassPathHolder.bcp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URL[] pathToURLs(File[] var0) &#123;</span><br><span class="line">        URL[] var1 = <span class="keyword">new</span> URL[var0.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">            var1[var2] = getFileURL(var0[var2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getClassPath(String var0) &#123;</span><br><span class="line">        File[] var1;</span><br><span class="line">        <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> var2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> var3 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> var4 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> var5;</span><br><span class="line">            <span class="keyword">int</span> var7;</span><br><span class="line">            <span class="keyword">for</span>(var5 = <span class="number">0</span>; (var7 = var0.indexOf(File.pathSeparator, var5)) != -<span class="number">1</span>; var5 = var7 + <span class="number">1</span>) &#123;</span><br><span class="line">                ++var3;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line">            var4 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var5 = <span class="number">0</span>; (var7 = var0.indexOf(File.pathSeparator, var5)) != -<span class="number">1</span>; var5 = var7 + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var7 - var5 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    var1[var2++] = <span class="keyword">new</span> File(var0.substring(var5, var7));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    var1[var2++] = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var5 &lt; var0.length()) &#123;</span><br><span class="line">                var1[var2++] = <span class="keyword">new</span> File(var0.substring(var5));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var1[var2++] = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2 != var3) &#123;</span><br><span class="line">                File[] var6 = <span class="keyword">new</span> File[var2];</span><br><span class="line">                System.arraycopy(var1, <span class="number">0</span>, var6, <span class="number">0</span>, var2);</span><br><span class="line">                var1 = var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> URL <span class="title">getFileURL</span><span class="params">(File var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var0 = var0.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ParseUtil.fileToEncodedURL(var0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">            <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">            <span class="keyword">super</span>(var1, var2, Launcher.factory);</span><br><span class="line">            <span class="keyword">this</span>.ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">            <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">                SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">                <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">                Class var5 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">                <span class="keyword">if</span> (var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.resolveClass(var5);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> var5;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PermissionCollection <span class="title">getPermissions</span><span class="params">(CodeSource var1)</span> </span>&#123;</span><br><span class="line">            PermissionCollection var2 = <span class="keyword">super</span>.getPermissions(var1);</span><br><span class="line">            var2.add(<span class="keyword">new</span> RuntimePermission(<span class="string">"exitVM"</span>));</span><br><span class="line">            <span class="keyword">return</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendToClassPathForInstrumentation</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">super</span>.addURL(Launcher.getFileURL(<span class="keyword">new</span> File(var1)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">            PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">            ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">            AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BootClassPathHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> URLClassPath bcp;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">BootClassPathHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            URL[] var0;</span><br><span class="line">            <span class="keyword">if</span> (Launcher.bootClassPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var0 = (URL[])AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;URL[]&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> URL[] run() &#123;</span><br><span class="line">                        File[] var1 = Launcher.getClassPath(Launcher.bootClassPath);</span><br><span class="line">                        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">                        HashSet var3 = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var2; ++var4) &#123;</span><br><span class="line">                            File var5 = var1[var4];</span><br><span class="line">                            <span class="keyword">if</span> (!var5.isDirectory()) &#123;</span><br><span class="line">                                var5 = var5.getParentFile();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (var5 != <span class="keyword">null</span> &amp;&amp; var3.add(var5)) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(var5);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> Launcher.pathToURLs(var1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var0 = <span class="keyword">new</span> URL[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bcp = <span class="keyword">new</span> URLClassPath(var0, Launcher.factory, (AccessControlContext)<span class="keyword">null</span>);</span><br><span class="line">            bcp.initLookupCache((ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class var0 = Launcher.ExtClassLoader<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                <span class="keyword">synchronized</span>(Launcher.ExtClassLoader<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        instance = createExtClassLoader();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        File[] var1 = Launcher.ExtClassLoader.getExtDirs();</span><br><span class="line">                        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                            MetaIndex.registerDirectory(var1[var3]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException var1) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException)var1.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addExtURL</span><span class="params">(URL var1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.addURL(var1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">            String var0 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">            File[] var1;</span><br><span class="line">            <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">                <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">                var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                    var1[var4] = <span class="keyword">new</span> File(var2.nextToken());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> URL[] getExtURLs(File[] var0) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            Vector var1 = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">                String[] var3 = var0[var2].list();</span><br><span class="line">                <span class="keyword">if</span> (var3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3.length; ++var4) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!var3[var4].equals(<span class="string">"meta-index"</span>)) &#123;</span><br><span class="line">                            File var5 = <span class="keyword">new</span> File(var0[var2], var3[var4]);</span><br><span class="line">                            var1.add(Launcher.getFileURL(var5));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            URL[] var6 = <span class="keyword">new</span> URL[var1.size()];</span><br><span class="line">            var1.copyInto(var6);</span><br><span class="line">            <span class="keyword">return</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">            var1 = System.mapLibraryName(var1);</span><br><span class="line">            URL[] var2 = <span class="keyword">super</span>.getURLs();</span><br><span class="line">            File var3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var2.length; ++var4) &#123;</span><br><span class="line">                URI var5;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var5 = var2[var4].toURI();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (URISyntaxException var9) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                File var6 = Paths.get(var5).toFile().getParentFile();</span><br><span class="line">                <span class="keyword">if</span> (var6 != <span class="keyword">null</span> &amp;&amp; !var6.equals(var3)) &#123;</span><br><span class="line">                    String var7 = VM.getSavedProperty(<span class="string">"os.arch"</span>);</span><br><span class="line">                    File var8;</span><br><span class="line">                    <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        var8 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(var6, var7), var1);</span><br><span class="line">                        <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var8 = <span class="keyword">new</span> File(var6, var1);</span><br><span class="line">                    <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var3 = var6;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">            ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">            AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">            instance = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">URLStreamHandlerFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String PREFIX = <span class="string">"sun.net.www.protocol"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> URLStreamHandler <span class="title">createURLStreamHandler</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">            String var2 = PREFIX + <span class="string">"."</span> + var1 + <span class="string">".Handler"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class var3 = Class.forName(var2);</span><br><span class="line">                <span class="keyword">return</span> (URLStreamHandler)var3.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ReflectiveOperationException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"could not load "</span> + var1 + <span class="string">"system protocol handler"</span>, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.free.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200321103017468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211215932039"></p>
<p>获取上层类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.free.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200321103033480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211220143673"></p>
<p>Java 核心类库都是使用 <strong>引导类加载器进行加载</strong></p>
<p>引导类加载器</p>
<p><img src="https://img-blog.csdnimg.cn/2020032110304999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211220932509"></p>
<p>扩展类加载器</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103104303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211221222697"></p>
<p>应用程序类加载器</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103117180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211221323558"></p>
<h3 id="为什么需要自定义类加载器"><a class="header-anchor" href="#为什么需要自定义类加载器">¶</a>为什么需要自定义类加载器</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321103133478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211221759736"></p>
<h3 id="自定义类加载器的步骤"><a class="header-anchor" href="#自定义类加载器的步骤">¶</a>自定义类加载器的步骤</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321103200884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211222041729"></p>
<h3 id="对类加载器的引用"><a class="header-anchor" href="#对类加载器的引用">¶</a>对类加载器的引用</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321103217829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211225220425"></p>
<h2 id="双亲委派机制"><a class="header-anchor" href="#双亲委派机制">¶</a>双亲委派机制</h2>
<p><img src="https://img-blog.csdnimg.cn/20200321103233525.png" alt="image-20200211222740092"></p>
<h3 id="工作原理"><a class="header-anchor" href="#工作原理">¶</a>工作原理</h3>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是<strong>双亲委派机制</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200321103250438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211223930852"></p>
<h3 id="沙箱安全机制"><a class="header-anchor" href="#沙箱安全机制">¶</a>沙箱安全机制</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321103309486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211224941769"></p>
<h2 id="类的主动使用和被动使用"><a class="header-anchor" href="#类的主动使用和被动使用">¶</a>类的主动使用和被动使用</h2>
<p><img src="https://img-blog.csdnimg.cn/20200321103324898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211225435415"></p>
<h2 id="运行时数据区内部结构"><a class="header-anchor" href="#运行时数据区内部结构">¶</a>运行时数据区内部结构</h2>
<p><img src="https://img-blog.csdnimg.cn/20200321103340570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211225957157"></p>
<p>阿里jvm示意图</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103354710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211230736650"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103415806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211230839506"></p>
<p>每个虚拟机有且只对应一个 Runtime实例</p>
<h3 id="线程"><a class="header-anchor" href="#线程">¶</a>线程</h3>
<ul>
<li>线程是一个程序里的运行单元。JVM 允许一个应用由多个线程并行的执行</li>
<li>在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li>
</ul>
<h4 id="JVM-系统线程"><a class="header-anchor" href="#JVM-系统线程">¶</a>JVM 系统线程</h4>
<p><img src="https://img-blog.csdnimg.cn/20200321103435154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212101134300"></p>
<h3 id="程序计数器"><a class="header-anchor" href="#程序计数器">¶</a>程序计数器</h3>
<p>JVM 中的 PC寄存器是对物理PC 寄存器的一种抽象模拟</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103451892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212101756499"></p>
<h3 id="虚拟机栈"><a class="header-anchor" href="#虚拟机栈">¶</a>虚拟机栈</h3>
<p>由于跨平台的设计，Java 的指令都是根据 <strong>栈</strong> 来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的</p>
<p><em>优点：跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</em></p>
<h4 id="内存中的栈与堆"><a class="header-anchor" href="#内存中的栈与堆">¶</a>内存中的栈与堆</h4>
<p>栈是 <strong>运行时</strong> 的单位，而堆是 <strong>存储</strong> 的单位</p>
<p>栈解决程序的运行问题，即 <em>程序如何执行，或者说如何处理数据</em>。堆解决的是数据存储的问题，即 <em>数据怎么放，放在哪儿</em>。</p>
<h4 id="基本内容"><a class="header-anchor" href="#基本内容">¶</a>基本内容</h4>
<p><img src="https://img-blog.csdnimg.cn/20200321103508455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212110233907"></p>
<h4 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h4>
<p><img src="https://img-blog.csdnimg.cn/20200321103526751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212111524501"></p>
<h4 id="栈可能出现的异常"><a class="header-anchor" href="#栈可能出现的异常">¶</a>栈可能出现的异常</h4>
<p><img src="https://img-blog.csdnimg.cn/20200321103542451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212111911949"></p>
<h4 id="设置栈内存大小"><a class="header-anchor" href="#设置栈内存大小">¶</a>设置栈内存大小</h4>
<p>我们可以使用参数 -Xss 选项来设置线程的最大占空间，栈的大小直接决定了<strong>函数调用的最大可达深度</strong></p>
<h4 id="栈的存储单位"><a class="header-anchor" href="#栈的存储单位">¶</a>栈的存储单位</h4>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以 **栈帧(Stack Frame) **的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h4 id="栈运行原理"><a class="header-anchor" href="#栈运行原理">¶</a>栈运行原理</h4>
<p><img src="https://img-blog.csdnimg.cn/2020032110361174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212125513737"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103632334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212125536047"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103648481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image"></p>
<h4 id="栈帧的内部结构"><a class="header-anchor" href="#栈帧的内部结构">¶</a>栈帧的内部结构</h4>
<p><img src="https://img-blog.csdnimg.cn/20200321103703486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212130707269"></p>
<p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表</strong></li>
<li><strong>操作数栈</strong></li>
<li>动态链接(指向运行时常量池的方法引用)</li>
<li>方法返回地址 (方法正常退出或者异常退出的定义)</li>
<li>一些附加j信息</li>
</ul>
<h5 id="局部变量表-重要"><a class="header-anchor" href="#局部变量表-重要">¶</a>局部变量表(重要)</h5>
<ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>定义一个数字数组，主要用于存储 <em>方法参数</em> 和 <em>定义在方法体内的局部变量</em>，这些数据类型包括各类<strong>基本数据类型</strong>，<strong>对象引用</strong>，以及<strong>returnAddress类型</strong></li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此 <em>不存在数据安全问题</em></li>
<li>局部变量表所需的容量大小是在 <em>编译期</em> 定下来的,并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表大小的</li>
</ul>
<h6 id="变量槽slot"><a class="header-anchor" href="#变量槽slot">¶</a>变量槽slot</h6>
<ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li>
<li>局部变量表，<em>最基本的存储单元是 <strong>slot(变量槽)</strong></em></li>
<li>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型，returnAddress类型的变量</li>
<li>在局部变量表里，<em>32位以内的类型只占用一个 slot(包括returnAddress类型),64位的类型(long 和 double) 占用两个 slot</em>
<ul>
<li>byte，short，char 在存储前被转换为 int；boolean 也被转换为 int</li>
<li>long 和 double 则占据两个 slot</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321103721620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212135535007"></p>
<p><em>实例方法对应的栈帧的数组种的第一个元素即为 this</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">long</span> arg2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myPrint = <span class="number">1</span>;</span><br><span class="line">    System.out.println(myPrint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    descriptor: (IJ)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore        <span class="number">4</span></span><br><span class="line">         3: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         <span class="number">6</span>: iload         <span class="number">4</span></span><br><span class="line">         8: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">11</span></span><br><span class="line">      LocalVariableTable:(重点关注这里，发现数组第一个元素即为<span class="keyword">this</span>,其他才是 方法参数 和 局部变量 )</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/free/demo/stack/StackErrorDemo;</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">1</span>  arg1   I</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">2</span>  arg2   J</span><br><span class="line">            <span class="number">3</span>       <span class="number">9</span>     <span class="number">4</span> myPrint   I</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      arg1</span><br><span class="line">      arg2</span><br></pre></td></tr></table></figure>
<p><em>静态方法种没有 this 变量</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: iconst_1</span><br><span class="line">        <span class="number">1</span>: istore_0</span><br><span class="line">        <span class="number">2</span>: iconst_2</span><br><span class="line">        <span class="number">3</span>: istore_1</span><br><span class="line">        4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        7: ldc           #4                  // String test2</span><br><span class="line">        9: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">19</span>: <span class="number">2</span></span><br><span class="line">       line <span class="number">20</span>: <span class="number">4</span></span><br><span class="line">       line <span class="number">21</span>: <span class="number">12</span></span><br><span class="line">     LocalVariableTable:(重点故关注这里，发现只有局部变量 i1 和 i2)</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">2</span>      <span class="number">11</span>     <span class="number">0</span>    i1   I</span><br><span class="line">           <span class="number">4</span>       <span class="number">9</span>     <span class="number">1</span>    i2   I</span><br></pre></td></tr></table></figure>
<h6 id="slot-的重复利用"><a class="header-anchor" href="#slot-的重复利用">¶</a>slot 的重复利用</h6>
<p><em>栈帧中的局部变量表中的槽位是可以重用的</em>,</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103739741.png" alt="image-20200212142754211"></p>
<h5 id="操作数栈-重要"><a class="header-anchor" href="#操作数栈-重要">¶</a>操作数栈(重要)</h5>
<ul>
<li>每个独立的栈帧中除了包含局部变量表以外，还包含一个 <em>后进先出</em> 的<strong>操作数栈</strong>，也可称之为<strong>表达式栈</strong></li>
<li><em>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)</em>
<ul>
<li>某些字节码指令将值压入操作操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行赋值，交换，求和等操作</li>
</ul>
</li>
<li><em>Java 虚拟机的解释引擎是基于 <strong>栈</strong> 的执行引擎，其中栈指的是<strong>操作数栈</strong></em></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321103754837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212204608787"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103808457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212205037031">·</p>
<h5 id="动态链接"><a class="header-anchor" href="#动态链接">¶</a>动态链接</h5>
<p><img src="https://img-blog.csdnimg.cn/20200321103824276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212211245377"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103838793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212212148682"></p>
<h5 id="方法返回地址"><a class="header-anchor" href="#方法返回地址">¶</a>方法返回地址</h5>
<ul>
<li>存放调用该方法的pc寄存器的值</li>
<li>一个方法的结束，有两种方式
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过 <em>异常表</em> 来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321103855537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216103304370"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103909269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216103611394"></p>
<p>实例：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103933542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216104156334"></p>
<h4 id="栈顶缓存技术"><a class="header-anchor" href="#栈顶缓存技术">¶</a>栈顶缓存技术</h4>
<p><img src="https://img-blog.csdnimg.cn/20200321103951992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212210806803"></p>
<h4 id="方法的调用"><a class="header-anchor" href="#方法的调用">¶</a>方法的调用</h4>
<p>在 JVM 中，将 <em>符号引用</em> 转换为调用方法的 <em>直接引用</em> 与方法的绑定机制有关</p>
<ul>
<li>
<p><strong>静态链接</strong></p>
<p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接</p>
</li>
<li>
<p><strong>动态链接</strong></p>
<p>如果 **被调用的方法在编译期无法确定下来，**也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</li>
</ul>
<p><em>虚函数</em> 是不能再 编译期 确定该调用哪个版本</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104055301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212214040762"></p>
<p>虚拟机提供了以下几条方法调用指令</p>
<ul>
<li>普通调用指令</li>
</ul>
<ol>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用&lt;init&gt;方法，私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
<ul>
<li>动态调用指令</li>
</ul>
<ol start="5">
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200321104108675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200213093547736"></p>
<h3 id="堆区"><a class="header-anchor" href="#堆区">¶</a>堆区</h3>
<p>转自：</p>
<p><a href="https://mp.weixin.qq.com/s/7bGtO9NfakQNHHcT26Ia7Q" target="_blank" rel="noopener">看懂这6张图，理解JVM内存布局就没问题了！</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104129182.png" alt="image-20200217204943499"></p>
<p>堆时 OOM 故障最主要的区域，它是内存中区域最大的一块区域，<strong>被所有线程共享</strong>。存储着几乎所有的实例对象。<strong>所有的对象实例以及数组都要在堆上分配。<strong>但是随着JIT编译器的发展与</strong>逃逸分析技术</strong>逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，<strong>所有的对象都分配在堆上也渐渐变得不是那么“绝对”了</strong>。</p>
<p>Java 堆是垃圾收集器管理的主要区域。从内存回收的角度看，由于现在收集器基本都采用 <em>分代收集算法</em>，所以 Java堆还可以细分为：<strong>新生代和老年代</strong>。</p>
<p>新生代</p>
<ul>
<li><strong>Eden空间</strong></li>
<li><strong>From Survivor空间</strong></li>
<li><strong>To Survivor空间</strong></li>
</ul>
<p>从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。</p>
<h4 id="堆区调整"><a class="header-anchor" href="#堆区调整">¶</a>堆区调整</h4>
<p>根据Java虚拟机规范的规定，<strong>Java堆可以处于物理上不连续的内存空间中</strong>，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以在运行时动态地调整</p>
<p>如何调整呢？</p>
<p>通过设置如下参数，可以设定堆区的初始值和最大值，比如 <code>-Xms256M -Xmx 1024M</code>，其中 <code>-X</code>这个字母代表它是JVM运行时参数，<code>ms</code>是<code>memory start</code>的简称，中文意思就是内存初始值，<code>mx</code> 是 <code>memory max</code>的简称，意思就是最大内存。</p>
<p><strong>值得注意的是，在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，会形成不必要的系统压力 所以在线上生产环境中 JVM的<code>Xms</code>和 <code>Xmx</code>会设置成同样大小，避免在GC 后调整堆大小时带来的额外压力。</strong></p>
<h4 id="堆的默认空间分配"><a class="header-anchor" href="#堆的默认空间分配">¶</a>堆的默认空间分配</h4>
<p>堆空间内存分配的大体情况</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3E2czF4Mmh3Mi5ia3QuY2xvdWRkbi5jb20vNzcucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>执行如下命令，就可以看到当前 JDK 版本所有默认的 JVM 参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version</span><br></pre></td></tr></table></figure>
<p>对应输出应该有几百行，主要看两个关键参数</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;java -XX:+PrintFlagsFinal -version</span><br><span class="line">[Global flags]</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">    uintx InitialSurvivorRatio                      = 8</span><br><span class="line">    uintx NewRatio                                  = 2</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">java version <span class="string">"1.8.0_131"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure>
<p>参数解释</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-XX:InitialSurvivorRatio</td>
<td style="text-align:left">新生代Eden/Survivor空间的初始比例</td>
</tr>
<tr>
<td style="text-align:left">-XX:NewRatio</td>
<td style="text-align:left">Old区/Young区的内存比例</td>
</tr>
</tbody>
</table>
<p>因为新生代是由Eden + S0 + S1组成的，所以按照上述默认比例，如果eden区内存大小是40M，那么两个survivor区就是5M，整个young区就是50M，然后可以算出Old区内存大小是100M，堆区总大小就是150M。</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError</code> 可以让JVM在遇到OOM异常时，输出堆内信息</p>
<h4 id="创建一个新对象，内存分配流程"><a class="header-anchor" href="#创建一个新对象，内存分配流程">¶</a>创建一个新对象，内存分配流程</h4>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3E2czF4Mmh3Mi5ia3QuY2xvdWRkbi5jb20vNzgucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>绝大部分对象在 Eden 区生成，当 Eden 区装填满的时候，会触发 <strong>Young Garbage Collection</strong>，即 <code>YGC</code>。垃圾回收的时候，在 Eden 区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到Survivor区。Survivor区分为so和s1两块内存空间。每次<code>YGC</code>的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果<code>YGC</code>要移送的对象大于Survivor区容量的上限，则直接移交给老年代。一个对象也不可能永远呆在新生代，就像人到了18岁就会成年一样，在JVM中<code>－XX:MaxTenuringThreshold</code>参数就是来配置一个对象从新生代晋升到老年代的阈值。默认值是<strong>15</strong>， 可以在Survivor区交换14次之后，晋升至老年代。</p>
<h3 id="元空间"><a class="header-anchor" href="#元空间">¶</a>元空间</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321104340358.png" alt="image-20200217211401315"></p>
<p>在 HotSpot JVM 中，**永久代（ ≈ 方法区）*<em>中用于*<em>存放类和方法的元数据以及常量池</em></em>,比如 <em>Class</em> 和 <em>Method</em>。每当一个类被初次加载的时候，它的元数据都会放到永久代。</p>
<p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code>，为此我们不得不对虚拟机做调优。</p>
<p>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</p>
<ol>
<li>由于 PermGen 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li>
<li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li>
</ol>
<p>根据上面的各种原因，PermGen 最终被移除，<strong>方法区移至 Metaspace，字符串常量池移至堆区</strong>。</p>
<p>准确来说，Perm 区中的<strong>字符串常量池被移到了堆内存</strong>中是在Java7 之后，Java 8 时，PermGen 被元空间代替，<strong>其他内容比如类元信息、字段、静态属性、方法、常量等都移动到元空间区</strong>。比如<code>java/lang/Object</code>类元信息、静态属性<code>System.out</code>、整形常量 <code>100000</code>等。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。（和后面提到的直接内存一样，都是使用本地内存）</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
<p><strong>对应的JVM调参：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-XX:MetaspaceSize</td>
<td style="text-align:left">分配给Metaspace（以字节计）的初始大小</td>
</tr>
<tr>
<td style="text-align:left">-XX:MaxMetaspaceSize</td>
<td style="text-align:left">分配给Metaspace 的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td>
</tr>
<tr>
<td style="text-align:left">-XX:MinMetaspaceFreeRatio</td>
<td style="text-align:left">在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</td>
</tr>
<tr>
<td style="text-align:left">-XX:MaxMetaspaceFreeRatio</td>
<td style="text-align:left">在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</td>
</tr>
</tbody>
</table>
<h3 id="本地方法接口"><a class="header-anchor" href="#本地方法接口">¶</a>本地方法接口</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321104356879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216110618851"></p>
<h4 id="什么是本地方法"><a class="header-anchor" href="#什么是本地方法">¶</a>什么是本地方法</h4>
<p>*一个 Native Method就是一个 Java 调用非 Java 代码的接口。*一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。</p>
<p><img src="https://img-blog.csdnimg.cn/2020032110442188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216110925645"></p>
<p>例如 Object.java 中的 <em>getClass()</em> 方法就是一个 native 方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104439634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216111105667"></p>
<h4 id="native-与-abstract-的区别"><a class="header-anchor" href="#native-与-abstract-的区别">¶</a>native 与 abstract 的区别</h4>
<p>native 是有方法体的，只不过是用 C 来实现</p>
<p>而 abstract 是没有方法体的，具体由子类去实现。</p>
<p>native 和 abstract 两者不能共用。</p>
<h3 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h3>
<p><em>变量的分类：</em></p>
<p>1.基本数据类型 2.引用数据类型</p>
<p><em>按照在类中声明的位置分类：</em></p>
<ol>
<li>
<p>成员变量：在使用前，都经历过默认初始化赋值</p>
<ol>
<li><strong>类变量</strong>：linking的prepare阶段，给类变量默认赋值 ----》 initial:给类变量显示赋值</li>
<li>**实例变量：**随着对象创建，会在堆空间分配实例变量空间，并进行默认赋值</li>
</ol>
</li>
<li>
<p>局部变量：在使用前，必须要进行显式赋值！否则，编译不通过</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200321104453426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212194503832"></p>
<h3 id="方法调用：关于-invokedynamic-指令"><a class="header-anchor" href="#方法调用：关于-invokedynamic-指令">¶</a>方法调用：关于 invokedynamic 指令</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321104506523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216094404600"></p>
<h3 id="方法的调用：方法重写的本质"><a class="header-anchor" href="#方法的调用：方法重写的本质">¶</a>方法的调用：方法重写的本质</h3>
<p><img src="https://img-blog.csdnimg.cn/20200321104518699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216094821151"></p>
<h3 id="方法的调用：虚方法表"><a class="header-anchor" href="#方法的调用：虚方法表">¶</a>方法的调用：虚方法表</h3>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<em>为了提高性能</em>，JVM 采用在类的方法区建立一个虚方法表(virtual method table)(<strong>非虚方法不会出现在表中</strong>)来实现。使用索引表来代替查找</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</li>
</ul>
<h2 id="垃圾回收器"><a class="header-anchor" href="#垃圾回收器">¶</a>垃圾回收器</h2>
<h3 id="对象引用分类"><a class="header-anchor" href="#对象引用分类">¶</a>对象引用分类</h3>
<p>参考：</p>
<p><a href="https://juejin.im/post/5b4dea755188251ac1098e98" target="_blank" rel="noopener">JVM系列(五) - JVM垃圾回收算法</a></p>
<p><a href="https://juejin.im/post/5b651200f265da0fa00a38d7#heading-3" target="_blank" rel="noopener">JVM系列(六) - JVM垃圾回收器</a></p>
<blockquote>
<h4 id="强引用"><a class="header-anchor" href="#强引用">¶</a>强引用</h4>
</blockquote>
<p>在代码中普遍存在的，类似<code>Object obj = new Object()</code>这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</p>
<blockquote>
<h4 id="软引用-SoftReference"><a class="header-anchor" href="#软引用-SoftReference">¶</a>软引用(SoftReference)</h4>
</blockquote>
<p><strong>有用但并非必需</strong> 的对象，可用<code>SoftReference</code>类来实现软引用。在系统将要发生<strong>内存溢出异常</strong>之前，将会把这些对象列进回收范围之中进行<strong>二次回收</strong>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<blockquote>
<h4 id="弱引用-WeakReference"><a class="header-anchor" href="#弱引用-WeakReference">¶</a>弱引用(WeakReference)</h4>
</blockquote>
<p><strong>非必需</strong> 的对象，但它的<strong>强度</strong>比软引用更弱，被弱引用关联的对象<strong>只能</strong>生存到下一次垃圾收集发生之前，<code>JDK</code>提供了<code>WeakReference</code>类来实现弱引用。无论当前内存是否足够，用软引用相关联的对象都会被回收掉。</p>
<blockquote>
<h4 id="虚引用-PhatomReference"><a class="header-anchor" href="#虚引用-PhatomReference">¶</a>虚引用(PhatomReference)</h4>
</blockquote>
<p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系，<code>JDK</code>提供了<code>PhantomReference</code>类来实现虚引用。为一个对象设置虚引用的唯一目的是：能在这个对象在<strong>垃圾回收器</strong>回收时收到一个<strong>系统通知</strong></p>
<h3 id="finalize-二次标记"><a class="header-anchor" href="#finalize-二次标记">¶</a>finalize() 二次标记</h3>
<p>一个对象是否应该在垃圾回收器在<code>GC</code>时回收，至少要经历<strong>两次标记过程</strong>。</p>
<p>第一次标记过程，通过<strong>可达性分析算法</strong>分析对象是否与<code>GC Roots</code>可达。经过第一次标记，并且被筛选为<strong>不可达</strong>的对象会进行第二次标记。</p>
<p>第二次标记过程，判断不可达对象是否有必要执行<code>finalize</code>方法。执行条件是当前对象的<code>finalize</code>方法被重写，并且还未被系统调用过。如果允许执行那么这个对象将会被放到一个叫<code>F-Query</code>的队列中，等待被执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：由于finalize由一个优先级比较低的Finalizer线程运行，所以该对象的的finalize方法不一定被执行，即使被执行了，也不保证finalize方法一定会执行完。如果对象第二次小规模标记，即finalize方法中拯救自己，只需要重新和引用链上的任一对象建立关联即可。</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法">¶</a>垃圾回收算法</h3>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/chenpt/p/9799095.html" target="_blank" rel="noopener">Jvm垃圾回收器（算法篇）</a></p>
<blockquote>
<h4 id="标记-清除算法"><a class="header-anchor" href="#标记-清除算法">¶</a>标记-清除算法</h4>
</blockquote>
<ul>
<li>标记</li>
</ul>
<p>标记出所有需要回收的对象</p>
<p>**一次标记：**在经过 <em>可达性分析算法</em> 后，对象没有与 GC Root 相关的引用链，那么则被第一次标记，并且进行一次筛选：当对象有必要执行 finalize() 方法时，则将该对象放入 F-Queue 队列中</p>
<p>**二次标记：**对 F-Queue 队列中的对象进行二次标记。在执行 finalize() 方法时，如果对象重新与 GC Root 引用链上的任意对象建立了关联，则将其移除 “即将回收” 集合。否则即将被回收</p>
<p>对被第一次标记且被第二次标记的，就可以判定位可回收对象了。</p>
<ul>
<li>清除</li>
</ul>
<p>两次标记后，还在 “即将回收” 集合的对象进行回收</p>
<p>执行过程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104534826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>**优点：**最基础的可达性算法，后续的收集算法都是基于这种思想实现的</p>
<p>**缺点：**标记和清除效率不高，产生大量不连续的内存碎片，导致创建大对象找不到连续的空间，不得不提前触发另一次的垃圾回收</p>
<blockquote>
<h3 id="复制算法"><a class="header-anchor" href="#复制算法">¶</a>复制算法</h3>
</blockquote>
<p>将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活的对象复制到另外一块内存上，然后再把已使用过的内存空间一次清理掉</p>
<p>复制算法过程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020032110454857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>**优点：**实现简单，效率高。解决了标记-清除算法导致的内存碎片问题</p>
<p>**缺点：**代价大，将内存缩小了一半。效率随对象的存活率升高而降低。</p>
<p>现在的商业虚拟机都采用这种算法（需要改良1:1的缺点）来回收新生代。</p>
<ul>
<li>改良算法</li>
</ul>
<p><strong>1.弱代理论</strong></p>
<p>分代垃圾收集基于弱代理论。具体描述如下：</p>
<ul>
<li>大多说分配了内存的对象并不会存活太长时间，在处于年轻时代就会死掉。</li>
<li>很少有对象会从老年代变成年轻代。</li>
</ul>
<p>其中IBM研究表明：新生代中98%的对象都是&quot;朝生夕死&quot;； 所以并不需要按1:1比例来划分内存（解决了缺点1）；</p>
<p><strong>2.Hotspot虚拟机新生代内存布局及算法</strong></p>
<p>新生代内存分配一块较大的Eden空间和两块较小的Survivor空间</p>
<p>每次使用Eden和其中一块Survivor空间</p>
<p>回收时将Eden和Survivor空间中存活的对象一次性复制到另一块Survivor空间上</p>
<p>最后清理掉Eden和使用过的Survivor空间。</p>
<p>Hotspot虚拟机默认Eden和Survivor的大小比例是8:1。</p>
<p><strong>分配担保</strong></p>
<p>如果另一块 Survivor 空间没有足够内存来存放上一次新生代收集下来的存活对象，那么这些对象则直接通过担保机制进入老年代。</p>
<blockquote>
<h3 id="标记-整理算法"><a class="header-anchor" href="#标记-整理算法">¶</a>标记-整理算法</h3>
</blockquote>
<p>标记-整理算法是根据老年代的特点应运而生</p>
<ul>
<li>标记</li>
</ul>
<p>标记过程和标记-清理算法一致（也是基于可达性分析算法）。</p>
<ul>
<li>整理</li>
</ul>
<p>和标记-清理不同的是，该算法不是针对可回收对象进行清理，而是根据存活对象进行整理。让存活对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p>标记-整理算法示意图</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104615802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>**优点：**不会像复制算法那样随着存活对象的升高而降低效率，不像标记-清除算法那样产生不连续的内存碎片</p>
<p>**缺点：**效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率更低。</p>
<blockquote>
<h3 id="分代收集算法"><a class="header-anchor" href="#分代收集算法">¶</a>分代收集算法</h3>
</blockquote>
<p>当前商业虚拟机的垃圾收集都是采用“ 分代收集 ”算法。</p>
<p>根据对象存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代。JVM根据各个年代的特点采用不同的收集算法。</p>
<p>新生代中，每次进行垃圾回收都会发现大量对象死去，只有少量存活，因此比较适合复制算法。只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中，因为对象存活率较高，没有额外的空间进行分配担保，所以适合标记-清理、标记-整理算法来进行回收。</p>
<h3 id="七种垃圾回收器"><a class="header-anchor" href="#七种垃圾回收器">¶</a>七种垃圾回收器</h3>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/chenpt/p/9803298.html" target="_blank" rel="noopener">JVM垃圾回收器</a></p>
<p>在 <code>JVM</code> 中，具体实现有</p>
<ul>
<li><code>Serial</code>,</li>
<li><code>ParNew</code> ，</li>
<li><code>Pallel Scavenge</code> ,</li>
<li><code>CMS</code> ,</li>
<li><code>Serial Old(MSC)</code> ，</li>
<li><code>Parallel Old</code> ,</li>
<li><code>G1</code> 等。</li>
</ul>
<p>在下图中，你可以看到 <strong>不同垃圾回收器</strong> 适合于 <strong>不同的内存区域</strong>，如果两个垃圾回收器之间 <strong>存在连线</strong>，那么表示两者可以 <strong>配合使用</strong>。</p>
<p>如果当 <strong>垃圾回收器</strong> 进行垃圾清理时，必须 <strong>暂停</strong> 其他所有的 <strong>工作线程</strong>，直到它完全收集结束。我们称这种需要暂停工作线程才能进行清理的策略为 <em>Stop-the-World</em>。</p>
<p>以上回收器中， <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Serial Old</code>、<code>Parallel Old</code> 均采用的是 <code>Stop-the-World</code> 的策略。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3E2czF4Mmh3Mi5ia3QuY2xvdWRkbi5jb20vODkucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>图中有 <code>7</code> 种不同的 <strong>垃圾回收器</strong>，它们分别用于不同分代的垃圾回收。</p>
<ul>
<li>**新生代回收器：**Serial，ParNew，Parallel Scavenge</li>
<li>**老年代回收器：**Serial Old，Parallel Old，CMS</li>
<li>**整堆回收器：**G1</li>
</ul>
<p>两个 <strong>垃圾回收器</strong> 之间有连线表示它们可以 <strong>搭配使用</strong>，可选的搭配方案如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">新生代</th>
<th style="text-align:left">老年代</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serial</td>
<td style="text-align:left">Serial Old</td>
</tr>
<tr>
<td style="text-align:left">Serial</td>
<td style="text-align:left">CMS</td>
</tr>
<tr>
<td style="text-align:left">ParNew</td>
<td style="text-align:left">Serial Old</td>
</tr>
<tr>
<td style="text-align:left">ParNew</td>
<td style="text-align:left">CMS</td>
</tr>
<tr>
<td style="text-align:left">Parallel Scavenge</td>
<td style="text-align:left">Serial Old</td>
</tr>
<tr>
<td style="text-align:left">Parallel Scavenge</td>
<td style="text-align:left">Parallel Old</td>
</tr>
<tr>
<td style="text-align:left">G1</td>
<td style="text-align:left">G1</td>
</tr>
</tbody>
</table>
<blockquote>
<h4 id="单线程垃圾回收器"><a class="header-anchor" href="#单线程垃圾回收器">¶</a>单线程垃圾回收器</h4>
</blockquote>
<ul>
<li>
<h4 id="Serial（-XX-UseSerialGC）"><a class="header-anchor" href="#Serial（-XX-UseSerialGC）">¶</a>Serial（-XX:+UseSerialGC）</h4>
</li>
</ul>
<p>Serial收集器是最基本的、发展历史最悠久的收集器。</p>
<p>**特点：**单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。</p>
<p><strong>应用场景</strong>：适用于Client模式下的虚拟机。</p>
<p><strong>Serial / Serial Old收集器运行示意图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104657654.png" alt="img"></p>
<ul>
<li>
<h4 id="Serial-Old（-XX-UseSerialGC）"><a class="header-anchor" href="#Serial-Old（-XX-UseSerialGC）">¶</a>Serial Old（-XX:+UseSerialGC）</h4>
</li>
</ul>
<p>Serial Old是Serial收集器的老年代版本。</p>
<p><strong>特点</strong>：同样是单线程收集器，采用标记-整理算法。</p>
<p><strong>应用场景</strong>：主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。</p>
<p>Server模式下主要的两大用途（在后续中详细讲解···）：</p>
<ol>
<li>在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。</li>
</ol>
<p>Serial / Serial Old收集器工作过程图（Serial收集器图示相同）：</p>
<p><img src="D:%5Ctypora%5Cnotes%5Casset%5C91.png" alt="img"></p>
<blockquote>
<h4 id="多线程垃圾回收器-吞吐量优先"><a class="header-anchor" href="#多线程垃圾回收器-吞吐量优先">¶</a>多线程垃圾回收器(吞吐量优先)</h4>
</blockquote>
<ul>
<li>
<h4 id="ParNew（-XX-UseParNewGC）"><a class="header-anchor" href="#ParNew（-XX-UseParNewGC）">¶</a>ParNew（-XX:+UseParNewGC）</h4>
</li>
</ul>
<p>ParNew收集器其实就是Serial收集器的多线程版本。</p>
<p>除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<p>和Serial收集器一样存在Stop The World问题</p>
<p><strong>应用场景</strong>：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。</p>
<p><strong>ParNew/Serial Old组合收集器运行示意图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104725361.png" alt="img"></p>
<ul>
<li>
<h4 id="Parallel-Scavenge（-XX-UseParallelGC）"><a class="header-anchor" href="#Parallel-Scavenge（-XX-UseParallelGC）">¶</a>Parallel Scavenge（-XX:+UseParallelGC）</h4>
</li>
</ul>
<p>与吞吐量关系密切，故也称为吞吐量优先收集器。</p>
<p><strong>特点</strong>：属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ol>
<li>
<p>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</p>
</li>
<li>
<p>XX:GCRatio 直接设置吞吐量的大小。</p>
</li>
</ol>
<ul>
<li>
<h4 id="Parallel-Old（-XX-UseParallelOldGC）"><a class="header-anchor" href="#Parallel-Old（-XX-UseParallelOldGC）">¶</a>Parallel Old（-XX:+UseParallelOldGC）</h4>
</li>
</ul>
<p>是Parallel Scavenge收集器的老年代版本。</p>
<p><strong>特点</strong>：多线程，采用标记-整理算法。</p>
<p><strong>应用场景</strong>：注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。</p>
<p><strong>Parallel Scavenge/Parallel Old收集器工作过程图：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104737684.png" alt="img"></p>
<blockquote>
<h3 id="其他的回收器（停顿时间优先）"><a class="header-anchor" href="#其他的回收器（停顿时间优先）">¶</a>其他的回收器（停顿时间优先）</h3>
</blockquote>
<ul>
<li>
<h4 id="CMS（-XX-UseConcMarkSweepGC）"><a class="header-anchor" href="#CMS（-XX-UseConcMarkSweepGC）">¶</a>CMS（-XX:+UseConcMarkSweepGC）</h4>
</li>
</ul>
<p>一种以获取最短回收停顿时间为目标的收集器。</p>
<p><strong>特点</strong>：基于标记-清除算法实现。并发收集、低停顿。</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务。</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。</p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。</p>
<p><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收。</p>
<p>CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS收集器的工作过程图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104748776.png" alt="img"></p>
<p>CMS收集器的缺点：</p>
<ul>
<li>
<p>对CPU资源非常敏感。</p>
</li>
<li>
<p>无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。</p>
</li>
<li>
<p>因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。</p>
</li>
<li>
<h4 id="G1收集器"><a class="header-anchor" href="#G1收集器">¶</a>G1收集器</h4>
</li>
</ul>
<p>一款面向服务端应用的垃圾收集器。</p>
<p><strong>特点如下：</strong></p>
<p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</p>
<p>分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p>
<p>空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。</p>
<p>可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<p>区域化内存划片 Region，整体编为了一些不连续的内存区域，避免了全内存区的GC操作<br>
核心思想是将整个堆内存区域分成大小相同的子区域(Region), 在 JVM 启动时会自动设置这些子区域的大小。<br>
在堆的使用上，G1 并不要求对象的存储一定是物理上连续的只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数 -XX:G1HeapRegionSize=n 可指定分区大小(1MB~32MB),默认将整堆划分为2048个分区<br>
大小范围在 1MB~32MB，最多能设置 2048 个区域，也即能够支持的最大内存为：32MB * 2048 = 65536MB = 64G内存</p>
<p>针对 Eden 区进行收集，Eden 区耗尽后会被触发，主要是小区域收集 + 形成连续的内存块，避免内存碎片</p>
<ul>
<li>Eden 区的数据移动到 Survivor 区，假如出现 Survivor 区空间不够，Eden 区数据会晋升到 Old 区</li>
<li>Survivor 区的数据移动到新的 Survivor 区，数据晋升到 Old 区</li>
<li>最后 Eden 区收拾干净，GC 结束，用户的应用程序继续执行</li>
</ul>
<p><strong>G1为什么能建立可预测的停顿时间模型？</strong></p>
<p>因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这样就保证了在有限的时间内可以获取尽可能高的收集效率。</p>
<p><strong>G1与其他收集器的区别</strong>：</p>
<p>其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。</p>
<p><strong>G1收集器存在的问题：</strong></p>
<p>Region不可能是孤立的，分配在Region中的对象可以与Java堆中的任意对象发生引用关系。在采用可达性分析算法来判断对象是否存活时，得扫描整个Java堆才能保证准确性。其他收集器也存在这种问题（G1更加突出而已）。会导致Minor GC效率下降。</p>
<p><strong>G1收集器是如何解决上述问题的？</strong></p>
<p>采用Remembered Set来避免整堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于多个Region中（即检查老年代中是否引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。</p>
<p><strong>如果不计算维护 Remembered Set 的操作，G1收集器大致可分为如下步骤：</strong></p>
<p><strong>初始标记</strong>：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。）</p>
<p><strong>并发标记</strong>：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行）</p>
<p><strong>最终标记</strong>：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set Logs里面，把Remembered Set Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。）</p>
<p><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行）</p>
<p><strong>G1收集器运行示意图：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104802941.png" alt="img"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2020/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319214514210" target="_blank" rel="noopener">单例</a></p>
<p><a href="https://blog.csdn.net/itachi85/article/details/50510124" target="_blank" rel="noopener">设计模式（二）单例模式的七种写法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33102022" target="_blank" rel="noopener">漫画：什么是单例模式？(推荐)</a></p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
</blockquote>
<p>单例模式( Singleton ) 的目的是为了保证在一个进程中，某个类有且仅有一个实例。属于 <em><strong>创建型模式</strong></em></p>
<p>因为这个类只有一个实例，因此，自然不能让调用方法 <code>new Xyz()</code> 来创建实例了。所以单例的构造方法必须是 <code>private</code> ，这样就防止了调用自己创建实例，但是类的内部，是可以用一个静态字段来引用唯一创建的实例的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>那么外部调用方如何获得这个唯一的实例呢？</p>
<p>那么问题来了，外部调用方如何获得这个唯一实例？</p>
<p>答案是提供一个静态方法，直接返回实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接把<code>static</code>变量暴露给外部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，单例模式的实现方式很简单：</p>
<ol>
<li>只有<code>private</code>构造方法，确保外部无法实例化；</li>
<li>通过<code>private static</code>变量持有唯一实例，保证全局唯一性；</li>
<li>通过<code>public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Chinese objref =<span class="keyword">new</span> Chinese();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chinese <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> objref; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChinese</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Chinese obj1 = Chinese.getInstance();</span><br><span class="line">        Chinese obj2 = Chinese.getInstance();</span><br><span class="line">        System.out.println(obj1 == obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>饿汉模式</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度块。</p>
<p>这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。</p>
<h1>懒汉模式(线程不安全)</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> instance;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。</p>
<h1>懒汉模式(线程安全)</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。</p>
<h1>双重检查模式(DCL)</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    instance= <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>静态内部类单例模式</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之事务隔离级别以及传播机制</title>
    <url>/2020/03/19/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/1078760" target="_blank" rel="noopener">Java提升篇－事务隔离级别和传播机制</a></p>
<p><a href="https://www.cnblogs.com/zhishan/" target="_blank" rel="noopener">在探索中前行</a></p>
<p><a href="https://blog.csdn.net/vbirdbest/article/details/82313903" target="_blank" rel="noopener">Spring Boot入门教程(四十五): 事务@Transactional</a></p>
<p><a href="https://juejin.im/post/5b00c52ef265da0b95276091" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a></p>
<h1>定义</h1>
<blockquote>
<p>事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致性以及操作隔离</p>
</blockquote>
<p><strong>数据一致</strong> 是指事务提交时保证事务内的所有操作都成功完成，并且永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。</p>
<p><strong>操作隔离</strong> 则是指多个同时执行的事务之间应该相互独立，互不影响。</p>
<a id="more"></a>
<h1>属性和行为</h1>
<p>提到事务，不可避免需要涉及到事务的ACID属性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
<h1>隔离级别</h1>
<p><em><strong>⭐️⭐️⭐️ 隔离级别是为了防止多个事务并发执行时，一个事务的执行不应影响其它事务的执行。</strong></em></p>
<p>InnoDB默认的隔离级别是<code>REPEATABLE READ</code>，其可避免<em>脏读</em>和<em>不可重复读</em>，但不能避免<em>幻读</em></p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td>
</tr>
</tbody>
</table>
<h1>传播机制</h1>
<p><em><strong>传播机制是 Spring 针对方法嵌套调用时事务的创建行为提出的机制，</strong></em></p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>表示该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>表示如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像PROPAGATION_REQUIRES一样。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>表示当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>表示该方法不应该在一个事务中运行。如果一个现有事务正在进行中，它将在该方法的运行期间被挂起。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>表示当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES</td>
<td>表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。</td>
</tr>
</tbody>
</table>
<p>按分类的方法可以将 7种 传播级别分为以下几种</p>
<p><u>支持当前事务的情况</u>：</p>
<ul>
<li>**TransactionDefinition.PROPAGATION_REQUIRED：**如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>**TransactionDefinition.PROPAGATION_SUPPORTS：**如果当前存在事务，则加入该事务；如果当前没事务，则以非事务的方式继续运行</li>
<li>**TransactionDefinition.PROPAGATION_MANDATORY：**如果当前存在事务，则加入该事务；如果当前没事务，则抛出异常  (<em><strong>mandatory：强制性</strong></em>)</li>
</ul>
<p><u>不支持当前事务的情况</u>：</p>
<ul>
<li>**TransactionDefinition.PROPAGATION_REQUIRES_NEW：**创建一个新的事务，如果当前存在事务，则把当前事务挂起</li>
<li>**TransactionDefinition.PROPAGATION_NOT_SUPPORTED：**以非事务方式运行，如果当前存在事务，则把当前事务挂起</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER:</strong>  以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><u>其它情况</u>：</p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED:</strong>  如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<p>需要指出的是，前面的<strong>六种事务</strong>传播行为是 Spring <strong>从 EJB 中引入的</strong>，他们共享相同的概念。而 <strong>PROPAGATION_NESTED</strong> 是 Spring 所特有的。</p>
<p>以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，<strong>嵌套的子事务不能单独提交</strong>。</p>
<p>如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</p>
<h1>Spring事务管理接口</h1>
<ul>
<li><strong>PlatformTransactionManager：</strong>(平台) 事务管理器</li>
<li>**TransactionDefinition：**事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li>
<li>**TransactionStatus：**事务运行机制</li>
</ul>
<blockquote>
<p><strong>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</strong></p>
</blockquote>
<h2 id="PlatformTransactionManager"><a class="header-anchor" href="#PlatformTransactionManager">¶</a>PlatformTransactionManager</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。）</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">    <span class="comment">// Commit the given transaction, with regard to its status（使用事务目前的状态提交事务）</span></span><br><span class="line">    <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="comment">// Perform a rollback of the given transaction（对执行的事务进行回滚）</span></span><br><span class="line">    <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TransactionDefinition"><a class="header-anchor" href="#TransactionDefinition">¶</a>TransactionDefinition</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//事务传播机制</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//事务隔离级别</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TransactionDefinition <span class="title">withDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务管理器接口 <strong>PlatformTransactionManager</strong> 通过 <strong>getTransaction(TransactionDefinition definition)</strong> 方法来得到一个事务，这个方法里面的参数是 <strong>TransactionDefinition类</strong> ，这个类就定义了一些基本的事务属性。</p>
<p><img src="https://img-blog.csdnimg.cn/2020031916085413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img1"></p>
<p><img src="https://img-blog.csdnimg.cn/20200319160906456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img2"></p>
<p>NESTED 传播级别</p>
<p><img src="https://img-blog.csdnimg.cn/20200319160916133.png" alt="image-20200319152322070"></p>
<p>@Transactional 只能应用到 public 方法才有效</p>
<p>未完成。。。</p>
]]></content>
      <categories>
        <category>事务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>隔离级别</tag>
        <tag>传播机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之ThreadLocal的理解</title>
    <url>/2020/03/18/Java%E4%B9%8BThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/" target="_blank" rel="noopener">理解Java中的ThreadLocal</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></p>
<h1>定义</h1>
<p>ThreadLocal 是一个关于创建线程局部变量的类</p>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的，而使用 ThreadLocal 创建的变量只能被当前线程访问，其它线程则无法访问和修改。</p>
<a id="more"></a>
<h2 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connect = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect == <span class="keyword">null</span>)&#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect!=<span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p>
<p>所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。</p>
<p>这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。</p>
<p>那么大家来仔细分析一下这个问题，这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。</p>
<p>到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Connection connect = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect == <span class="keyword">null</span>)&#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect!=<span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConnectionManager connectionManager = <span class="keyword">new</span> ConnectionManager();</span><br><span class="line">        Connection connection = connectionManager.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用connection进行操作</span></span><br><span class="line"></span><br><span class="line">        connectionManager.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。</p>
<p><em><strong>注意：</strong></em> 虽然 ThreadLocal 能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用 ThreadLocal 要大</p>
<h1>深入理解</h1>
<p>先了解一下 ThreadLocal 类提供的几个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em><strong>get()</strong></em> 方法用来获取 ThreadLocal 在当前线程中保存的变量副本</li>
<li><em><strong>set()</strong></em> 用来设置当前线程中变量的副本</li>
<li><em><strong>remove()</strong></em> 用来移除当前线程中变量的副本</li>
<li><em><strong>initialValue()</strong></em> 是一个 protected 方法，一般是用来在使用时进行重写的，它是一个延迟加载方法</li>
</ul>
<h2 id="get"><a class="header-anchor" href="#get">¶</a>get()</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//2.然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//3.然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">//4.如果获取成功，则返回value值。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.如果map为空，则调用setInitialValue方法返回value。</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getMap-Thread-t"><a class="header-anchor" href="#getMap-Thread-t">¶</a>getMap(Thread t)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用当期线程t，返回当前线程t中的一个成员变量threadLocals</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="threadLocals"><a class="header-anchor" href="#threadLocals">¶</a>threadLocals</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//threadLocals 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类</span></span><br></pre></td></tr></table></figure>
<h2 id="ThreadLocalMap"><a class="header-anchor" href="#ThreadLocalMap">¶</a>ThreadLocalMap</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment">     * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment">     * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment">     * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment">     * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment">     * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment">     * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment">     * the table starts running out of space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p>
<h2 id="setInitialValue"><a class="header-anchor" href="#setInitialValue">¶</a>setInitialValue()</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment">     * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map</p>
<h2 id="createMap-Thread-t-T-firstValue"><a class="header-anchor" href="#createMap-Thread-t-T-firstValue">¶</a>createMap(Thread t, T firstValue)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<h2 id="例子-v2"><a class="header-anchor" href="#例子-v2">¶</a>例子</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">        stringLocal.set(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        test.set();</span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.set();</span><br><span class="line">                System.out.println(test.getLong());</span><br><span class="line">                System.out.println(test.getString());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">         </span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/29.png" alt="image-20200318204333449"></p>
<p>从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。</p>
<h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3>
<ol>
<li>实际的通过 ThreadLocal  创建的副本是存储在每个线程自己的 threadLocals 中的;</li>
<li>为何 threadLocals 的类型 ThreadLocalMap 的键值为 ThreadLocal 对象，因为每个线程中可有多个 threadLocal 变量，就像上面代码中的 longLocal 和 stringLocal</li>
<li>在进行 get 之前，必须先 set，否则会报空指针异常</li>
</ol>
<h1>应用的场景</h1>
<p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">    = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议,OSI七层协议</title>
    <url>/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE,OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">OSI七层模型详解</a></p>
<p><a href="https://juejin.im/post/5a069b6d51882509e5432656" target="_blank" rel="noopener">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p>
<p><a href="https://blog.csdn.net/zhshulin/article/details/62888061" target="_blank" rel="noopener">一张图了解TCP/IP五层网络模型</a></p>
<a id="more"></a>
<h1>OSI七层协议</h1>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/21.png" alt="img"></p>
<h2 id="物理层"><a class="header-anchor" href="#物理层">¶</a>物理层</h2>
<blockquote>
<p>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</p>
</blockquote>
<h2 id="数据链路层"><a class="header-anchor" href="#数据链路层">¶</a>数据链路层</h2>
<blockquote>
<p>通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p>
</blockquote>
<p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<h2 id="网络层"><a class="header-anchor" href="#网络层">¶</a>网络层</h2>
<blockquote>
<p>通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</p>
</blockquote>
<p>该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p>
<p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。</p>
<h2 id="传输层"><a class="header-anchor" href="#传输层">¶</a>传输层</h2>
<blockquote>
<p>向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</p>
</blockquote>
<p>传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。</p>
<h2 id="会话层"><a class="header-anchor" href="#会话层">¶</a>会话层</h2>
<blockquote>
<p>向两个实体的表示层提供建立和使用连接的方法。</p>
</blockquote>
<h2 id="表示层"><a class="header-anchor" href="#表示层">¶</a><strong>表示层</strong></h2>
<blockquote>
<p>处理用户信息的表示问题，如编码、数据格式转换和加密解密</p>
</blockquote>
<h2 id="应用层"><a class="header-anchor" href="#应用层">¶</a>应用层</h2>
<blockquote>
<p>直接向用户提供服务，完成用户希望在网络上完成的各种工作</p>
</blockquote>
<p>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/22.png" alt="计算机网络体系结构分层"></p>
<p><strong>OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</strong></p>
<h1>TCP/IP 五层协议</h1>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/24.png" alt="img"></p>
<h1>数据处理流程</h1>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/23.png" alt="数据处理流程"></p>
<p>① 应用程序处理<br>
首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>
编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>
<p>② TCP 模块的处理<br>
TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>
<p>③ IP 模块的处理<br>
IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>
<p>④ 网络接口（以太网驱动）的处理<br>
从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<p>⑤ 网络接口（以太网驱动）的处理<br>
主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>
如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>
<p>⑥ IP 模块的处理<br>
IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>
另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>
<p>⑦ TCP 模块的处理<br>
在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<p>⑧ 应用程序的处理<br>
接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>计算机网络</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之集合框架</title>
    <url>/2020/03/17/Java%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://www.jianshu.com/p/63e76826e852" target="_blank" rel="noopener">Java - 集合框架完全解析</a></p>
<p><a href="https://juejin.im/post/5da41417f265da5ba532b21c" target="_blank" rel="noopener">详解Java集合框架，让你全面掌握！</a></p>
<p>在 Java2 之前，Java 是没有完整的集合框架。它只有一些简单的可以自扩展的容器类，比如 Vector，Stack，Hashtable 等。但由于效率的原因遭受诟病，于是不得不进行改革。</p>
<a id="more"></a>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/25.png" alt="img"></p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/26.png" alt="img"></p>
<p>从上面的集合框架可以看到，</p>
<p>Java集合框架主要包括两种类型的容器，一种是集合(Collection)，存储一个元素集合，</p>
<p>另一种是图(Map)，存储 key/value 映射。</p>
<p>Collection接口：</p>
<ul>
<li>List</li>
<li>Set</li>
<li>Queue</li>
</ul>
<p><em><strong>List</strong></em> 代表了 <strong>有序</strong>, <strong>可重复</strong> 集合，可直接根据元素的索引来访问；</p>
<p><em><strong>Set</strong></em> 代表了 <strong>无序</strong>, <strong>不可重复</strong> 集合，只能根据元素本身来访问；</p>
<p><em><strong>Queue</strong></em> 是队列集合</p>
<p><em><strong>Map</strong></em> 代表的是 <strong>存储key/value</strong> 的集合，可根据元素的 key 来访问 value。</p>
<h1>Set 集合</h1>
<p>Set集合与Collection的方法相同，由于Set集合不允许存储相同的元素，所以如果把两个相同元素添加到同一个Set集合，则添加操作失败，新元素不会被加入，add()方法返回false。</p>
<h2 id="1-HashSet"><a class="header-anchor" href="#1-HashSet">¶</a>1.<strong>HashSet</strong></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Set&lt;String&gt; set=<span class="keyword">new</span> HashSet();</span><br><span class="line">   set.add(<span class="string">"hello world"</span>);</span><br><span class="line">   set.add(<span class="string">"hello 冰湖一角"</span>);</span><br><span class="line">   set.add(<span class="string">"hello 冰湖一角"</span>);</span><br><span class="line">   System.out.println(<span class="string">"集合中元素个数："</span></span><br><span class="line">        +set.size());</span><br><span class="line">   System.out.println(<span class="string">"集合中元素为："</span></span><br><span class="line">       +set.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知 <em><strong>HashSet</strong></em> 的底层是通过 <em><strong>HashMap</strong></em> 实现的</p>
<p>查看 <strong>add()</strong> 的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用 HashMap 的 put()</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>put()</strong> 的源码主要是通过 <u>hash值</u> 以及 <u>equals()</u> 方法来避免重复的添加</p>
<h2 id="2-LinkedHashSet"><a class="header-anchor" href="#2-LinkedHashSet">¶</a>2.<strong>LinkedHashSet</strong></h2>
<h2 id="3-TreeSet"><a class="header-anchor" href="#3-TreeSet">¶</a>3.<strong>TreeSet</strong></h2>
<h2 id="4-EnumSet"><a class="header-anchor" href="#4-EnumSet">¶</a>4.<strong>EnumSet</strong></h2>
<h1>List 集合</h1>
<blockquote>
<p>List集合代表一个有序、可重复集合，集合中每个元素都有其对应的顺序索引。List集合默认按照元素的添加顺序设置元素的索引，可以通过索引（类似数组的下标）来访问指定位置的集合元素。</p>
</blockquote>
<h2 id="1-ArrayList"><a class="header-anchor" href="#1-ArrayList">¶</a>1.ArrayList</h2>
<h2 id="2-LinkedList"><a class="header-anchor" href="#2-LinkedList">¶</a>2.<strong>LinkedList</strong></h2>
<h2 id="3-Vector"><a class="header-anchor" href="#3-Vector">¶</a>3.<strong>Vector</strong></h2>
<h2 id="4-Stack"><a class="header-anchor" href="#4-Stack">¶</a>4.<strong>Stack</strong></h2>
<h2 id="5-Iterator接口和ListIterator接口"><a class="header-anchor" href="#5-Iterator接口和ListIterator接口">¶</a>5.<strong>Iterator接口和ListIterator接口</strong></h2>
<h1>Map 集合</h1>
<h2 id="1-HashMap与Hashtable"><a class="header-anchor" href="#1-HashMap与Hashtable">¶</a>1.<strong>HashMap与Hashtable</strong></h2>
<h2 id="2-LinkedHashMap"><a class="header-anchor" href="#2-LinkedHashMap">¶</a>2.<strong>LinkedHashMap</strong></h2>
<h2 id="3-Properties"><a class="header-anchor" href="#3-Properties">¶</a>3.<strong>Properties</strong></h2>
<h2 id="4-TreeMap"><a class="header-anchor" href="#4-TreeMap">¶</a>4.<strong>TreeMap</strong></h2>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之equals理解</title>
    <url>/2020/03/17/Java%E4%B9%8Bequals%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>今天面试的时候，被面试官问到了 ’ == ’ 和 ’ equals ’ 的区别，最后他还总结 equals 是同通过比较 hashCode() 。其实我当时心里挺疑惑的，我记得好像不是比较 hashCode 的。</p>
<p>于是我看了下 String#equals 源码</p>
<a id="more"></a>
<p>String.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this string to the specified object.  The result is &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * true&#125; if and only if the argument is not &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * String&#125; object that represents the same sequence of characters as this</span></span><br><span class="line"><span class="comment">     * object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  anObject</span></span><br><span class="line"><span class="comment">     *         The object to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the given object represents a &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">     *          equivalent to this string, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>  #compareTo(String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>  #equalsIgnoreCase(String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现比较的顺序</p>
<ol>
<li><strong>比较两个对象的地址是否相同</strong></li>
<li><strong>比较两个对象的类型</strong></li>
<li><strong>比较两个对象的值是否相同</strong></li>
<li><strong>详细比较两个对象的每个字符</strong></li>
</ol>
<blockquote>
<p>如有不对，请指教！</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之线程池解析</title>
    <url>/2020/03/17/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676" target="_blank" rel="noopener">面试必备：Java线程池解析</a></p>
<h1>概念</h1>
<p>简单理解，它就是一个管理线程的池子</p>
<ul>
<li>
<p><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</p>
</li>
<li>
<p><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</p>
</li>
<li>
<p><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p>
</li>
</ul>
<a id="more"></a>
<h1>创建</h1>
<p>线程池可以通过 ThreadPoolExecutor 来创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>几个核心参数的作用：</p>
<ul>
<li>
<p><strong>corePoolSize：</strong> 线程池核心线程数最大值</p>
</li>
<li>
<p><strong>maximumPoolSize：</strong> 线程池最大线程数大小</p>
</li>
<li>
<p><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</p>
</li>
<li>
<p><strong>unit：</strong> 线程空闲存活时间单位</p>
</li>
<li>
<p><strong>workQueue：</strong> 存放任务的阻塞队列</p>
</li>
<li>
<p><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</p>
</li>
<li>
<p><strong>handler：</strong>  线城池的饱和策略事件，主要有四种类型。</p>
</li>
</ul>
<h1>任务执行</h1>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/27.png" alt="img"></p>
<ul>
<li>
<p>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</p>
</li>
<li>
<p>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</p>
</li>
<li>
<p>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</p>
</li>
<li>
<p>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</p>
</li>
</ul>
<h2 id="四种拒绝策略"><a class="header-anchor" href="#四种拒绝策略">¶</a>四种拒绝策略</h2>
<ul>
<li>
<p>AbortPolicy(抛出一个异常，默认的)</p>
</li>
<li>
<p>DiscardPolicy(直接丢弃任务)</p>
</li>
<li>
<p>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</p>
</li>
<li>
<p>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</p>
</li>
</ul>
<p><strong>为了形象描述线程池执行，我打个比喻：</strong></p>
<ul>
<li>
<p>核心线程比作公司正式员工</p>
</li>
<li>
<p>非核心线程比作外包员工</p>
</li>
<li>
<p>阻塞队列比作需求池</p>
</li>
<li>
<p>提交任务比作提需求</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/28.png" alt="img"></p>
</li>
<li>
<p>当产品提个需求，正式员工（核心线程）先接需求（执行任务）</p>
</li>
<li>
<p>如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</p>
</li>
<li>
<p>如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</p>
</li>
<li>
<p>如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</p>
</li>
<li>
<p>如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</p>
</li>
</ul>
<p>好的，到这里。<strong>面试问题1-&gt;Java的线程池说一下，各个参数的作用，如何进行的?</strong> 是否已经迎刃而解啦， 我觉得这个问题，回答：<strong>线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</strong> 就差不多啦。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之intern()深入理解</title>
    <url>/2020/03/17/Java%E4%B9%8Bintern()%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>转载：</p>
<p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">美团大佬技术团队！多关注</a></p>
<p>在 Java 语言中有8中种基本类型和一种比较特殊的类型 <code>String</code>。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个 <strong>Java 系统级别提供的缓存</strong></p>
<p>8种基本类型的常量池都是系统协调的，<code>String</code>类型的常量池比较特殊。它的主要使用方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<a id="more"></a>
<h1>1.Java代码</h1>
<p>通过查看源码可以发现，intern() 方法是用 native 修饰的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">     * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">     * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">     * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">     * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">     * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">     *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p>
<h1>2.native 代码</h1>
<p>在 jdk7后，oracle 接管了 JAVA 的源码后就不对外开放了，根据 jdk 的主要开发人员声明 openJdk7 和 jdk7 使用的是同一分主代码，只是分支代码会有些许的变动。所以可以直接跟踪 openJdk7 的源码来探究 intern 的实现。</p>
<ul>
<li>native实现代码:</li>
</ul>
<p>\openjdk7\jdk\src\share\native\java\lang\String.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Java_java_lang_String_intern(JNIEnv *env, jobject <span class="keyword">this</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> JVM_InternString(env, <span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>\openjdk7\hotspot\src\share\vm\prims\jvm.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* java.lang.String </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">JNIEXPORT jstring JNICALL  </span><br><span class="line">JVM_InternString(JNIEnv *env, jstring str);</span><br></pre></td></tr></table></figure>
<p>\openjdk7\hotspot\src\share\vm\prims\jvm.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String support ///////////////////////////////////////////////////////////////////////////  </span></span><br><span class="line">JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))  </span><br><span class="line">  JVMWrapper(<span class="string">"JVM_InternString"</span>);  </span><br><span class="line">  JvmtiVMObjectAllocEventCollector oam;  </span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  oop <span class="built_in">string</span> = JNIHandles::resolve_non_null(str);  </span><br><span class="line">  oop result = StringTable::intern(<span class="built_in">string</span>, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> (jstring) JNIHandles::make_local(env, result);  </span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<p>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">StringTable::intern</span><span class="params">(Handle string_or_null, jchar* name,  </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> len, TRAPS)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = java_lang_String::hash_string(name, len);  </span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);  </span><br><span class="line">  oop <span class="built_in">string</span> = the_table()-&gt;lookup(index, name, len, hashValue);  </span><br><span class="line">  <span class="comment">// Found  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">string</span> != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">string</span>;  </span><br><span class="line">  <span class="comment">// Otherwise, add to symbol to table  </span></span><br><span class="line">  <span class="keyword">return</span> the_table()-&gt;basic_add(index, string_or_null, name, len,  </span><br><span class="line">                                hashValue, CHECK_NULL);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">StringTable::lookup</span><span class="params">(<span class="keyword">int</span> index, jchar* name,  </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">for</span> (HashtableEntry&lt;oop&gt;* l = bucket(index); l != <span class="literal">NULL</span>; l = l-&gt;next()) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;hash() == hash) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (java_lang_String::equals(l-&gt;literal(), name, len)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> l-&gt;literal();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的大体实现结构就是：</p>
<p>Java 使用 <code>JNI</code> 调用 C++ 实现的 <code>StringTable</code> 的 <code>intern</code> 方法，<code>StringTable</code>的<code>intern</code>方法跟Java中的<code>HashMap</code>的实现是差不多的, 只是不能自动扩容。默认大小是1009。</p>
<p>要注意的是，String的String Pool是一个固定大小的<code>Hashtable</code>，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String.intern</code>时性能会大幅下降（因为要一个一个找）。</p>
<p>在 jdk6中<code>StringTable</code>是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，<code>StringTable</code>的长度可以通过一个参数指定：</p>
<ul>
<li><code>-XX:StringTableSize=99991</code></li>
</ul>
<p>相信很多 JAVA 程序员都做做类似 <code>String s = new String(&quot;abc&quot;)</code>这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象。</p>
<h1>示例</h1>
<p>来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果是</p>
<ul>
<li>jdk6 下<code>false false</code></li>
<li>jdk7 下<code>false true</code></li>
</ul>
<p>具体为什么稍后再解释，然后将<code>s3.intern();</code>语句下调一行，放到<code>String s4 = &quot;11&quot;;</code>后面。将<code>s.intern();</code> 放到<code>String s2 = &quot;1&quot;;</code>后面。是什么结果呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<ul>
<li>jdk6 下<code>false false</code></li>
<li>jdk7 下<code>false false</code></li>
</ul>
<h2 id="解释"><a class="header-anchor" href="#解释">¶</a>解释</h2>
<h3 id="jdk6中的解释"><a class="header-anchor" href="#jdk6中的解释">¶</a>jdk6中的解释</h3>
<p><img src="https://img-blog.csdnimg.cn/20200317125431592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="jdk6图"></p>
<p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p>
<p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用<code>String.intern</code>方法也是没有任何关系的。</p>
<h3 id="jdk7中的解释"><a class="header-anchor" href="#jdk7中的解释">¶</a>jdk7中的解释</h3>
<p>再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生<code>java.lang.OutOfMemoryError: PermGen space</code>错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。</p>
<p>正式因为字符串常量池移动到 JAVA Heap 区域后，再来解释为什么会有上述的打印结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200317125452636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="jdk7图1"></p>
<ul>
<li>在第一段代码中，先看 s3和s4字符串。<code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</code>，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的<code>new String(&quot;1&quot;)</code>我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。</li>
<li>接下来<code>s3.intern();</code>这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</li>
<li>最后<code>String s4 = &quot;11&quot;;</code> 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 <code>s3 == s4</code> 是 true。</li>
<li>再看 s 和 s2 对象。 <code>String s = new String(&quot;1&quot;);</code> 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。<code>s.intern();</code> 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</li>
<li>接下来<code>String s2 = &quot;1&quot;;</code> 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。图中画的很清晰。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200317125502968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="jdk7图2"></p>
<h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3>
<p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
<ul>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ul>
<h1>3.intern 正确使用例子</h1>
<p>接下来我们来看一下一个比较常见的使用<code>String#intern</code>方法的例子。</p>
<p>代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static final <span class="built_in">int</span> MAX = <span class="number">1000</span><span class="operator"> * </span><span class="number">10000</span>;</span><br><span class="line">static final String<span class="literal">[]</span> arr = <span class="keyword">new</span> String<span class="literal">[MAX]</span>;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">    Integer<span class="literal">[]</span> DB_DATA = <span class="keyword">new</span> Integer<span class="literal">[<span class="number">10</span>]</span>;</span><br><span class="line">    Random random = <span class="keyword">new</span> <span class="constructor">Random(10 <span class="operator">*</span> 10000)</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="module-access"><span class="module"><span class="identifier">DB_DATA</span>.</span></span>length; i++) &#123;</span><br><span class="line">        DB_DATA<span class="literal">[<span class="identifier">i</span>]</span> = random.next<span class="constructor">Int()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	long t = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        <span class="comment">//arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span></span><br><span class="line">         arr<span class="literal">[<span class="identifier">i</span>]</span> = <span class="keyword">new</span> <span class="constructor">String(String.<span class="params">valueOf</span>(DB_DATA[<span class="params">i</span> % DB_DATA.<span class="params">length</span>])</span>).intern<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println((<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span> - t) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>gc<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的参数是：<code>-Xmx2g -Xms2g -Xmn1500M</code> 上述代码是一个演示代码，其中有两条语句不一样，一条是使用 intern，一条是未使用 intern。结果如下图</p>
<p>2160ms</p>
<p><img src="https://img-blog.csdnimg.cn/20200317125338436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="使用 intern"></p>
<p>826ms<img src="https://img-blog.csdnimg.cn/2020031712540094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="未使用 intern"></p>
<p>通过上述结果，我们发现不使用 intern 的代码生成了1000w 个字符串，占用了大约640m 空间。 使用了 intern 的代码生成了1345个字符串，占用总空间 133k 左右。其实通过观察程序中只是用到了10个字符串，所以准确计算后应该是正好相差100w 倍。虽然例子有些极端，但确实能准确反应出 intern 使用后产生的巨大空间节省。</p>
<p>细心的同学会发现使用了 intern 方法后时间上有了一些增长。这是因为程序中每次都是用了 <code>new String</code> 后，然后又进行 intern 操作的耗时时间，这一点如果在内存空间充足的情况下确实是无法避免的，但我们平时使用时，内存空间肯定不是无限大的，不使用 intern 占用空间导致 jvm 垃圾回收的时间是要远远大于这点时间的。 毕竟这里使用了1000w次intern 才多出来1秒钟多的时间。</p>
<h1>4.intern 不当使用</h1>
<p>看过了 intern 的使用和 intern 的原理等，我们来看一个不当使用 intern 操作导致的问题。</p>
<p>在使用 fastjson 进行接口读取的时候，我们发现在读取了近70w条数据后，我们的日志打印变的非常缓慢，每打印一次日志用时30ms左右，如果在一个请求中打印2到3条日志以上会发现请求有一倍以上的耗时。在重新启动 jvm 后问题消失。继续读取接口后，问题又重现。接下来我们看一下出现问题的过程</p>
<h2 id="4-1-根据-log4j-打印日志查找问题原因"><a class="header-anchor" href="#4-1-根据-log4j-打印日志查找问题原因">¶</a>4.1.根据 log4j 打印日志查找问题原因</h2>
<p>在使用<code>log4j#info</code>打印日志的时候时间非常长。所以使用 housemd 软件跟踪 info 方法的耗时堆栈。</p>
<ul>
<li>trace SLF4JLogger.</li>
<li>trace AbstractLoggerWrapper:</li>
<li>trace AsyncLogger</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">org/apache/logging/log4j/core/async/AsyncLogger.actualAsyncLog(RingBufferLogEvent)                sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">109</span>aca82            <span class="number">1</span>            <span class="number">1ms</span>    org<span class="selector-class">.apache</span><span class="selector-class">.logging</span><span class="selector-class">.log4j</span><span class="selector-class">.core</span><span class="selector-class">.async</span>.AsyncLogger@<span class="number">19</span>de86bb  </span><br><span class="line">org/apache/logging/log4j/core/async/AsyncLogger.location(String)                                  sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">30ms</span>    org<span class="selector-class">.apache</span><span class="selector-class">.logging</span><span class="selector-class">.log4j</span><span class="selector-class">.core</span><span class="selector-class">.async</span>.AsyncLogger@<span class="number">19</span>de86bb  </span><br><span class="line">org/apache/logging/log4j/core/async/AsyncLogger.log(Marker, String, Level, Message, Throwable)    sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">61ms</span>    org<span class="selector-class">.apache</span><span class="selector-class">.logging</span><span class="selector-class">.log4j</span><span class="selector-class">.core</span><span class="selector-class">.async</span>.AsyncLogger@<span class="number">19</span>de86bb</span><br></pre></td></tr></table></figure>
<p>代码出在 <code>AsyncLogger.location</code> 这个方法上. 里边主要是调用了 <code>return Log4jLogEvent.calcLocation(fqcnOfLogger);</code>和<code>Log4jLogEvent.calcLocation()</code></p>
<p><code>Log4jLogEvent.calcLocation()</code>的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StackTraceElement <span class="title">calcLocation</span><span class="params">(<span class="keyword">final</span> String fqcnOfLogger)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (fqcnOfLogger == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();  </span><br><span class="line">    <span class="keyword">boolean</span> next = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> StackTraceElement element : stackTrace) &#123;  </span><br><span class="line">        <span class="keyword">final</span> String className = element.getClassName();  </span><br><span class="line">        <span class="keyword">if</span> (next) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> element;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </span><br><span class="line">            next = <span class="keyword">true</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NOT_AVAIL.equals(className)) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过跟踪发现是 <code>Thread.currentThread().getStackTrace();</code> 的问题。</p>
<h2 id="4-2-跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern"><a class="header-anchor" href="#4-2-跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern">¶</a>4.2.跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern</h2>
<p><code>Thread.currentThread().getStackTrace();</code>native的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> StackTraceElement[] getStackTrace() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;  </span><br><span class="line">        <span class="comment">// check for getStackTrace permission  </span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();  </span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            security.checkPermission(  </span><br><span class="line">                SecurityConstants.GET_STACK_TRACE_PERMISSION);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// optimization so we do not call into the vm for threads that  </span></span><br><span class="line">        <span class="comment">// have not yet started or have terminated  </span></span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;  </span><br><span class="line">            <span class="keyword">return</span> EMPTY_STACK_TRACE;  </span><br><span class="line">        &#125;        StackTraceElement[][] stackTraceArray = dumpThreads(<span class="keyword">new</span> Thread[] &#123;<span class="keyword">this</span>&#125;);  </span><br><span class="line">        StackTraceElement[] stackTrace = stackTraceArray[<span class="number">0</span>];  </span><br><span class="line">        <span class="comment">// a thread that was alive during the previous isAlive call may have  </span></span><br><span class="line">        <span class="comment">// since terminated, therefore not having a stacktrace.  </span></span><br><span class="line">        <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            stackTrace = EMPTY_STACK_TRACE;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stackTrace;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// Don't need JVM help for current thread  </span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Exception()).getStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> StackTraceElement[][] dumpThreads(Thread[] threads);</span><br></pre></td></tr></table></figure>
<p>下载 openJdk7的源码查询 jdk 的 native 实现代码，列表如下【这里因为篇幅问题，不详细罗列涉及到的代码，有兴趣的可以根据文件名称和行号查找相关代码】：</p>
<p>\openjdk7\jdk\src\share\native\java\lang\Thread.c<br>
\openjdk7\hotspot\src\share\vm\prims\jvm.h line:294: \openjdk7\hotspot\src\share\vm\prims\jvm.cpp line:4382-4414:<br>
\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:235-267: \openjdk7\hotspot\src\share\vm\services\threadService.cpp line:566-577:<br>
\openjdk7\hotspot\src\share\vm\classfile\javaClasses.cpp line:1635-[1651,1654,1658]:</p>
<p>完成跟踪了底层的 jvm 源码后发现，是下边的三条代码引发了整个程序的变慢问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oop classname = StringTable::intern((<span class="keyword">char</span>*) str, CHECK_0);  </span><br><span class="line">oop methodname = StringTable::intern(method-&gt;name(), CHECK_0);  </span><br><span class="line">oop filename = StringTable::intern(source, CHECK_0);</span><br></pre></td></tr></table></figure>
<p>这三段代码是获取类名、方法名、和文件名。因为类名、方法名、文件名都是存储在字符串常量池中的，所以每次获取它们都是通过<code>String#intern</code>方法。但没有考虑到的是默认的 StringPool 的长度是1009且不可变的。因此一旦常量池中的字符串达到的一定的规模后，性能会急剧下降。</p>
<h2 id="4-3-fastjson-不当使用-String-intern"><a class="header-anchor" href="#4-3-fastjson-不当使用-String-intern">¶</a>4.3.fastjson 不当使用 String#intern</h2>
<p>导致这个 intern 变慢的原因是因为 fastjson 对<code>String#intern</code>方法的使用不当造成的。跟踪 fastjson 中的实现代码发现，</p>
<p><code>com.alibaba.fastjson.parser.JSONScanner#scanFieldSymbol()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == <span class="string">'\"'</span>) &#123;</span><br><span class="line">    bp = index;</span><br><span class="line">    <span class="keyword">this</span>.ch = ch = buf[bp];</span><br><span class="line">    strVal = symbolTable.addSymbol(buf, start, index - start - <span class="number">1</span>, hash);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>com.alibaba.fastjson.parser.SymbolTable#addSymbol()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new entry from the specified symbol information and next entry reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> hash, Entry next)</span></span>&#123;</span><br><span class="line">    characters = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">    System.arraycopy(ch, offset, characters, <span class="number">0</span>, length);</span><br><span class="line">    symbol = <span class="keyword">new</span> String(characters).intern();</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.hashCode = hash;</span><br><span class="line">    <span class="keyword">this</span>.bytes = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fastjson 中对所有的 json 的 key 使用了 intern 方法，缓存到了字符串常量池中，这样每次读取的时候就会非常快，大大减少时间和空间。而且 json 的 key 通常都是不变的。这个地方没有考虑到大量的 json key 如果是变化的，那就会给字符串常量池带来很大的负担。</p>
<p>这个问题 fastjson 在1.1.24版本中已经将这个漏洞修复了。程序加入了一个最大的缓存大小，超过这个大小后就不会再往字符串常量池中放了。</p>
<p>[1.1.24版本的<code>com.alibaba.fastjson.parser.SymbolTable#addSymbol()</code> Line:113]代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt;= MAX_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer, offset, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题是70w 数据量时候的引发的，如果是几百万的数据量的话可能就不只是30ms 的问题了。因此在使用系统级提供的<code>String#intern</code>方式一定要慎重！</p>
<p>本文大体的描述了 <code>String#intern</code>和字符串常量池的日常使用，jdk 版本的变化和<code>String#intern</code>方法的区别，以及不恰当使用导致的危险等内容，让大家对系统级别的 <code>String#intern</code>有一个比较深入的认识。让我们在使用和接触它的时候能避免出现一些 bug，增强系统的健壮性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>常量池</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架Thrift</title>
    <url>/2020/03/16/RPC%E6%A1%86%E6%9E%B6Thrift/</url>
    <content><![CDATA[<p><code>Thrift</code>是一个<strong>轻量级</strong>、<strong>跨语言</strong>的<strong>远程服务调用</strong>框架，它通过自身的<code>IDL</code><strong>中间语言</strong>, 并借助<strong>代码生成引擎</strong>生成各种主流语言的<code>RPC</code><strong>服务端</strong>/<strong>客户端</strong>模板代码。</p>
<p><strong>如何实现多语言之间的通信？</strong></p>
<a id="more"></a>
<p>数据传输使用 socket(多种语言均支持)，数据再以特定的格式 (String 等) 发送，接收方语言进行解析。</p>
<p>定义 thrift 的文件，由 thrift 文件(IDL) 生成双方语言的接口，model，在生成的 model 以及接口中会有解码编码的代码</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvMjkzODFmMzBlOTI0Yjg5OTkzNjZhYzEyNmMwNjFkOTUwYTdiZjY0Ng?x-oss-process=image/format,png" alt="img"></p>
<p><strong>Thrift 传输格式</strong></p>
<ul>
<li>TBinaryProtocol: 二进制格式</li>
<li>TCompactProtocol: 压缩格式</li>
<li>TJSONProtocol： JSON格式</li>
<li>TSimpleJSONProtocol： 提供 JSON 只写协议，生成的文件很容易通过脚本语言解析</li>
<li>TDebugProtocol：使用易懂的可读的文本格式，以便于debug</li>
</ul>
<p><strong>Thrift数据传输方式</strong></p>
<ul>
<li>TSocket：阻塞式socket</li>
<li>TFramedTransport：以frame为单位进行传输，以非阻塞式服务中使用</li>
<li>TFileTransport：以文件形式进行传输</li>
<li>TMemoryTransport：将内存用于 I/O, Java 实现内部实际使用了简单的 ByteArrayOutputStream</li>
<li>TZlibTransport：使用 zlib 进行压缩，与其他传输方式联合使用。当前无 Java 实现</li>
</ul>
<p>Thrift支持的服务模型</p>
<ul>
<li>TSimpleServer：简单的单线程服务模型，常用于测试</li>
<li>TThreadPoolServer：多线程服务模型，使用标准的阻塞式 IO</li>
<li>TNonblockingServer：多线程服务模型，使用非阻塞式 IO(需使用TFramedTransport数据传输方式)</li>
<li>THsHaServer：THsHa 引入了线程池去处理，其模型把读写任务放到线程池去处理；Half-sync/Half-async 的处理模式，Half-async 是在处理 IO 事件上(accept/read/write io),Half-sync 用于 handler 对 rpc 的同步处理</li>
</ul>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT7.7.x版本添加访问量和访客数</title>
    <url>/2020/03/15/NexT7.7.x%E7%89%88%E6%9C%AC%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E8%AE%BF%E5%AE%A2%E6%95%B0/</url>
    <content><![CDATA[<p>最近看多了别人的个人博客网站弄得挺精致的，居然有<strong>访客数</strong>和<strong>访问量</strong>，不行我也不能落后，所以自己也准备升级下自己简陋的博客网站哈哈。</p>
<p>由于我的 Hexo 的版本(7.7.2) 在目前来说是最新的，所以通过百度和google查询到的资料不多，所以耗费了好几个小时在搜查相关的资料，终于功夫不负有心人，最终升级成功。</p>
<p>据<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官网</a>说, 他们在第三方服务中提供了 <strong>不蒜子统计</strong> 的功能，看来多看看官网还是有好处的哈哈。</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200315223305251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200315222038516"></p>
<p>1.参照了相关的资料，需要修改将 <strong>主题配置文件</strong> 中的<code>busuanzi_count</code>的配置项。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>给 <strong>footer.swig</strong> 添加以下内容，该文件在径<code>&quot;\themes\next\layout\_partials\</code> 下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">	&lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">		&lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">	&lt;&#x2F;span&gt;</span><br><span class="line">	访问量：&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt; 次数</span><br><span class="line">&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">	&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">	访客数：&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt; 人次</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 以上内容放错位置可就显示的不好看哦</p>
</blockquote>
<p>把这段内容添加 <code>&lt;div div class=&quot;copyright&quot;&gt;</code> 模块的末尾添加，示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;copyright&quot;&gt;</span><br><span class="line">  &#123;% set copyright_year &#x3D; date(null, &#39;YYYY&#39;) %&#125;</span><br><span class="line">  &amp;copy; &#123;% if theme.footer.since and theme.footer.since !&#x3D; copyright_year %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;</span><br><span class="line">  &lt;span itemprop&#x3D;&quot;copyrightYear&quot;&gt;&#123;&#123; copyright_year &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;with-love&quot;&gt;</span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.footer.icon.name &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;author&quot; itemprop&#x3D;&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright or author &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">  &#123;%- if config.symbols_count_time.total_symbols %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-area-chart&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#39;symbols_count_time.count_total&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title&#x3D;&quot;&#123;&#123; __(&#39;symbols_count_time.count_total&#39;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsCountTotal(site) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if config.symbols_count_time.total_time %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-coffee&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#39;symbols_count_time.time_total&#39;) &#125;&#125; &amp;asymp;&lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title&#x3D;&quot;&#123;&#123; __(&#39;symbols_count_time.time_total&#39;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsTimeTotal(site, theme.symbols_count_time.awl, theme.symbols_count_time.wpm, __(&#39;symbols_count_time.time_minutes&#39;)) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;添加的位置从这里开始</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    访问量：&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt; 次数</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">    访客数：&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt; 人次</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">  &#x2F;&#x2F;这里结束</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>重新部署一下，需要的内容就出来啦！</p>
<p>效果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200315223249814.png" alt="image-20200315223107231"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中基本类型存储方式</title>
    <url>/2020/03/15/Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>java 把内存分为两种：</p>
<p>一种是 <strong>栈内存</strong>，另一种是 <strong>堆内存</strong></p>
<ol>
<li>在函数中定义的基本类型变量(即基本类型的局部变量) 和 对象的引用变量(即对象的变量名) 都在函数的栈内存中分配</li>
<li>堆内存用来存放由 new 创建的对象和数组以及对象的实例变量(即全局变量)</li>
</ol>
<p>方法区中主要存储所有对象数据共享区域，存储静态变量和普通方法、静态方法、常量、字符串常量（严格说存放在常量池，堆和栈都有）等类信息，、说白了就是保存类的模板</p>
<a id="more"></a>
<p>其实基本类型的数据并不都是存储在栈上的，例如：类的成员变量如果是基本类型(int,float,double等)，它就存储在堆内存中。</p>
<p><em><strong>反证</strong></em>：如果类的成员变量(基本数据类型)存储在栈上，众所周知，栈<strong>不是线程共享</strong>的且它的生命周期随着相关方法的结束就结束，可这时只是执行完了一个方法，而整个类的生命周期还未结束，难道这个类的成员变量也就无法调用了？这不就矛盾了吗？</p>
<p>所以说基本类型的数据并不都是存储在栈上的。而且堆是<strong>线程共享的</strong>，类的成员变量应该是属于这个类的，而不是属于某个方法的，具有共享的性质，所以也应该存储在堆上。</p>
<p>总结：</p>
<ol>
<li>方法内定义的基本数据类型放在栈帧中，栈里面的数据都是线程私有的，不共享。</li>
<li>方法外定义的类成员变量，存放在 JVM 的堆中</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Protobuf协议缓冲区</title>
    <url>/2020/03/15/Google-Protobuf%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<p><a href="https://developers.google.cn/protocol-buffers/" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://juejin.im/post/5938f1785c497d006b613b0d" target="_blank" rel="noopener">更小、更快、更简单Google ProtoBuf 跨语言通信协议</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1146352" target="_blank" rel="noopener">通讯协议序列化解读（一） Protobuf详解教程</a></p>
<blockquote>
<p>协议缓冲区是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。</p>
</blockquote>
<a id="more"></a>]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之装饰器模式</title>
    <url>/2020/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">装饰器模式</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319302594594" target="_blank" rel="noopener">装饰器</a></p>
<blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来讲，相比生成子类更为灵活</p>
</blockquote>
<p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200313164100749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200215214741558"></p>
<ul>
<li>
<p>**Component(组件)：**组件接口定义了全部组件实现类以及所有 <em>装饰器实现的行为。</em></p>
</li>
<li>
<p>**ConcreteComponent(具体组件实现类)：**具体组件实现类实现了Component接口。通常情况下，具体组件实现类就是被装饰器装饰的原始对象，该类提供了 Component 接口中定义的最基本的功能，其它高级功能或后续添加的新功能，都是通过装饰器的方式添加到该类的对象之上。</p>
</li>
<li>
<p>**Decorator(装饰器)：**所有装饰器的父类，它是一个实现了 Component 接口的<em>抽象类</em>，并在<em>其中封装了一个 Component 对象</em>，也就是被装饰的对象。而这个被装饰的对象只要是 Component 类型即可，这就实现了装饰器的组合和复用。</p>
</li>
<li>
<p>**ConcreteDecorator：**具体的装饰器实现类，该实现类要向被装饰对象添加某些功能。</p>
</li>
</ul>
<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>
<p>Decorator模式有什么好处？<strong>它实际上把 <em>核心功能</em> 和 <em>附加功能</em> 给分开了</strong>。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造者模式</title>
    <url>/2020/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://juejin.im/post/5a23bdd36fb9a045272568a6" target="_blank" rel="noopener">人人都会设计模式—建造者模式–Builder</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319155793953#0" target="_blank" rel="noopener">生成器</a></p>
<blockquote>
<p>将一个复杂对象的构建过程与它的表示分离，从而使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>建造者模式将一个复杂对象的创建过程分成了一步步简单的步骤，用户只需要了解复杂对象的类型和内容，而无须关注复杂对象的具体构造过程，帮助用户屏蔽掉了复杂对象内部的具体构建细节。</p>
<a id="more"></a>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/10.png" alt="image-20200219114359493"></p>
<p>主要角色如下所述：</p>
<ul>
<li>**建造者(Builder)接口：**Builder接口用于定义建造者构建产品对象的各部分行为</li>
<li>**具体建造者(ConcreteBuilder)角色：**在建造者模式中，直接创建产品对象的是具体建造者。具体建造者类必须实现建造者接口所要求的两类方法：
<ul>
<li>建造方法</li>
<li>获取构建好的产品对象方法</li>
</ul>
</li>
<li>**导演(Direct)角色：**该角色会通过调用具体建造者，创建需要的产品对象</li>
<li>**产品(Product)角色：**产品对象就是用户需要使用的复杂对象</li>
</ul>
<h2 id="一-什么是建造者模式"><a class="header-anchor" href="#一-什么是建造者模式">¶</a>一.什么是建造者模式</h2>
<h3 id="1-生活中的建造者模式"><a class="header-anchor" href="#1-生活中的建造者模式">¶</a>1.生活中的建造者模式</h3>
<blockquote>
<p>1.盖房子</p>
</blockquote>
<p>我们在生活中盖房子，一般就是打地基，盖框架「用砖头或钢筋混凝土」，然后是粉刷。基本上就是这个路子。当然我们这些工作全部可以自己做，可也以找几个工人去干，当然还可以可以直接找一个设计师，直接说我就要这样的房子，然后就不管了，最后问设计师「设计师给一张纸给工人，工人就啪啪的干了」验收房子即可「至于你是如何建的过程我不关心，我只要结果」—这就是建造者模式</p>
<blockquote>
<p>2.组装电脑</p>
</blockquote>
<p>我们买的电脑都是由主板、内存、cpu、显卡等组成，如何把这些东西组装起来给用户这就是建造者模式的作用，不同的人对电脑的配置需求不一样的「打游戏的对显卡要求高」，但是电脑构成部件是固定的，我们找电脑城的装机人员把电脑装起来这一过程就是建造模式</p>
<blockquote>
<p>3.软件开发</p>
</blockquote>
<p>我们开发一款产品，需要技术主管、产品经理、苦逼的程序员。在这里，产品经理就是指挥者「Director」和客户沟通，了解产品需求，技术主管是抽象的建造者[Builder]，让猿们杂做就杂做，而程序员就是体力劳动者「即具体的建造者，按照技术主管下发的任务去做」</p>
<h3 id="2-程序中的建造者模式"><a class="header-anchor" href="#2-程序中的建造者模式">¶</a>2.程序中的建造者模式</h3>
<blockquote>
<p>建造者模式的特点</p>
</blockquote>
<p>建造者模式是一种创建型模式，适用于那些流程固定【顺序不一定固定】，建造的目标对象会有所改变这种场景【比如画一条狗，这个目标不变，但是不同的是有黄狗，胖狗，瘦狗等】</p>
<p>还有一种场景就是替代 <strong>多参数构造器</strong></p>
<blockquote>
<p>建造者模式的作用</p>
</blockquote>
<ul>
<li>1、用户不知道对象的建造过程和细节就可以创建出复杂的对象「屏蔽了建造的具体细节」</li>
<li>2、用户只需给出复杂对象的内容和类型可以创建出对象</li>
<li>3、建造者模工按流程一步步的创建出复杂对象</li>
</ul>
<blockquote>
<p>建造者模式的结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>角色</th>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Builder</td>
<td>接口或抽象类</td>
<td>抽象的建造者，不是必须的</td>
</tr>
<tr>
<td>ConcreateBuilder</td>
<td>具体的建造者</td>
<td>可以有多个「因为每个建造风格可能不一样」</td>
</tr>
<tr>
<td>Product</td>
<td>普通的类</td>
<td>具体的产品「即被建造的对象」</td>
</tr>
<tr>
<td>Director</td>
<td>导演也叫指挥者</td>
<td>统一指挥建造者去建造目标，导演不是必须的</td>
</tr>
</tbody>
</table>
<h2 id="二-建造者模式的举例"><a class="header-anchor" href="#二-建造者模式的举例">¶</a>二 建造者模式的举例</h2>
<blockquote>
<p>1.组装电脑</p>
</blockquote>
<p>小明想组装一个台式电脑，小明对电脑配置一窍不通，就直接跑到电脑城给装机老板说我要一台打游戏非常爽的电脑，麻烦你给装一下「配置什么的你给我推荐一下吧」，于是老板就让它的员工「小美」按小明的要求装了一个性能灰常牛 B 的电脑，1 个小时后电脑装好了，小明交钱拿电脑走人。不一会儿小张又来了，要一个满足平时写文章就可以的电脑，老板针对小张的要求给不同的装机配置。不同的人有不同的配置方案「但是装机流程是一样的」，这就是一个典型的建造者模式</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/11.png" alt="组装电脑简单的 UML"></p>
<ul>
<li>创建被建造的对象电脑(产品类) — Computer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 产品类--被建造的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu ; <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hardDisk ; <span class="comment">//硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String mainBoard ; <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String memory ; <span class="comment">// 内存</span></span><br><span class="line">    ... 省略 getter 和 setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象的建造者 — Builder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 抽象的建造者，即装电脑的步骤</span></span><br><span class="line"><span class="comment"> * 至于安装什么型号的主板，不是我关心，而是具体的建造者关心的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 安装主板</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装 cpu</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createCpu</span><span class="params">(String cpu)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装硬盘</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createhardDisk</span><span class="params">(String hardDisk)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span> </span>;</span><br><span class="line">    <span class="comment">// 组成电脑</span></span><br><span class="line">    <span class="function">Computer <span class="title">createComputer</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体建造者，也就是装机工人小美 — AssemblerBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 具体的建造者，这里是商场的一个装机人员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssemblerBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer = <span class="keyword">new</span> Computer() ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createhardDisk</span><span class="params">(String hardDisk)</span> </span>&#123;</span><br><span class="line">        computer.setHardDisk(hardDisk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">        computer.setMainBoard(mainBoard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还有老板「“指手画脚的人”」安排装机工工作 — Direcror.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 声明一个导演类「指挥者，这里可以装电脑的老板」，用来指挥组装过程，也就是组装电脑的流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder ;</span><br><span class="line">	<span class="comment">// 使用多态，装机工非常多，我管你小美，小兰，小猪，我统统收了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Direcror</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 老板最后只想看到装成的成品---要交到客户手中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">(String cpu,String hardDisk,String mainBoard,String memory)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 具体的工作是装机工去做</span></span><br><span class="line">        <span class="keyword">this</span>.builder.createMainBoard(mainBoard);</span><br><span class="line">        <span class="keyword">this</span>.builder.createCpu(cpu) ;</span><br><span class="line">        <span class="keyword">this</span>.builder.createMemory(memory);</span><br><span class="line">        <span class="keyword">this</span>.builder.createhardDisk(hardDisk);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.builder.createComputer() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">// 装机员小美</span></span><br><span class="line">        Builder builder = <span class="keyword">new</span> AssemblerBuilder() ;</span><br><span class="line">        <span class="comment">// 老板把小明的需求转给小美</span></span><br><span class="line">        Direcror direcror = <span class="keyword">new</span> Direcror(builder) ;</span><br><span class="line">        <span class="comment">// 老板最后拿到成品机子，工作全由小美去做</span></span><br><span class="line">        Computer computer = direcror.createComputer(<span class="string">"Intel 酷睿i9 7900X"</span>,<span class="string">"三星M9T 2TB （HN-M201RAD）"</span>,<span class="string">"技嘉AORUS Z270X-Gaming 7"</span>,<span class="string">"科赋Cras II 红灯 16GB DDR4 3000"</span>) ;</span><br><span class="line">        System.out.println(<span class="string">"小明这台电脑使用的是：\n"</span>+computer.getMainBoard()+<span class="string">" 主板\n"</span>+computer.getCpu()+<span class="string">" CPU\n"</span>+computer.getHardDisk()+<span class="string">"硬盘\n"</span>+computer.getMainBoard()+<span class="string">" 内存\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.盖房子</p>
</blockquote>
<p>盖房子的基本步骤和流程是固定的无非就是打地基、盖框架、然后浇筑「至于盖平房、还是楼房那是每个客户的具体需求」。总体来说盖房子以有以三种方式：</p>
<ul>
<li>1、自己盖房子「没有办法有的人就是牛 B ,自己设计，自己动手，当然这属于小房子，你让一个人盖个32 层让我看看」</li>
<li>2、想盖房子的人是一个包工头，自己找一帮工人自己就把房子搞定了</li>
<li>3、想盖房子的人就是一个普通人，啥也不会，找一个设计师说“我就要盖个房子，南北通透，四秀常春”，设计师说没有问题，设计师把设计出来的图纸扔给包工头说：“就照这个样子盖”，包工头拿着图纸给工人们分工派活，最后完工</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/12.png" alt="盖房子建造者模式简单的 UML"></p>
<ul>
<li>房子对象 House.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 最终的产品---房子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="keyword">private</span> String foundation ;</span><br><span class="line">    <span class="comment">// 盖框架</span></span><br><span class="line">    <span class="keyword">private</span> String frame ;</span><br><span class="line">    <span class="comment">// 浇筑</span></span><br><span class="line">    <span class="keyword">private</span> String pouring ;</span><br><span class="line">    ... 省略 setter 和 getter </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象建造者「包工头」 HouseBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 盖框架</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 浇灌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 房子建成 </span></span><br><span class="line">    <span class="function">House <span class="title">getHouse</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体建造者「工人」–盖平房 PingFangBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 盖平房</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingFangBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> House house = <span class="keyword">new</span> House() ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFoundation(<span class="string">"盖平房的地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFrame(<span class="string">"盖平房的框架"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setPouring(<span class="string">"盖平房不用浇灌，直接人工手刷就可以"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体建造者「工人」–盖楼房 LouFangBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 盖楼房</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LouFangBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> House house = <span class="keyword">new</span> House() ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFoundation(<span class="string">"盖楼房的地基就打十米深"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFrame(<span class="string">"楼房的框架要使用非常坚固钢筋混凝土"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setPouring(<span class="string">"楼房拿个罐车把框架拿混凝土灌满即可"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指挥者「设计师」 HouseDirector.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 设计师</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指挥包工头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHouse</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        houseBuilder.doFoundation();</span><br><span class="line">        houseBuilder.doFrame();</span><br><span class="line">        houseBuilder.dpPouring();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试一下 Test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式一、客户自己盖房子，亲力亲为</span></span><br><span class="line">        System.out.println(<span class="string">"========客户自己建房子，必须知道盖房的细节========"</span>);</span><br><span class="line">        House house = <span class="keyword">new</span> House() ;</span><br><span class="line">        house.setFoundation(<span class="string">"用户自己建造房子：打地基"</span>);</span><br><span class="line">        house.setFrame(<span class="string">"用户自己建造房子：盖框架"</span>);</span><br><span class="line">        house.setPouring(<span class="string">"用户自己建造房子：浇筑"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(house.getFoundation());</span><br><span class="line">        System.out.println(house.getFrame());</span><br><span class="line">        System.out.println(house.getPouring());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二、客户找一个建造者盖房子「充当包工头角色」，但是要知道如何盖房子「调用建造者盖房子的顺序」</span></span><br><span class="line">        System.out.println(<span class="string">"========客户直接找盖房子的工人「建造者」，客户要调用建造者方法去盖房子，客户必须得知道房子如何造========"</span>);</span><br><span class="line"></span><br><span class="line">        HouseBuilder houseBuilder = <span class="keyword">new</span> PingFangBuilder() ;</span><br><span class="line">        houseBuilder.doFoundation();</span><br><span class="line">        houseBuilder.doFrame();</span><br><span class="line">        houseBuilder.dpPouring();</span><br><span class="line">        House house1 = houseBuilder.getHouse() ;</span><br><span class="line">        System.out.println(house1.getFoundation());</span><br><span class="line">        System.out.println(house1.getFrame());</span><br><span class="line">        System.out.println(house1.getPouring());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三、使用建造者模式，找一个设计师「设计师拉一帮建造者去干活」，告诉他我想要什么样的房子，最后客户只问设计师要房子即可</span></span><br><span class="line">        System.out.println(<span class="string">"========客户直接找一个设计师，设计师统一指挥建造者盖房子，房子杂盖，客户不关心，最后只是找设计师要房子即可========"</span>);</span><br><span class="line"></span><br><span class="line">        HouseBuilder pingFangBuilder = <span class="keyword">new</span> PingFangBuilder() ;</span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector() ;</span><br><span class="line">        houseDirector.buildHouse(pingFangBuilder);</span><br><span class="line">        House houseCreateByBuilder = pingFangBuilder.getHouse() ;</span><br><span class="line"></span><br><span class="line">        System.out.println(houseCreateByBuilder.getFoundation());</span><br><span class="line">        System.out.println(houseCreateByBuilder.getFrame());</span><br><span class="line">        System.out.println(houseCreateByBuilder.getPouring());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.替代多参数构造函数的建造者模式，以组装电脑为例</p>
</blockquote>
<p>前面我们说了<strong>在建造者模式中 Director 不是必须的</strong>，Director 的作用不是构造产品「建造产品是建造者的事情」而是指挥协调建造的步骤「当有一个新的建造者的时候直接实现抽象建造者，而不用关心具体的执行步骤，这就是 Director 干的事情」</p>
<ul>
<li>原始的 Computer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些可选配置</span></span><br><span class="line">    <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">    <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">    <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">    <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String graphicsCard,String mouse,String computerCase,String mousePad,String other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = mousePad ;</span><br><span class="line">        <span class="keyword">this</span>.other = other ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                    String graphicsCard,String mouse,String computerCase,String mousePad)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = mousePad ;</span><br><span class="line">    &#125;</span><br><span class="line">    ... 省略其它的构造方法和 setter 和 getter 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要调用这个类就得在构参数方法中传递“无数个参数”「如果有的参是一些可选项，我们还得重写构造方法」，要么就要调用多个 setter 方法，才能给一个对象赋值，方法虽然可行，但是也太扯淡了「谁能记住那些参数呀」，那么建造者模式可以解决多参数构造方法来建造对象</p>
<ul>
<li>使用建造者建立 ComputerB.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 替代多参构造方法--建造者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些可选配置</span></span><br><span class="line">    <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">    <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">    <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">    <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ComputerB 自己充当 Director </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComputerB</span><span class="params">(ComputerBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = builder.mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = builder.cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = builder.hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = builder.powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = builder.graphicsCard ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mouse = builder.mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = builder.computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = builder.mousePad ;</span><br><span class="line">        <span class="keyword">this</span>.other = builder.other ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 声明一个静态内存类 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一个电脑的必须配置</span></span><br><span class="line">        <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">        <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">        <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">        <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">        <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其它一些可选配置</span></span><br><span class="line">        <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">        <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">        <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">        <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里声明一些必须要传的参数「规定这些参数是必须传的，这里只是举例，再实中可能参数都是可选的」</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ComputerBuilder</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,String graphicsCard)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">            <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">            <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">            <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	... 其它的一些 setXXX() 方法</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 生成最终的产品</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerB <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComputerB(<span class="keyword">this</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码注释非常详细，乍一看好像和建造者模式没有毛关系，但是我们细细一分析这个确实是一个建造者模式，我们看一看：产品是–&gt;ComputerB,具体的建造者是一个静态内存类–&gt;ComputerBuilder,但是没有抽象的建造者和指挥者「其实 ComputerB 充当的就是指挥者的角色」，我们说过建造者模式中 <strong>指挥者</strong> 和 <strong>抽象建造者</strong> 都不是必须的，所以这是一个典型的建造者模式</p>
<ul>
<li>测试类 Test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用建造者模式</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(<span class="string">"主板"</span>,<span class="string">"cpu"</span>,<span class="string">"hd"</span>,<span class="string">"电源"</span>,<span class="string">"显卡"</span></span><br><span class="line">        ,<span class="string">"鼠标"</span>,<span class="string">"机箱"</span>,<span class="string">"鼠标垫"</span>) ;</span><br><span class="line">        System.out.println(<span class="string">"使用普通的构造方法组装电脑："</span>+computer.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用建造者模式</span></span><br><span class="line">        ComputerB computerB = <span class="keyword">new</span> ComputerB.ComputerBuilder(<span class="string">"主板"</span>,<span class="string">"cpu"</span>,<span class="string">"hd"</span>,<span class="string">"电源"</span>,<span class="string">"显卡"</span>)</span><br><span class="line">                .setMouse(<span class="string">"鼠标"</span>).setMousePad(<span class="string">"垫子"</span>).build() ;</span><br><span class="line">        System.out.println(<span class="string">"使用建造者模式组装电脑："</span>+computerB.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-建造者模式的优缺点"><a class="header-anchor" href="#三-建造者模式的优缺点">¶</a>三.建造者模式的优缺点</h2>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>1、使创建产品的步骤「把创建产品步骤放在不同的方法中，更加清晰直观」和产品本身分离，即使用相同的创建过程要吧创建出不同的产品</li>
<li>2、每个建造者都是独立的互不影响，这样就达到解耦的目的，所以如果想要替换现有的建造者那非常方便，添加一个实现即可。</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>1、只适用于产品具有相同的特点「过程和步骤」，如果产品之间差异非常大，则不适用「使用范围受限」</li>
<li>2、万一那天产品内部发生改变，那多个建造者都要修改，成本太大</li>
</ul>
<h2 id="四-建造者模式-VS-简单工厂模式"><a class="header-anchor" href="#四-建造者模式-VS-简单工厂模式">¶</a>四.建造者模式 VS 简单工厂模式</h2>
<blockquote>
<p>相似点</p>
</blockquote>
<p>它们都属于创建型模式【都是创建产品的】</p>
<blockquote>
<p>区别</p>
</blockquote>
<ul>
<li>1、创建对象的粒度不同</li>
</ul>
<p>工厂模式创建的对象都是一个鸟样子，而建造者模式创建的是一个复合产品，由各个复杂的部件组成，部件不同所构成的产品也不同</p>
<ul>
<li>2、关注点不同：</li>
</ul>
<p>工厂模式注重只要把这个对象创建出来就 o 了「不关心这个产品的组成部分」，而建造者模式不似要创造出这个产品，还有知道这个产品的组成部分</p>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>
<p>JavaMail的<code>MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code>MimeMessage</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">textpart.setContent(body, <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> ByteArrayDataSource(input, <span class="string">"application/octet-stream"</span>)));</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br><span class="line"></span><br><span class="line">MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">"me@example.com"</span>));</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(<span class="string">"xiaoming@somewhere.com"</span>));</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.setSubject(<span class="string">"Hello"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.setContent(multipart);</span><br></pre></td></tr></table></figure>
<p>很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(secure ? <span class="string">"https://"</span> : <span class="string">"http://"</span>)</span><br><span class="line">       .append(<span class="string">"www.liaoxuefeng.com"</span>)</span><br><span class="line">       .append(<span class="string">"/"</span>)</span><br><span class="line">       .append(<span class="string">"?t=0"</span>);</span><br><span class="line">String url = builder.toString();</span><br></pre></td></tr></table></figure>
<p>由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = URLBuilder.builder() <span class="comment">// 创建Builder</span></span><br><span class="line">        .setDomain(<span class="string">"www.liaoxuefeng.com"</span>) <span class="comment">// 设置domain</span></span><br><span class="line">        .setScheme(<span class="string">"https"</span>) <span class="comment">// 设置scheme</span></span><br><span class="line">        .setPath(<span class="string">"/"</span>) <span class="comment">// 设置路径</span></span><br><span class="line">        .setQuery(Map.of(<span class="string">"a"</span>, <span class="string">"123"</span>, <span class="string">"q"</span>, <span class="string">"K&amp;R"</span>)) <span class="comment">// 设置query</span></span><br><span class="line">        .build(); <span class="comment">// 完成build</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常量池</title>
    <url>/2020/03/13/Java%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/1450501" target="_blank" rel="noopener">Java常量池</a></p>
<p><a href="https://blog.csdn.net/zm13007310400/article/details/77534349" target="_blank" rel="noopener">Java中的常量池(字符串常量池、class常量池和运行时常量池)</a></p>
<p><a href="https://www.jianshu.com/p/c7f47de2ee80" target="_blank" rel="noopener">Java常量池理解与总结</a></p>
<p>Java 中的常量池主要分为 <strong>Class文件常量池</strong>，<strong>运行时常量池</strong>，<strong>全局字符串常量池</strong></p>
<h1>Class 文件常量池</h1>
<p>class 文件是一组以字节为单位的二进制数据流，在 java 在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 class文件中存在常量池（非运行时常量池），其在编译阶段就已经确定。</p>
<a id="more"></a>
<p>通过一个简单的例子说明情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0x101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> temp = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = temp + v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 javac 命令编译之后，用 javap -v 命令查看编译后的文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">developer</span>.<span class="title">es</span>.<span class="title">test</span>.<span class="title">demo</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#30         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #5.#31         // org/developer/es/test/demo.value:I</span><br><span class="line">   #3 = String             #32            // abc</span><br><span class="line">   #4 = Fieldref           #5.#33         // org/developer/es/test/demo.s:Ljava/lang/String;</span><br><span class="line">   #5 = Class              #34            // org/developer/es/test/demo</span><br><span class="line">   #6 = Class              #35            // java/lang/Object</span><br><span class="line">   #7 = Utf8               value</span><br><span class="line">   #8 = Utf8               I</span><br><span class="line">   #9 = Utf8               s</span><br><span class="line">  #10 = Utf8               Ljava/lang/String;</span><br><span class="line">  #11 = Utf8               f</span><br><span class="line">  #12 = Utf8               ConstantValue</span><br><span class="line">  #13 = Integer            257</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lorg/developer/es/test/demo;</span><br><span class="line">  #21 = Utf8               setValue</span><br><span class="line">  #22 = Utf8               (I)V</span><br><span class="line">  #23 = Utf8               v</span><br><span class="line">  #24 = Utf8               temp</span><br><span class="line">  #25 = Utf8               MethodParameters</span><br><span class="line">  #26 = Utf8               getValue</span><br><span class="line">  #27 = Utf8               ()I</span><br><span class="line">  #28 = Utf8               SourceFile</span><br><span class="line">  #29 = Utf8               demo.java</span><br><span class="line">  #30 = NameAndType        #14:#15        // "&lt;init&gt;":()V</span><br><span class="line">  #31 = NameAndType        #7:#8          // value:I</span><br><span class="line">  #32 = Utf8               abc</span><br><span class="line">  #33 = NameAndType        #9:#10         // s:Ljava/lang/String;</span><br><span class="line">  #34 = Utf8               org/developer/es/test/demo</span><br><span class="line">  #35 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>
<p>class 文件常量池主要存放两大常量：<strong>字面量和符号引用</strong></p>
<ol>
<li>字面量：字面量接近java语言层面的常量概念，主要包括：</li>
</ol>
<ul>
<li><strong>文本字符串</strong>，也就是我们经常申明的： public String s = “abc”;中的&quot;abc&quot;</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#9 = Utf8               s</span><br><span class="line">#3 = String             #31            // abc</span><br><span class="line">#31 = Utf8              abc</span><br></pre></td></tr></table></figure>
<ul>
<li>用final修饰的成员变量，包括静态变量、实例变量和局部变量</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#11 = Utf8               f</span><br><span class="line"> #12 = Utf8               ConstantValue</span><br><span class="line"> #13 = Integer            257</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>符号引用 符号引用主要设涉及编译原理方面的概念，包括下面三类常量:</li>
</ol>
<ul>
<li>类和接口的全限定名，也就是java/lang/String;这样，将类名中原来的&quot;.“替换为”/&quot;得到的，主要用于在运行时解析得到类的直接引用，像上面</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#5 = Class              #33            // JavaBasicKnowledge/JavaBean</span><br><span class="line"> #33 = Utf8               JavaBasicKnowledge/JavaBean</span><br></pre></td></tr></table></figure>
<ul>
<li>字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量和实例级的变量</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I</span><br><span class="line"> #5 = Class              #33            // JavaBasicKnowledge/JavaBean</span><br><span class="line"> #32 = NameAndType       #7:#8          // value:I</span><br><span class="line"></span><br><span class="line"> #7 = Utf8               value</span><br><span class="line"> #8 = Utf8               I</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这两个是局部变量，值保留字段名称</span></span><br><span class="line"> #23 = Utf8               v</span><br><span class="line"> #24 = Utf8               temp</span><br></pre></td></tr></table></figure>
<p>可以看到，对于方法中的局部变量名，class文件的常量池仅仅保存字段名。</p>
<ul>
<li>方法中的名称和描述符，也即参数类型+返回值</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#21 = Utf8               setValue</span><br><span class="line"> #22 = Utf8               (I)V</span><br><span class="line"></span><br><span class="line"> #25 = Utf8               getValue</span><br><span class="line"> #26 = Utf8               ()I</span><br></pre></td></tr></table></figure>
<p><em><strong>什么时字面量和符号引用</strong></em></p>
<ul>
<li>字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量</li>
<li>符号引用：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符</li>
</ul>
<h1>运行时常量池</h1>
<p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过<strong>加载、链接（验证、准备、解析）、初始化</strong>，在第一步加载的时候需要完成：</p>
<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class，它作为方法区这个类的各种数据访问的入口。</li>
</ul>
<p>类对象和普通对象是不同的，类对象是在类加载的时候完成的，是jvm创建的并且是单例的，作为这个类和外界交互的入口， 而普通的对象一般是在调用new之后创建。</p>
<p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下<strong>不同的类共用一个运行时常量池</strong>，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。</p>
<p>运行时常量池的作用是存储java class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p>
<p>运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>常量池</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题汇总</title>
    <url>/2020/03/12/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1>1.如果一条sql执行时间过长，如何优化…</h1>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312230201.png" alt="img"></p>
<a id="more"></a>
<p>1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）</p>
<p>2、涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合</p>
<p>3、如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度</p>
<p>4、针对数量大的表进行历史表分离（如交易流水表）</p>
<p>5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</p>
<p>6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等</p>
<p>7、查看mysql执行日志，看看是否有其他方面的问题</p>
<h1>2.前端通过http请求后端的详细过程</h1>
<p>参考：</p>
<p><a href="https://juejin.im/post/5c3b21e4e51d455231347349#heading-6" target="_blank" rel="noopener">浅析一次HTTP请求</a></p>
<p><a href="https://www.jianshu.com/p/c1d6a294d3c0" target="_blank" rel="noopener">一次完整的HTTP请求与响应涉及了哪些知识？真的讲得好很细</a></p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232201.png" alt="img"></p>
<ul>
<li>Http 请求是依托于 TCP/IP 连接的，第一次连接的时候会进行 TCP 的三次握手</li>
<li>HTTP 通过 Keep-Alive 来进行持久连接，通过定时发送一个心跳包，来告诉服务端自己还活跃</li>
<li>HTTP 连接的断开也会导致TCP的四次挥手，但是如果服务器判断满足条件，会合并 ACK 和 FIN 信号，进而转化为三次挥手。</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232501.png" alt="img"></p>
<p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）</p>
<p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。</p>
<p>通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232701.png" alt="img"></p>
<h2 id="HTTP协议"><a class="header-anchor" href="#HTTP协议">¶</a>HTTP协议</h2>
<h3 id="Http是什么？"><a class="header-anchor" href="#Http是什么？">¶</a>Http是什么？</h3>
<p>通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p>
<p><strong>四个基于：</strong></p>
<p>**请求与响应：**客户端发送请求，服务器端响应数据</p>
<p>**无状态的：**协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</p>
<p>**应用层：**Http是属于应用层的协议，配合TCP/IP使用。</p>
<p>**TCP/IP：**Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</p>
<p><strong>针对无状态的一些解决策略：</strong></p>
<p>有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。</p>
<p>HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。<br>
等等还有很多。。。。。。</p>
<p>下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。</p>
<p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p>
<h2 id="HTTP请求报文"><a class="header-anchor" href="#HTTP请求报文">¶</a>HTTP请求报文</h2>
<p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/1.png" alt="img"></p>
<h3 id="1-请求行"><a class="header-anchor" href="#1-请求行">¶</a>1.请求行</h3>
<p>请求行分为三个部分：请求方法、请求地址和协议版本</p>
<p><strong>请求方法</strong></p>
<p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p>
<p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p>
<p><strong>请求地址</strong></p>
<p>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</p>
<p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</p>
<p><strong>端口和路径有时可以省略（HTTP默认端口号是80）</strong></p>
<p>如下例：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/2.png" alt="img"></p>
<p>有时会带参数，GET请求</p>
<p><strong>协议版本</strong></p>
<p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<h3 id="2-请求头部"><a class="header-anchor" href="#2-请求头部">¶</a>2.请求头部</h3>
<p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p>
<p>常见请求头如下：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/3.png" alt="img"></p>
<p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p>
<h3 id="3-请求数据"><a class="header-anchor" href="#3-请求数据">¶</a>3.请求数据</h3>
<p>可选部分，比如GET请求就没有请求数据。</p>
<p>下面是一个POST方法的请求报文：</p>
<blockquote>
<p>POST 　/index.php　HTTP/1.1                                                                　　 请求行<br>
Host: localhost<br>
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头<br>
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>
Accept-Language: zh-cn,zh;q=0.5<br>
Accept-Encoding: gzip, deflate<br>
Connection: keep-alive<br>
Referer: <a href="https://link.jianshu.com?t=http://localhost/" target="_blank" rel="noopener">http://localhost/</a><br>
Content-Length：25<br>
Content-Type：application/x-www-form-urlencoded<br>
　空行<br>
username=aa&amp;password=1234　　请求数据</p>
</blockquote>
<h2 id="HTTP响应报文"><a class="header-anchor" href="#HTTP响应报文">¶</a>HTTP响应报文</h2>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/4.png" alt="img"></p>
<p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p>
<h3 id="1-状态行"><a class="header-anchor" href="#1-状态行">¶</a>1.状态行</h3>
<p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p>
<p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p>
<p><strong>状态码</strong></p>
<p>状态代码为3位数字。<br>
1xx：指示信息–表示请求已接收，继续处理。<br>
2xx：成功–表示请求已被成功接收、理解、接受。<br>
3xx：重定向–要完成请求必须进行更进一步的操作。<br>
4xx：客户端错误–请求有语法错误或请求无法实现。<br>
5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>下面列举几个常见的：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/5.png" alt="img"></p>
<h3 id="2-响应头部"><a class="header-anchor" href="#2-响应头部">¶</a>2.响应头部</h3>
<p>与请求头部类似，为响应报文添加了一些附加信息</p>
<p>常见响应头部如下：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/6.png" alt="img"></p>
<h3 id="3-响应数据"><a class="header-anchor" href="#3-响应数据">¶</a>3.响应数据</h3>
<p>用于存放需要返回给客户端的数据信息。</p>
<p>下面是一个响应报文的实例：</p>
<blockquote>
<p>HTTP/1.1 200 OK　　状态行</p>
</blockquote>
<p>Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部<br>
Server: Apache/2.2.8 (Win32) PHP/5.2.5<br>
X-Powered-By: PHP/5.2.5<br>
Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/<br>
Expires: Thu, 19 Nov 1981 08:52:00 GMT<br>
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br>
Pragma: no-cache<br>
Content-Length: 4393<br>
Keep-Alive: timeout=5, max=100<br>
Connection: Keep-Alive<br>
Content-Type: text/html; charset=utf-8</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">空行</span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span>&gt;</span>　　响应数据</span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP响应示例<span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> Hello HTTP!</span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于请求头部和响应头部的知识点很多，这里只是简单介绍。</p>
<p>通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接</p>
<h1>3.递归算 n 的阶乘</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Sytem.out.print(rec(m) + <span class="string">" "</span>);</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">rec</span><span class="params">(Integer m)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        m = m * rec( m - <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>4.List 和 Set 的区别</h1>
<p><em><strong>List</strong></em> 和 <em><strong>Set</strong></em> 都继承自 Collection，用来存放数据项集合</p>
<p>区别：</p>
<ol>
<li>List 和 Set 之间有个很重要的区别就是是否允许重复元素的存在，List 中允许插入重复元素，而 Set 不允许重复元素存在，List 中允许插入重复元素，而 Set 不允许重复元素存在</li>
<li>与元素先后存放顺序有关，List 是有序集合，保留元素插入顺序；Set 是无序集合</li>
<li>List 可通过下标访问，而 Set 不能</li>
</ol>
<h1>5.什么是 RESTful API</h1>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/84568e364ee8" target="_blank" rel="noopener">深入理解什么是RESTful API ？</a></p>
<p>REST 全称是 Representational State Transfer (表现层状态转移)</p>
<blockquote>
<p>URL 定位资源，用 HTTP 动词 (GET,POST,DELETE,PUT) 描述操作</p>
</blockquote>
<ul>
<li>**Resource：**资源，即数据。</li>
</ul>
<blockquote>
<p>REST的名称&quot;表现层状态转化&quot;中，省略了主语。“表现层&quot;其实指的是&quot;资源”（Resources）的&quot;表现层&quot;。</p>
</blockquote>
<blockquote>
<p>**所谓&quot;资源&quot;，就是网络上的一个实体，或者说是网络上的一个具体信息。**它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源标识符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
</blockquote>
<ul>
<li>**Representational：**某种表现形式，比如用 JSON, XML, JPEG 等</li>
</ul>
<blockquote>
<p>资源&quot;是一种信息实体，它可以有多种外在表现形式。<strong>我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;（Representation）。</strong></p>
</blockquote>
<blockquote>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
</blockquote>
<blockquote>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的&quot;.html&quot;后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对&quot;表现层&quot;的描述。</p>
</blockquote>
<ul>
<li>**State Transfer：**状态变化。通过 HTTP 动词实现</li>
</ul>
<blockquote>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
</blockquote>
<blockquote>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转化&quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot;。</strong></p>
</blockquote>
<blockquote>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>
</blockquote>
<h2 id="总结："><a class="header-anchor" href="#总结：">¶</a>总结：</h2>
<ul>
<li>每个 URI 代表一个资源</li>
<li>客户端和服务段之间，传递这种资源的某种<em><strong>表现层</strong></em></li>
<li>客户端通过4个HTTP动词，对服务端资源进行操作，实现&quot;表现层状态转化&quot;</li>
</ul>
<h2 id="误区"><a class="header-anchor" href="#误区">¶</a>误区</h2>
<blockquote>
<p>**最常见的一种设计错误，就是URI包含动词。**因为&quot;资源&quot;表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>
</blockquote>
<blockquote>
<p><strong>另一个设计误区，就是在URI中加入版本号</strong></p>
</blockquote>
<h1>6.接口和抽象类的区别</h1>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a></p>
<p><a href="https://www.nowcoder.com/questionTerminal/bdb310cc6e384e78b2564dfd3ba4197c" target="_blank" rel="noopener">抽象类</a></p>
<blockquote>
<p>从设计层面上来说，</p>
<p>抽象是对类的抽象，是一种模板设计；</p>
<p>接口是行为的抽象，是一种行为的规范；</p>
</blockquote>
<h2 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h2>
<p>抽象类和普通类的区别：</p>
<p>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
<p>抽象类不能创建对象</p>
<p>果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</p>
<h2 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h2>
<p>接口可以有 <em><strong>变量</strong></em> 和 <em><strong>方法</strong></em>。</p>
<p>变量 会被隐式指定为 public static final 并且只能是 public static final，<strong>用 private 修饰会报编译错误</strong></p>
<p>方法会被隐式地指定为public abstract方法且只能是public abstract方法**，用其他关键字，比如private、protected、static、 final等修饰会报编译错误**</p>
<p>接口中不能含有 <strong>静态代码块和静态方法</strong></p>
<p>**jdk8 以后，接口也可以有方法体 ，**用 <em><strong>default</strong></em> 修饰的方法体</p>
<h3 id="区别："><a class="header-anchor" href="#区别：">¶</a>区别：</h3>
<blockquote>
<p>抽象类是对整个类整体进行抽象，包括属性、行为;</p>
<p>但是接口却是对类局部（行为）进行抽象。</p>
</blockquote>
<p>一个类只能继承一个抽象类，而一个类却可以实现多个接口</p>
<h1>7.final修饰符的理解</h1>
<p>参考：</p>
<p><a href="http://www.51gjie.com/java/569.html" target="_blank" rel="noopener">Java final关键字</a></p>
<h2 id="final修饰类"><a class="header-anchor" href="#final修饰类">¶</a>final修饰类</h2>
<p>final修饰类即表示此类已经是“最后的、最终的”含义。因此，用final修饰的类<strong>不能被继承</strong>，即<strong>不能拥有自己的子类</strong>。如果试图对一个已经用final修饰的类进行继承，在编译期间或发生错误。</p>
<h2 id="final修饰方法"><a class="header-anchor" href="#final修饰方法">¶</a>final修饰方法</h2>
<p>final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即<strong>此方法不能被重写</strong>（可以重载多个final修饰的方法）。</p>
<p>此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。</p>
<h2 id="final修饰变量"><a class="header-anchor" href="#final修饰变量">¶</a>final修饰变量</h2>
<p>final修饰的变量表示此变量是“最后的、最终的”含义。一旦定义了final变量并在首次为其显示初始化后，<strong>final修饰的变量值不可被改变</strong>(即不能再赋值)。</p>
<p>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</p>
<h1>8.Java创建对象的方式</h1>
<ol>
<li><strong>使用 new 关键字</strong></li>
<li><strong>使用反射的 Class 类的 newInstance() 方法</strong>：ObjectName obj = ObjectName.class.newInstance();</li>
<li><strong>使用反射的 Constructor 类的 newInstance() 方法</strong>：ObjectName obj = ObjectName.class.getConstructor.newInstance();</li>
<li><strong>使用对象的克隆 clone() 方法</strong>：ObjectName obj = obj.clone();</li>
<li><strong>使用反序列化（ObjectInputStream）的readObject()方法</strong>： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</li>
</ol>
<h1>9.重写和重载区别(高频)</h1>
<ul>
<li>重写</li>
</ul>
<blockquote>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变</p>
</blockquote>
<p><strong>外壳不变，核心重写</strong></p>
<ul>
<li>重载</li>
</ul>
<blockquote>
<p>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表</p>
</blockquote>
<h1>10.collection 和 collections的区别</h1>
<ul>
<li>Collection</li>
</ul>
<blockquote>
<p>java.util.Collection 是一个 <strong>集合接口</strong>。它提供了对集合对象进行基本操作的通用接口方法</p>
</blockquote>
<ul>
<li>Collections</li>
</ul>
<blockquote>
<p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的<strong>静态多态方法</strong></p>
<p>此类 <strong>不能实例化</strong>，就像一个 <strong>工具类</strong>, 服务于 Java 的 Collection 类</p>
</blockquote>
<h1>11.Thread的 join()</h1>
<p>转载自：</p>
<p><a href="https://www.cnblogs.com/huangzejun/p/7908898.html" target="_blank" rel="noopener">Java 浅析 Thread.join()</a></p>
<blockquote>
<p>当一个线程必须等待另一个线程执行完毕才能执行时，Thread 类提供了 join 这个方法来完成这个功能</p>
</blockquote>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建child对象，此时child表示的线程处于NEW状态</span></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        <span class="comment">// child表示的线程转换为RUNNABLE状态</span></span><br><span class="line">        child.start();</span><br><span class="line">        <span class="comment">// 等待child线程运行完再继续运行</span></span><br><span class="line">        child.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码展示了两个类：Parent（父线程类），Child（子线程类）。</p>
<p>Parent.main()方法是程序的入口，通过 Child child = new Child(); 新建child子线程（此时 child子线程处于NEW状态）；</p>
<p>然后调用child.start()（child子线程状态转换为RUNNABLE）；</p>
<p>再调用child.join()，此时，Parent父线程会等待child子线程运行完再继续运行。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/33.png" alt="Java-thread-state-transition"></p>
<h1>12.mybatis 动态标签</h1>
<ul>
<li><strong>if</strong></li>
<li><strong>where</strong></li>
<li><strong>choose</strong></li>
<li><strong>when</strong></li>
<li><strong>otherwise</strong></li>
<li><strong>trim</strong></li>
<li><strong>set</strong></li>
<li><strong>foreach</strong></li>
</ul>
<h1>13.JDBC 控制事务</h1>
<p>参考：<a href="https://www.yiibai.com/jdbc/jdbc-transactions.html" target="_blank" rel="noopener">JDBC事务</a></p>
<p>事务能够控制何时更改提交并应用于数据库。它将单个 SQL 语句或一组 SQL 语句视为一个逻辑单元，如果任何语句失败，整个事务将失败。</p>
<p>要启用手动事务支持，而不是使用 JDBC 驱动程序默认使用的自动提交模式，请调用 <code>Connection</code> 对象的<code>setAutoCommit()</code>方法。 如果将布尔的<code>false</code>传递给<code>setAutoCommit()</code>，则关闭自动提交。 也可以传递一个布尔值<code>true</code>来重新打开它。</p>
<p>例如，如果有一个名为<code>conn</code>的<code>Connection</code>对象，请将以下代码关闭自动提交 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="提交和回滚"><a class="header-anchor" href="#提交和回滚">¶</a>提交和回滚</h2>
<p>如果JDBC连接处于自动提交模式，默认情况下，则每个SQL语句在完成后都会提交到数据库。</p>
<p>对于简单的应用程序可能没有问题，但是有三个原因需要考虑是否关闭自动提交并管理自己的事务 -</p>
<ul>
<li>提高性能</li>
<li>保持业务流程的完整性</li>
<li>使用分布式事务</li>
</ul>
<p>事务能够控制何时更改提交并应用于数据库。 它将单个SQL语句或一组SQL语句视为一个逻辑单元，如果任何语句失败，整个事务将失败。</p>
<p>要启用手动事务支持，而不是使用JDBC驱动程序默认使用的自动提交模式，请调用<code>Connection</code>对象的<code>setAutoCommit()</code>方法。 如果将布尔的<code>false</code>传递给<code>setAutoCommit()</code>，则关闭自动提交。 也可以传递一个布尔值<code>true</code>来重新打开它。</p>
<p>例如，如果有一个名为<code>conn</code>的<code>Connection</code>对象，请将以下代码关闭自动提交 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>完成更改后，若要提交更改，那么可在连接对象上调用<code>commit()</code>方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.commit( );</span><br></pre></td></tr></table></figure>
<p>否则，要使用连接名为<code>conn</code>的数据库回滚更新，请使用以下代码 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.rollback( );</span><br></pre></td></tr></table></figure>
<p>以下示例说明了如何使用提交和回滚对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Assume a valid connection object conn</span></span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    String SQL = <span class="string">"INSERT INTO Employees  "</span> +</span><br><span class="line">        <span class="string">"VALUES (106, 20, 'Rita', 'Tez')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);  </span><br><span class="line">    <span class="comment">//Submit a malformed SQL statement that breaks</span></span><br><span class="line">    String SQL = <span class="string">"INSERTED IN Employees  "</span> +</span><br><span class="line">        <span class="string">"VALUES (107, 22, 'Sita', 'Singh')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);</span><br><span class="line">    <span class="comment">// If there is no error.</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">    <span class="comment">// If there is any error.</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，上述<code>INSERT</code>语句不会成功执行，因为所有操作都被回滚了。</p>
<h2 id="使用保存点"><a class="header-anchor" href="#使用保存点">¶</a>使用保存点</h2>
<p>新的 JDBC3.0 新添加了 <code>Savepoint</code> 接口提供了额外的事务控制能力。大多数现代 DBMS 支持其环境中的保存点，如 Oracle 的 PL/SQL。</p>
<p>设置保存点(<code>Savepoint</code>)时，可以在事务中定义逻辑回滚点。 如果通过保存点(<code>Savepoint</code>)发生错误时，则可以使用回滚方法来撤消所有更改或仅保存保存点之后所做的更改。</p>
<p><strong>Connection</strong> 对象有两种新的方法可用来管理保存点</p>
<ul>
<li>**setSavepoint(String savepointName)：**定义新的保存点，它还返回一个 <code>Savepoint</code> 对象</li>
<li>**releaseSavepoint(Savepoint savepointName)：**删除保存点。要注意，他需要一个 <code>Savepoint</code>对象作为参数。 该对象通常是由<code>setSavepoint()</code>方法生成的保存点。</li>
</ul>
<p>有一个*rollback (String savepointName)*方法，它将使用事务回滚到指定的保存点。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Assume a valid connection object conn</span></span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set a Savepoint</span></span><br><span class="line">    Savepoint savepoint1 = conn.setSavepoint(<span class="string">"Savepoint1"</span>);</span><br><span class="line">    String SQL = <span class="string">"INSERT INTO Employees "</span> +</span><br><span class="line">        <span class="string">"VALUES (106, 24, 'Curry', 'Stephen')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);  </span><br><span class="line">    <span class="comment">//Submit a malformed SQL statement that breaks</span></span><br><span class="line">    String SQL = <span class="string">"INSERTED IN Employees "</span> +</span><br><span class="line">        <span class="string">"VALUES (107, 32, 'Kobe', 'Bryant')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);</span><br><span class="line">    <span class="comment">// If there is no error, commit the changes.</span></span><br><span class="line">    conn.commit();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">    <span class="comment">// If there is any error.</span></span><br><span class="line">    conn.rollback(savepoint1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>14.finalize()</h1>
<p><em><strong>finalize() 已经在 Java9 中不被推荐使用，明确在 Object.finalize() 标记为 deprecated</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment">     * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment">     * A subclass overrides the &#123;<span class="doctag">@code</span> finalize&#125; method to dispose of</span></span><br><span class="line"><span class="comment">     * system resources or to perform other cleanup.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of &#123;<span class="doctag">@code</span> finalize&#125; is that it is invoked</span></span><br><span class="line"><span class="comment">     * if and when the Java&amp;trade; virtual</span></span><br><span class="line"><span class="comment">     * machine has determined that there is no longer any</span></span><br><span class="line"><span class="comment">     * means by which this object can be accessed by any thread that has</span></span><br><span class="line"><span class="comment">     * not yet died, except as a result of an action taken by the</span></span><br><span class="line"><span class="comment">     * finalization of some other object or class which is ready to be</span></span><br><span class="line"><span class="comment">     * finalized. The &#123;<span class="doctag">@code</span> finalize&#125; method may take any action, including</span></span><br><span class="line"><span class="comment">     * making this object available again to other threads; the usual purpose</span></span><br><span class="line"><span class="comment">     * of &#123;<span class="doctag">@code</span> finalize&#125;, however, is to perform cleanup actions before</span></span><br><span class="line"><span class="comment">     * the object is irrevocably discarded. For example, the finalize method</span></span><br><span class="line"><span class="comment">     * for an object that represents an input/output connection might perform</span></span><br><span class="line"><span class="comment">     * explicit I/O transactions to break the connection before the object is</span></span><br><span class="line"><span class="comment">     * permanently discarded.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> finalize&#125; method of class &#123;<span class="doctag">@code</span> Object&#125; performs no</span></span><br><span class="line"><span class="comment">     * special action; it simply returns normally. Subclasses of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Object&#125; may override this definition.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The Java programming language does not guarantee which thread will</span></span><br><span class="line"><span class="comment">     * invoke the &#123;<span class="doctag">@code</span> finalize&#125; method for any given object. It is</span></span><br><span class="line"><span class="comment">     * guaranteed, however, that the thread that invokes finalize will not</span></span><br><span class="line"><span class="comment">     * be holding any user-visible synchronization locks when finalize is</span></span><br><span class="line"><span class="comment">     * invoked. If an uncaught exception is thrown by the finalize method,</span></span><br><span class="line"><span class="comment">     * the exception is ignored and finalization of that object terminates.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * After the &#123;<span class="doctag">@code</span> finalize&#125; method has been invoked for an object, no</span></span><br><span class="line"><span class="comment">     * further action is taken until the Java virtual machine has again</span></span><br><span class="line"><span class="comment">     * determined that there is no longer any means by which this object can</span></span><br><span class="line"><span class="comment">     * be accessed by any thread that has not yet died, including possible</span></span><br><span class="line"><span class="comment">     * actions by other objects or classes which are ready to be finalized,</span></span><br><span class="line"><span class="comment">     * at which point the object may be discarded.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> finalize&#125; method is never invoked more than once by a Java</span></span><br><span class="line"><span class="comment">     * virtual machine for any given object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Any exception thrown by the &#123;<span class="doctag">@code</span> finalize&#125; method causes</span></span><br><span class="line"><span class="comment">     * the finalization of this object to be halted, but is otherwise</span></span><br><span class="line"><span class="comment">     * ignored.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable the &#123;<span class="doctag">@code</span> Exception&#125; raised by this method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.ref.WeakReference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.ref.PhantomReference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 12.6 Finalization of Class Instances</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>由以下这段可知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.A subclass overrides the &#123;<span class="meta">@code</span> finalize&#125; method to dispose of system resources or to perform other cleanup.</span><br><span class="line">    </span><br><span class="line"><span class="comment">//当垃圾回收确定不再存在对对象的引用时，垃圾回收器对对象调用。子类重写&#123;@code finalize&#125;方法以释放系统资源或执行其他清理。</span></span><br></pre></td></tr></table></figure>
<p>该方法会被垃圾回收器处理没有任何引用指向的对象的时候所调用，并且该方法由子类去重写回收对象的实现</p>
<h1>15.crontab 命令</h1>
<blockquote>
<p>Linux crontab 是用来定期执行程序的命令</p>
</blockquote>
<p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<h2 id="命令格式"><a class="header-anchor" href="#命令格式">¶</a>命令格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>
<ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示</li>
</ul>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂模式</title>
    <url>/2020/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1>工厂模式</h1>
<p>参考：<a href="https://juejin.im/entry/58f5e080b123db2fa2b3c4c6" target="_blank" rel="noopener">工厂模式</a></p>
<p>工厂模式分为三种：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<blockquote>
<p>设计模式只是思想，没有固定的代码</p>
</blockquote>
<a id="more"></a>
<h2 id="简单工厂模式"><a class="header-anchor" href="#简单工厂模式">¶</a>简单工厂模式</h2>
<p>简单工厂模式其实并不是一种设计模式，更多的是一种编程习惯</p>
<blockquote>
<p>定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或者接口</p>
</blockquote>
<p><strong>适用场景</strong></p>
<p>其实由定义也大概能推测出其使用场景，首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。</p>
<h3 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h3>
<p>shape.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>圆形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"CircleShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"draw: CircleShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正方形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RectShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(  <span class="string">"RectShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(  <span class="string">"draw: RectShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriangleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"TriangleShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"draw: TriangleShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是工厂类的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ShapeFactory"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Shape shape = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"circle"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> CircleShape();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"rect"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> RectShape();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"triangle"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> TriangleShape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个工厂类中通过传入不同的type可以new不同的形状，<strong>返回结果为Shape 类型</strong>，这个就是简单工厂核心的地方了。</p>
<p>客户端调用</p>
<p>画圆形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"circle"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>
<p>画正方形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"rect"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>
<p>画三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"triangle"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>
<h2 id="工厂方法模式"><a class="header-anchor" href="#工厂方法模式">¶</a>工厂方法模式</h2>
<p>工厂方法模式是简单工厂的进一步深化，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说<strong>每个对象都有一个与之对应的工厂</strong>。</p>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
</blockquote>
<h3 id="实例-v2"><a class="header-anchor" href="#实例-v2">¶</a>实例</h3>
<p>现在需要设计一个这样的图片加载类，它具有多个图片加载器，用来加载jpg，png，gif格式的图片，每个加载器都有一个 read() 方法，用于读取图片。下面我们完成这个图片加载类。</p>
<p>首先完成图片加载器的设计，编写一个加载器的公共接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reader 里面只有一个read（）方法，然后完成各个图片加载器的代码。</p>
<p>Jpg图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read jpg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Png图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PngReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read png"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gif图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GifReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read gif"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们按照定义所说定义一个抽象的工厂接口ReaderFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Reader <span class="title">getReader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面有一个getReader（）方法返回我们的Reader 类，接下来我们把上面定义好的每个图片加载器都提供一个工厂类，这些工厂类实现了ReaderFactory 。</p>
<p>Jpg加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpgReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Png加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PngReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PngReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gif加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GifReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GifReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每个工厂类中我们都通过复写的getReader（）方法返回各自的图片加载器对象。</p>
<p>客户端使用</p>
<p>读取Jpg</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> JpgReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>
<p>读取Png</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> PngReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>
<p>读取Gif</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> GifReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>
<p><strong>适用场景</strong></p>
<p>（1）客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了创建过程。<br>
（2）客户端可以通过子类来指定创建对应的对象。</p>
<h2 id="抽象工厂模式"><a class="header-anchor" href="#抽象工厂模式">¶</a>抽象工厂模式</h2>
<p>抽象工厂模式是一个比较复杂的创建型模式</p>
<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应多个实际工厂，每个实际工厂负责创建多个实际产品。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                ┌────────┐</span><br><span class="line">                             ─ &gt;│ProductA│</span><br><span class="line">┌────────┐    ┌─────────┐   │   └────────┘</span><br><span class="line">│ Client │─ ─&gt;│ Factory │─ ─</span><br><span class="line">└────────┘    └─────────┘   │   ┌────────┐</span><br><span class="line">                   ▲         ─ &gt;│ProductB│</span><br><span class="line">           ┌───────┴───────┐    └────────┘</span><br><span class="line">           │               │</span><br><span class="line">      ┌─────────┐     ┌─────────┐</span><br><span class="line">      │Factory1 │     │Factory2 │</span><br><span class="line">      └─────────┘     └─────────┘</span><br><span class="line">           │   ┌─────────┐ │   ┌─────────┐</span><br><span class="line">            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│</span><br><span class="line">           │   └─────────┘ │   └─────────┘</span><br><span class="line">               ┌─────────┐     ┌─────────┐</span><br><span class="line">           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│</span><br><span class="line">               └─────────┘     └─────────┘</span><br></pre></td></tr></table></figure>
<p>为形状创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实现接口的实体类。</p>
<p><em>Rectangle.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为颜色创建一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Red::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Green::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Blue::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"RED"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"GREEN"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"BLUE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"COLOR"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状工厂</span></span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色工厂</span></span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      Color color1 = colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      Color color2 = colorFactory.getColor(<span class="string">"Green"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">      Color color3 = colorFactory.getColor(<span class="string">"BLUE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合AOP记录接口访问日志</title>
    <url>/2020/03/12/SpringBoot%E6%95%B4%E5%90%88AOP%E8%AE%B0%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/technology/aop_log" target="_blank" rel="noopener">SpringBoot整合AOP</a></p>
<h1>AOP</h1>
<blockquote>
<p>AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程，通过 <strong>预编译</strong> 方式和 <strong>运行期动态代理</strong> 实现程序功能的统一维护的一种技术。利用 AOP 可以对业务逻辑的个部分进行隔离，从而从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
</blockquote>
<a id="more"></a>
<h2 id="AOP的相关术语"><a class="header-anchor" href="#AOP的相关术语">¶</a>AOP的相关术语</h2>
<h3 id="通知-Advice"><a class="header-anchor" href="#通知-Advice">¶</a>通知(Advice)</h3>
<p>通知描述了切面要完成的工作以及何时执行。比如我们的日志切面需要记录每个接口调用时长，就需要在接口调用前后分别记录当前时间，再取差值。</p>
<ul>
<li>前置通知（Before）：在目标方法调用前调用通知功能；</li>
<li>后置通知（After）：在目标方法调用之后调用通知功能，不关心方法的返回结果；</li>
<li>返回通知（AfterReturning）：在目标方法成功执行之后调用通知功能；</li>
<li>异常通知（AfterThrowing）：在目标方法抛出异常后调用通知功能；</li>
<li>环绕通知（Around）：通知包裹了目标方法，在目标方法调用之前和之后执行自定义的行为。</li>
</ul>
<h3 id="连接点-JoinPoint"><a class="header-anchor" href="#连接点-JoinPoint">¶</a>连接点(JoinPoint)</h3>
<p>通知功能被应用的时机，比如接口方法被调用的时候就是日志切面的连接点</p>
<h3 id="切点-Pointcut"><a class="header-anchor" href="#切点-Pointcut">¶</a>切点(Pointcut)</h3>
<p>切点定义了通知功能被应用的范围。比如日志切面的应用范围就是所有接口，即所有controller层的接口方法。</p>
<h3 id="切面-Aspect"><a class="header-anchor" href="#切面-Aspect">¶</a>切面(Aspect)</h3>
<p>切面是通知和切点的结合，定义了何时，何地应用通知功能</p>
<h3 id="引入-Introduction"><a class="header-anchor" href="#引入-Introduction">¶</a>引入(Introduction)</h3>
<p>在无需修改现有类的情况下，向现有的类添加新方法或属性。</p>
<h3 id="织入-Weaving"><a class="header-anchor" href="#织入-Weaving">¶</a>织入(Weaving)</h3>
<p>把切面应用到目标对象并创建新的代理对象的过程。</p>
<h2 id="Spring中使用注解创建切面"><a class="header-anchor" href="#Spring中使用注解创建切面">¶</a>Spring中使用注解创建切面</h2>
<h3 id="相关注解"><a class="header-anchor" href="#相关注解">¶</a><a href="http://www.macrozheng.com/#/technology/aop_log?id=%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3" target="_blank" rel="noopener">相关注解</a></h3>
<ul>
<li>@Aspect：用于定义切面</li>
<li>@Before：通知方法会在目标方法调用之前执行</li>
<li>@After：通知方法会在目标方法返回或抛出异常后执行</li>
<li>@AfterReturning：通知方法会在目标方法返回后执行</li>
<li>@AfterThrowing：通知方法会在目标方法抛出异常后执行</li>
<li>@Around：通知方法会将目标方法封装起来</li>
<li>@Pointcut：定义切点表达式</li>
</ul>
<h3 id="切点表达式"><a class="header-anchor" href="#切点表达式">¶</a><a href="http://www.macrozheng.com/#/technology/aop_log?id=%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">切点表达式</a></h3>
<p>指定了通知被应用的范围，表达式格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(方法修饰符 返回类型 方法所属的包.类名.方法名称(方法参数)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.macro.mall.tiny.controller包中所有类的public方法都应用切面里的通知</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.macro.mall.tiny.controller.*.*(..))</span><br><span class="line"><span class="comment">//com.macro.mall.tiny.service包及其子包下所有类中的所有方法都应用切面里的通知</span></span><br><span class="line">execution(* com.macro.mall.tiny.service..*.*(..))</span><br><span class="line"><span class="comment">//com.macro.mall.tiny.service.PmsBrandService类中的所有方法都应用切面里的通知</span></span><br><span class="line">execution(* com.macro.mall.tiny.service.PmsBrandService.*(..))</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h2>
<p>添加日志信息封装类 WebLog</p>
<blockquote>
<p>用于封装需要记录的日志信息，包括操作的描述、时间、消耗时间、url、请求参数和返回结果等信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.dto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller层的日志封装类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLog</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消耗时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer spendTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IP地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求返回的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加切面类 WebLogAspect</p>
<blockquote>
<p>定义了一个日志切面，在环绕通知中获取日志需要的信息，并应用到controller层中所有的public方法中去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 统一日志处理切面</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/12 17:22</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WebLogAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * org.developer.es.api.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"webLog()"</span>, returning = <span class="string">"ret"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知=前置 + 目标方法执行 + 后置通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取当前请求对象</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        <span class="comment">//记录请求信息</span></span><br><span class="line">        WebLog webLog = <span class="keyword">new</span> WebLog();</span><br><span class="line">        <span class="comment">//proceed 方法就是用于启动目标方法执行</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="comment">//获取被调用的签名</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="comment">//转换为方法签名</span></span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        <span class="comment">//获取 controller 的方法</span></span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        <span class="comment">//如果存在 ApiOperation 注解，获取描述的值</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(ApiOperation<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">            ApiOperation apiOperation = method.getAnnotation(ApiOperation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            webLog.setDescription(apiOperation.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        String urlStr = request.getRequestURL().toString();</span><br><span class="line">        webLog.setBasePath(StrUtil.removeSuffix(urlStr, URLUtil.url(urlStr).getPath()));</span><br><span class="line">        webLog.setIp(request.getRemoteUser());</span><br><span class="line">        webLog.setMethod(request.getMethod());</span><br><span class="line">        webLog.setParameter(getParameter(method, joinPoint.getArgs()));</span><br><span class="line">        webLog.setResult(result);</span><br><span class="line">        webLog.setSpendTime((<span class="keyword">int</span>) (endTime - startTime));</span><br><span class="line">        webLog.setStartTime(startTime);</span><br><span class="line">        webLog.setUri(request.getRequestURI());</span><br><span class="line">        webLog.setUrl(request.getRequestURL().toString());</span><br><span class="line">        logger.info(<span class="string">"&#123;&#125; \n"</span>, JSONUtil.parse(webLog));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据方法和传入的参数获取请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getParameter</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; argList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取方法的参数</span></span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将 RequestBody 注解修饰的参数作为请求参数</span></span><br><span class="line">            RequestBody requestBody = parameters[i].getAnnotation(RequestBody<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(requestBody != <span class="keyword">null</span>)&#123;</span><br><span class="line">                argList.add(args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 RequestParam 注解修饰的参数作为请求参数</span></span><br><span class="line">            RequestParam requestParam = parameters[i].getAnnotation(RequestParam<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (requestParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                String key = parameters[i].getName();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(requestParam.value())) &#123;</span><br><span class="line">                    key = requestParam.value();</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(key, args[i]);</span><br><span class="line">                argList.add(map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> argList.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> argList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200313101900106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313101627277"></p>
<p><img src="https://img-blog.csdnimg.cn/2020031310191371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313101704157"></p>
<p>当执行遇到错误的时候，就会有以下信息</p>
<p><img src="https://img-blog.csdnimg.cn/20200313102657103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313102544808"></p>
<h2 id="拓展"><a class="header-anchor" href="#拓展">¶</a>拓展</h2>
<p><strong>SpringBoot 官方建议使用 logback-spring.xml</strong></p>
<p>logback.xml：应用启动时会直接被日志框架 logback 识别而被使用，不经过 SpringBoot</p>
<p>logback-spring.xml：logback日志框架就不能直接识别到，而会由 Spring Boot 解析此日志配置文件</p>
<h3 id="SpringBoot-加载-logback-spring-xml"><a class="header-anchor" href="#SpringBoot-加载-logback-spring-xml">¶</a>SpringBoot 加载 logback-spring.xml</h3>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/27874182" target="_blank" rel="noopener">Spring Boot中logback配置文件加载过程</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.logging.logback.LogbackLoggingSystem</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getStandardConfigLocations() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"logback-test.groovy"</span>, <span class="string">"logback-test.xml"</span>, <span class="string">"logback.groovy"</span>,</span><br><span class="line">                         <span class="string">"logback.xml"</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这里可以看到spring boot中支持的logback配置文件格式，就是在logback自配置文件（logback-test.xml, logback.xml等）基础上文件名后面加了“-spring”，如logback-test-spring, logback-spring等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the spring config locations for this system. By default this method returns</span></span><br><span class="line"><span class="comment"> * a set of locations based on &#123;<span class="doctag">@link</span> #getStandardConfigLocations()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the spring config locations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getSpringInitializationConfig()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String[] getSpringConfigLocations() &#123;</span><br><span class="line">    String[] locations = getStandardConfigLocations();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">        String extension = StringUtils.getFilenameExtension(locations[i]);</span><br><span class="line">        locations[i] = locations[i].substring(<span class="number">0</span>,</span><br><span class="line">                                              locations[i].length() - extension.length() - <span class="number">1</span>) + <span class="string">"-spring."</span></span><br><span class="line">            + extension;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> locations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>重点关注org.springframework.boot.logging.logback.LogbackLoggingSystem</strong></em></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020Java技术栈</title>
    <url>/2020/03/12/2020Java%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<p>回想飞逝而去的2019，在学生和职场人身份之间的转换，一切匆匆。好像自己的技术栈也没有提升和丰富多少，最近也不断在思考，到底哪里出了问题…</p>
<p>所以先暂时参考下尚硅谷的2020的学习路线吧！</p>
<a id="more"></a>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/18884a1af98c92fcd05324b2c9bc7938c2676bdf.jpg" alt="预览图"></p>
<p>数据的路线</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/1991c1c3921161f01d991cc2b3a0b6a851b9ae52.jpg" alt="img"></p>
<p>目前就暂时以这个标准作为学习的方向吧！奥利给，加油！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像加速地址</title>
    <url>/2020/03/11/Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>由于最近想入门 ELK 框架，所以找到一篇<a href="%5Bhttp://www.macrozheng.com/#/technology/mall_tiny_elk?id=%e5%88%9b%e5%bb%ba%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%ad%98%e6%94%be%e7%9b%ae%e5%bd%95%e5%b9%b6%e4%b8%8a%e4%bc%a0%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%88%b0%e8%af%a5%e7%9b%ae%e5%bd%95%5D(http://www.macrozheng.com/#/technology/mall_tiny_elk?id=%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95%E5%B9%B6%E4%B8%8A%E4%BC%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%B0%E8%AF%A5%E7%9B%AE%E5%BD%95)">大神的文章</a>来练练手。</p>
<p>可是 Docker 的 pull 镜像的速度差点让我吐血了 orz；</p>
<p>后面通过神奇的谷歌搜索，找到了<a href="http://einverne.github.io/post/2018/03/docker-mirror.html" target="_blank" rel="noopener">一篇很不错的文章</a></p>
<a id="more"></a>
<blockquote>
<h2 id="使用-registry-mirrors"><a class="header-anchor" href="#使用-registry-mirrors">¶</a>使用 registry mirrors</h2>
</blockquote>
<p>手动修改 Docker 配置 <code>/etc/docker/daemon.json</code> 文件增加 docker registry 镜像：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"加速地址"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"insecure-registries"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改其中的 <code>加速地址</code>，不同的服务提供的镜像加速地址不一样。</p>
<p>记得修改配置之后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<p>重启 docker。下面就总结一下国内的 Docker 镜像站点。</p>
<p>修改后使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>
<p>来检查配置是否生效。</p>
<p>如果下方公开的镜像速度不佳的话，尝试阿里云的镜像，需要开发者账号。</p>
<h3 id="Docker-cn"><a class="header-anchor" href="#Docker-cn">¶</a>Docker cn</h3>
<p>Docker 官方提供的镜像：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>
<h3 id="Azure"><a class="header-anchor" href="#Azure">¶</a>Azure</h3>
<p>Azure <a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">中国镜像</a> 包括 Docker Hub、GCR、Quay。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//dockerhub.azk8s.cn</span></span><br></pre></td></tr></table></figure>
<h3 id="网易-亲测真的非常有效"><a class="header-anchor" href="#网易-亲测真的非常有效">¶</a>网易(亲测真的非常有效)</h3>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//hub-mirror.c.163.com</span></span><br></pre></td></tr></table></figure>
<h3 id="腾讯"><a class="header-anchor" href="#腾讯">¶</a>腾讯</h3>
<p>腾讯只能在腾讯云上使用：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//mirror.ccs.tencentyun.com</span></span><br></pre></td></tr></table></figure>
<h3 id="科大镜像-ustc"><a class="header-anchor" href="#科大镜像-ustc">¶</a>科大镜像 ustc</h3>
<p><a href="https://mirrors.ustc.edu.cn/help/dockerhub.html" target="_blank" rel="noopener">科大</a> 包括 Docker Hub、GCR、Quay。<a href="http://einverne.github.io/post/2018/03/docker-mirror.html#fn:ustc" target="_blank" rel="noopener">1</a></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//docker.mirrors.ustc.edu.cn</span></span><br></pre></td></tr></table></figure>
<h3 id="七牛"><a class="header-anchor" href="#七牛">¶</a>七牛</h3>
<p><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//<span class="keyword">reg</span>-mirror.qiniu.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>
<h3 id="DaoCloud"><a class="header-anchor" href="#DaoCloud">¶</a>DaoCloud</h3>
<p>DaoCloud <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">提供</a> 的加速地址：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//6ce28dce.m.daocloud.io</span></span><br></pre></td></tr></table></figure>
<p>这个地址不同用户看起开不一样，可以使用我的，也可以自己注册。</p>
<p>这个地址不知道是不是长久地址，不过失效，可以到他的官方<a href="http://6ce28dce.m.daocloud.io/" target="_blank" rel="noopener">网站</a> 查看。</p>
<h3 id="Docker-cn-v2"><a class="header-anchor" href="#Docker-cn-v2">¶</a>Docker cn</h3>
<p>也可以使用 Docker 官方提供的镜像</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>
<p>官网<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">地址</a></p>
<h3 id="个人维护的镜像"><a class="header-anchor" href="#个人维护的镜像">¶</a>个人维护的镜像</h3>
<p><a href="https://mritd.me/2017/03/21/private-maintenance-docker-mirror-registry/" target="_blank" rel="noopener">mritd</a> 反向代理了主流的三大仓库（Docker Hub，<a href="http://gcr.io" target="_blank" rel="noopener">gcr.io</a>，<a href="http://quay.io" target="_blank" rel="noopener">quay.io</a>）。</p>
<h2 id="docker-registries"><a class="header-anchor" href="#docker-registries">¶</a>docker registries</h2>
<p>不得不说的 <a href="http://hub.docker.com" target="_blank" rel="noopener">hub.docker.com</a>，官方提供</p>
<h3 id="daocloud-hub"><a class="header-anchor" href="#daocloud-hub">¶</a>daocloud hub</h3>
<p>这是国内 DaoCloud 公司提供的</p>
<ul>
<li><a href="https://hub.daocloud.io/" target="_blank" rel="noopener">https://hub.daocloud.io/</a></li>
</ul>
<h3 id="gcr-io"><a class="header-anchor" href="#gcr-io">¶</a><a href="http://gcr.io" target="_blank" rel="noopener">gcr.io</a></h3>
<p>可以通过下面的链接查看 <a href="http://gcr.io" target="_blank" rel="noopener">gcr.io</a> 中存在镜像，类似于直接在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 中搜索查看。</p>
<ul>
<li><a href="https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers" target="_blank" rel="noopener">https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers</a></li>
</ul>
<h3 id="阿里云"><a class="header-anchor" href="#阿里云">¶</a>阿里云</h3>
<p>这里是阿里云提供的镜像托管服务</p>
<ul>
<li><a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></li>
</ul>
<p>然后<a href="http://dockone.io/question/1216" target="_blank" rel="noopener">有人</a> 把 <code>gcr.io/google-containers</code> 下所有的 Docker 镜像都同步到了中央库</p>
<ul>
<li><a href="https://hub.docker.com/u/googlecontainer/" target="_blank" rel="noopener">https://hub.docker.com/u/googlecontainer/</a></li>
</ul>
<p>更多的 registry 可以参考<a href="https://github.com/veggiemonk/awesome-docker#registry" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Velocity总结</title>
    <url>/2020/03/11/Velocity%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1>入门示例</h1>
<p>参考：<a href="https://blog.csdn.net/fyyyr/article/details/84839595" target="_blank" rel="noopener">https://blog.csdn.net/fyyyr/article/details/84839595</a></p>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--velocity模板引擎依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写一个模板代码</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package $&#123;package&#125;.controller</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class $&#123;className&#125;Controller&#123;</span><br><span class="line"></span><br><span class="line">    public void get$&#123;Object&#125;()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set$&#123;Object&#125;()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VelocityEngine ve = <span class="keyword">new</span> VelocityEngine();</span><br><span class="line"><span class="comment">//设置资源路径</span></span><br><span class="line">ve.setProperty(RuntimeConstants.RESOURCE_LOADER,<span class="string">"classpath"</span>);</span><br><span class="line">ve.setProperty(<span class="string">"classpath.resource.loader.class"</span>, ClasspathResourceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">ve.init();</span><br><span class="line"></span><br><span class="line"><span class="comment">//载入模板</span></span><br><span class="line">Template t = ve.getTemplate(<span class="string">"templates/controller.java.vm"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义替换规则</span></span><br><span class="line">VelocityContext context = <span class="keyword">new</span> VelocityContext();</span><br><span class="line">context.put(<span class="string">"package"</span>,<span class="string">"org.developer.velocity.api"</span>);</span><br><span class="line">context.put(<span class="string">"className"</span>,<span class="string">"velocityDemo"</span>);</span><br><span class="line">context.put(<span class="string">"Object"</span>,<span class="string">"Value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储合并后的结果</span></span><br><span class="line">StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">t.merge(context,sw);</span><br><span class="line">String r = sw.toString();</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"##r:   \n"</span> +r);</span><br></pre></td></tr></table></figure>
<p>生成结果：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package org.developer.velocity.api.controller</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.<span class="keyword">annotation</span>.<span class="title">RestController</span>;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">velocityDemoController</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    public void getValue()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200311004417510.png" alt="image-20200311004417510"></p>
]]></content>
      <categories>
        <category>Velocity</category>
      </categories>
      <tags>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title>h-g源码解析</title>
    <url>/2020/03/10/h-g%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<ol>
<li>
<p>capitalizeFully 通过指定的符号将所有分隔的字母的首字母大写</p>
</li>
<li>
<p>java.util.Properties 继承自hashtable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li>
<p>IOUtils.closeQuietly(out)</p>
<p>参考：<a href="https://www.jianshu.com/p/4edd1775b983" target="_blank" rel="noopener">commons.io-2.6 closeQuietly()</a></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeable.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>简化了流的关闭操作</strong></em></p>
</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>疫情下的影响</title>
    <url>/2020/03/10/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<p>2020 年伊始，新冠肺炎的汹涌来袭，我相信对于很多人来说的都是触不及防。</p>
<p>不出意外，我也成了这次疫情的 “受害者”。</p>
<p>2020农历新年才过几天，我就收到了前公司的主管的电话，当时兴奋的以为是转正的事宜，没想到的是解聘的通知…,在电话里，公司以 “莫须有” 的罪名把我裁了。很不幸，刚出社会就体验到了生活的冷暖，还记得那天是艳阳高照，春天还未到来，寒风依然猖獗，温暖的阳光照在身上，可是我却感受不到任何温度。</p>
<p>同样的我对几个朋友和同事也进行了交流，以下是他们对这次疫情的反映。</p>
<a id="more"></a>
<ul>
<li>朋友A</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192432.jpg" alt="image"></p>
<ul>
<li>朋友B</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192445.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192445.jpg"></p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192449.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192449.jpg"></p>
<ul>
<li>朋友C</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192453.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192453.jpg"></p>
<p>其实每个人的境遇差不多，在疫情面前，大家都是平等的，只有严守才能最终战胜疫情。</p>
<p>希望等到夏日炎炎的时候，大家都可以约好一起吃雪糕！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎ElasticSearch</title>
    <url>/2020/03/09/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticSearch/</url>
    <content><![CDATA[<h1>ElasticSearch</h1>
<h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2>
<p>参考：<a href="https://mp.weixin.qq.com/s/stC_xMP1n3aQ-0ZNAc3eQA" target="_blank" rel="noopener">elasticsearch基础</a></p>
<blockquote>
<p>Elasticsearch 为开源的、分布式、基于 Restful API、支持 PB 甚至更高数量级的搜索引擎工具。</p>
</blockquote>
<p>文档主要还是参考 es 的官方文档，已经解释说明的非常详尽。<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html</a></p>
<p>Elasticsearch 使用 JavaScript Object Notation（或者 <a href="http://en.wikipedia.org/wiki/Json" target="_blank" rel="noopener"><em>JSON</em></a>）作为文档的序列化格式。JSON 序列化为大多数编程语言所支持，并且已经成为 NoSQL 领域的标准格式。 它简单、简洁、易于阅读。</p>
<table>
<thead>
<tr>
<th>ElasticSearch</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>index 索引</td>
<td>database 数据库</td>
</tr>
<tr>
<td>type 类型</td>
<td>table 表</td>
</tr>
<tr>
<td>document 文档</td>
<td>Row 行</td>
</tr>
<tr>
<td>field 属性</td>
<td>Column 字段</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjXcNvIDv32BMwkVKqicrC8Tk3iciaUjfVTJtYAM9x1CSH2mwBEtlGPmh1L1icpOCbO46RTSqDj4Owjmzw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>从上表中可以看出：</p>
<ol>
<li>MySQL 中的数据库（DataBase），等价于 ES 中的索引（Index）。</li>
<li>MySQL 中一个数据库下面有 N 张表（Table），等价于1个索引 Index 下面有 N 多类型（Type）。</li>
<li>MySQL 中一个数据库表（Table）下的数据由多行（Row）多列（column，属性）组成，等价于1个 Type 由多个文档（Document）和多 Field 组成。</li>
<li>MySQL 中定义表结构、设定字段类型等价于 ES 中的 Mapping。举例说明，在一个关系型数据库里面，Schema 定义了表、每个表的字段，还有表和字段之间的关系。与之对应的，在 ES 中，Mapping 定义索引下的 Type 的字段处理规则，即索引如何建立、索引类型、是否保存原始索引 JSON 文档、是否压缩原始 JSON 文档、是否需要分词处理、如何进行分词处理等。</li>
<li>MySQL 中的增 insert、删 delete、改 update、查 search 操作等价于 ES 中的增 PUT/POST、删 Delete、改 _update、查 GET。其中的修改指定条件的更新 update 等价于 ES 中的 update_by_query，指定条件的删除等价于 ES 中的 delete_by_query。</li>
<li>MySQL 中的 group by、avg、sum 等函数类似于 ES 中的 Aggregations 的部分特性。</li>
<li>MySQL 中的去重 distinct 类似 ES 中的 cardinality 操作。</li>
<li>MySQL 中的数据迁移等价于 ES 中的 reindex 操作。</li>
</ol>
<p>如下是传统的关系型数据库（如Oracle、MySQL）、非关系型的数据库（如 Mongo）所做不到的：</p>
<p>1.传统的关系型数据库虽然能支持类型“like 待检索词”模糊语句匹配，但无法进行全文检索（分词检索）。</p>
<p>这里的全文检索，举例如下。</p>
<p>“text”：“公路局正在治理解放大道路面积水问题”，对于这段待检索的文字，经过细粒度分词后能得出如下的分词结果：</p>
<blockquote>
<p>公路局、公路、路局、路、局正、正在、正、治理、治、理解、理、解放、解、放大、大道、大、道路、道、路面、路、面积、面、积水、积、水、问题</p>
</blockquote>
<p>如果进行全文检索，是针对以上分词后的结果逐个进行匹配，并由得分的高低快速的返回匹配结果。</p>
<p>这点，传统数据库几乎不可能做到。</p>
<p>2.非关系型数据库 Mongo 虽能进行简单的全文检索，但对中文支持的不好、数据量大性能会有问题，这点是在实际应用中总结出的。</p>
<p>查询最简单的语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/1</span><br></pre></td></tr></table></figure>
<p>语法：GET /index/type/id</p>
<p>其实还有许多更复杂的搜索，例如：轻量搜索，高亮搜索，全文搜索等等。</p>
<h3 id="bulk增删改操作"><a class="header-anchor" href="#bulk增删改操作">¶</a>bulk增删改操作</h3>
<blockquote>
<p>bulk api 对 json 的语法，有严格的要求，每个 json 串不能换行，只能放一行，同时一个 json 串和一个 json 串之间，必须有一个换行</p>
</blockquote>
<p>语法如下：</p>
<p>bulk每一个操作要两个json串(delete语法除外)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"action"</span>:<span class="string">"&#123;metadata&#125;"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"data"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"index"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"jluzh"</span>,<span class="attr">"_type"</span>:<span class="string">"person"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"张三"</span>,<span class="attr">"age"</span>:<span class="number">20</span>,<span class="attr">"mail"</span>:<span class="string">"111@qq.com"</span>,<span class="attr">"hobby"</span>:<span class="string">"羽毛球，兵乓球，足球"</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合查询"><a class="header-anchor" href="#组合查询">¶</a>组合查询</h3>
<p>如果查询的结果中有 should 字段，则得分会更加高，也就是相似度更高。</p>
<blockquote>
<p>bool 查询会为每个文档计算相关度评分 _score, 再将所有匹配的 must 和 should 语句的分数 _score 求和，最后除以 must 和 should 语句的总数</p>
<p>must_not 语句不会影响评分；它的作用只是将不相关的文档排除</p>
</blockquote>
<h2 id="入门示例"><a class="header-anchor" href="#入门示例">¶</a>入门示例</h2>
<p>参考：<a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=mall%E6%95%B4%E5%90%88elasticsearch%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">mall整合Elasticsearch实现商品搜索</a></p>
<p>示例出自上面这位大神</p>
<h3 id="知识点铺垫"><a class="header-anchor" href="#知识点铺垫">¶</a>知识点铺垫</h3>
<p>由于SpringBoot 与 elasticsearch 需进行整合，所以不得不提到 Spring Data Elasticsearch</p>
<blockquote>
<p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，它可以避免编写大量的样板代码。</p>
</blockquote>
<p>常用的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标示映射到Elasticsearch文档上的领域对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Document &#123;</span><br><span class="line">    <span class="comment">//索引库名次，mysql中数据库的概念</span></span><br><span class="line">    <span class="function">String <span class="title">indexName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//文档类型，mysql中表的概念</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//默认分片数</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">shards</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line">    <span class="comment">//默认副本数量</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">replicas</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=id" target="_blank" rel="noopener">@Id</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示是文档的id，文档可以认为是mysql中表行的概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=field" target="_blank" rel="noopener">@Field</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Field &#123;</span><br><span class="line">  <span class="comment">//文档中字段的类型</span></span><br><span class="line">    <span class="function">FieldType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FieldType.Auto</span>;</span><br><span class="line">  <span class="comment">//是否建立倒排索引</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">index</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  <span class="comment">//是否进行存储</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">store</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  <span class="comment">//分词器名次</span></span><br><span class="line">    <span class="function">String <span class="title">analyzer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="comment">//为文档自动指定元数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FieldType &#123;</span><br><span class="line">    Text,<span class="comment">//会进行分词并建了索引的字符类型</span></span><br><span class="line">    Integer,</span><br><span class="line">    Long,</span><br><span class="line">    Date,</span><br><span class="line">    Float,</span><br><span class="line">    Double,</span><br><span class="line">    Boolean,</span><br><span class="line">    Object,</span><br><span class="line">    Auto,<span class="comment">//自动判断字段类型</span></span><br><span class="line">    Nested,<span class="comment">//嵌套对象类型</span></span><br><span class="line">    Ip,</span><br><span class="line">    Attachment,</span><br><span class="line">    Keyword<span class="comment">//不会进行分词建立索引的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=sping-data%E6%96%B9%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener">Sping Data方式的数据操作</a></p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=%E7%BB%A7%E6%89%BFelasticsearchrepository%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">继承ElasticsearchRepository接口可以获得常用的数据操作方法</a></p>
<p><img src="http://www.macrozheng.com/images/arch_screen_31.png" alt="img"></p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%A1%8D%E7%94%9F%E6%9F%A5%E8%AF%A2" target="_blank" rel="noopener">可以使用衍生查询</a></p>
<blockquote>
<p>在接口中直接指定查询方法名称便可查询，无需进行实现，如商品表中有商品名称、标题和关键字，直接定义以下查询，就可以对这三个字段进行全文搜索。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索查询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name              商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subTitle          商品标题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keywords          商品关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page              分页信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;EsProduct&gt; <span class="title">findByNameOrSubTitleOrKeywords</span><span class="params">(String name, String subTitle, String keywords, Pageable page)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在idea中直接会提示对应字段</p>
</blockquote>
<p><img src="http://www.macrozheng.com/images/arch_screen_32.png" alt="img"></p>
<h3 id="开始"><a class="header-anchor" href="#开始">¶</a>开始</h3>
<p>引入相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Elasticsearch相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!--Swagger-UI API文档生产工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">repositories:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">elasticsearch</span> <span class="comment"># es集群的名称</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure>
<p><em><strong>添加商品文档对象 EsProduct</strong></em></p>
<blockquote>
<p>不需要中文分词的字段设置成@Field(type = FieldType.Keyword)类型，需要中文分词的设置成@Field(analyzer = “ik_max_word”,type = FieldType.Text)类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.nosql.elasticsearch.document;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索中的商品信息</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/6/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"pms"</span>, type = <span class="string">"product"</span>,shards = <span class="number">1</span>,replicas = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsProduct</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String productSn;</span><br><span class="line">    <span class="keyword">private</span> Long brandId;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line">    <span class="keyword">private</span> Long productCategoryId;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String productCategoryName;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String subTitle;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String keywords;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer sale;</span><br><span class="line">    <span class="keyword">private</span> Integer newStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer recommandStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="keyword">private</span> Integer promotionType;</span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line">    <span class="meta">@Field</span>(type =FieldType.Nested)</span><br><span class="line">    <span class="keyword">private</span> List&lt;EsProductAttributeValue&gt; attrValueList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了所有getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=%E6%B7%BB%E5%8A%A0esproductrepository%E6%8E%A5%E5%8F%A3%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9Celasticsearch" target="_blank" rel="noopener">添加EsProductRepository接口用于操作Elasticsearch</a></p>
<blockquote>
<p>继承ElasticsearchRepository接口，这样就拥有了一些基本的Elasticsearch数据操作方法，同时定义了一个衍生查询方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.nosql.elasticsearch.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.nosql.elasticsearch.document.EsProduct;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品ES操作类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/6/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EsProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">EsProduct</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name              商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subTitle          商品标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keywords          商品关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page              分页信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Page&lt;EsProduct&gt; <span class="title">findByNameOrSubTitleOrKeywords</span><span class="params">(String name, String subTitle, String keywords, Pageable page)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它请参照大神的项目：<a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-06" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-06</a></p>
<p>具体流程：</p>
<p>模拟搜索商品的业务流程，先将数据库中所有的商品信息导入到es中，再通过es的分词方法，通过keyword 快速找到商品的相应的信息。</p>
<h1>Logstash</h1>
<p>可以把 Logstash 理解成流入，流出 Elasticsearch 的传送带</p>
<p>支持：不同类型的数据或实施数据流经过 Logstash 写入 ES 或者从 ES 中读出写入文件或对应的实施数据流。</p>
<p>包括但不限于：</p>
<ul>
<li>本地或远程文件；</li>
<li>Kafka 实时数据流——核心插件有 logstashinputkafka/logstashoutputkafka；</li>
<li>MySQL、Oracle 等关系型数据库——核心插件有 logstashinputjdbc/logstashouputjdbc；</li>
<li>Mongo 非关系型数据库——核心插件有 logstashinputmongo/logstashoutputmongo；</li>
<li>Redis 数据流；</li>
<li>……</li>
</ul>
<h1>Kibana 认知</h1>
<blockquote>
<p>Kibana 是 ES 大数据的图形化展示工具。集成了 DSL 命令行查看、数据处理插件、继承了 x-pack（收费）安全管理插件等。</p>
</blockquote>
<h1>Beats(轻量型数据采集器)</h1>
<blockquote>
<p>Beats 平台集合了多种单一用途采集器，它们从成百上千台机器和系统向 Logstash 或 Elasticsearch 发送数据</p>
</blockquote>
<p>数据流程图</p>
<p><img src="https://images2018.cnblogs.com/blog/874963/201808/874963-20180808170444229-5723261.png" alt="img"></p>
<p>Beats 的组件</p>
<p><img src="D:%5Ctypora%5Cnotes%5Casset%5Cimage-20200309215925095.png" alt="image-20200309215925095"></p>
<h2 id="FileBeat"><a class="header-anchor" href="#FileBeat">¶</a>FileBeat</h2>
<p>轻量型日志采集器</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>LongStream实现Fibonacci数列</title>
    <url>/2020/03/09/LongStream%E5%AE%9E%E7%8E%B0Fibonacci%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322655160467490" target="_blank" rel="noopener">创建Stream</a></p>
<p>在学习 Java8 的 Stream 的时候，发现廖雪峰的网站上有一道题挺有意思，顺便可以练练手。</p>
<ul>
<li>编写一个能输出斐波拉契数列（Fibonacci）的<code>LongStream</code>：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, ...</span><br></pre></td></tr></table></figure>
<p>最后捣鼓出来的答案：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Learn Java from https://www.liaoxuefeng.com/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mikelv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		LongStream fib = LongStream.generate(<span class="keyword">new</span> FibSupplier());</span><br><span class="line">		<span class="comment">// 打印Fibonacci数列：1，1，2，3，5，8，13，21...</span></span><br><span class="line">		fib.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibSupplier</span> <span class="keyword">implements</span> <span class="title">LongSupplier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAsLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sum = x + y;</span><br><span class="line">		x = y;</span><br><span class="line">		y = sum;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比之前网上的常用的实现方法确实简洁了不少，而且更易于理解。代码地址：<a href="https://gitee.com/mikeLv01/stream-fibonacci-demo" target="_blank" rel="noopener">https://gitee.com/mikeLv01/stream-fibonacci-demo</a></p>
<p>转载：<a href="https://blog.csdn.net/blue_hh/article/details/75453603" target="_blank" rel="noopener">大龙湖畔</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.homework.lhh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"斐波那契数列前20项的值如下："</span>);</span><br><span class="line">        System.out.print(num[<span class="number">0</span>]+<span class="string">" "</span>+num[<span class="number">1</span>]+<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            num[i] = num[i - <span class="number">1</span>] + num[i - <span class="number">2</span>];</span><br><span class="line">            System.out.print(num[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2>
<blockquote>
<h3 id="基于-Supplier"><a class="header-anchor" href="#基于-Supplier">¶</a>基于 Supplier</h3>
</blockquote>
<p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>
<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> NatualSupplier());</span><br><span class="line">        <span class="comment">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class="line">        natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NatualSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>如果用<code>List</code>表示，即便在<code>int</code>范围内，也会占用巨大的内存，而<code>Stream</code>几乎不占用空间，<em><strong>因为每个元素都是实时计算出来的，用的时候再算</strong></em>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8-Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性</title>
    <url>/2020/03/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="函数式接口"><a class="header-anchor" href="#函数式接口">¶</a>函数式接口</h2>
<p>函数式接口(Functional Interface)就是一个<em><strong>有且仅有一个抽象方法</strong></em>，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为 lambda 表达式。方法引用是 lambda 表达式的另一种表现形式</p>
<h2 id="Lambda"><a class="header-anchor" href="#Lambda">¶</a>Lambda</h2>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/8b4e578ecf58" target="_blank" rel="noopener">Lambda表达式学习（一）为什么使用Lambda表达式？</a></p>
<p><a href="https://www.cnblogs.com/WJ5888/p/4667086.html" target="_blank" rel="noopener">Java 8 Lambda实现原理分析</a></p>
<p>代码简介程度：外部类 &gt; 内部类 &gt; 匿名内部类 &gt; lambda &gt; 方法引用</p>
<p>这里不得不提及下 <em><strong>匿名内部类</strong></em></p>
<p>参考自：<a href="https://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="noopener">java提高篇(十)-----详解匿名内部类</a></p>
<blockquote>
<p>省去了实现类，直接<strong>new 接口名(){…}</strong> 没有实现类名，实际就是实现且创建了一个接口对象。</p>
<p>匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类</p>
<p>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。</p>
</blockquote>
<p>Lambad 表达式首先会被编译为一个 <strong>私有的静态函数</strong></p>
<p>其后，会生成一个 <strong>内部类</strong></p>
<a id="more"></a>
<h2 id="Stream"><a class="header-anchor" href="#Stream">¶</a>Stream</h2>
<p>转载：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889" target="_blank" rel="noopener">使用Stream</a></p>
<p>Java8 开始，不但引入 Lambada 表达式，还引入了一个全新的流式 API：<strong>Stream API</strong>。它位于 <code>java.util.stream</code> 包中。</p>
<p><em>划重点</em>：这个<code>Stream</code>不同于<code>java.io</code>的<code>InputStream</code>和<code>OutputStream</code>，它代表的是<em><strong>任意Java对象的序列</strong></em>。两者对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"><a href="http://java.io" target="_blank" rel="noopener">java.io</a></th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">存储</td>
<td style="text-align:left">顺序读写的<code>byte</code>或<code>char</code></td>
<td>顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td style="text-align:left">用途</td>
<td style="text-align:left">序列化至文件或网络</td>
<td>内存计算／业务逻辑</td>
</tr>
</tbody>
</table>
<p><em>再次划重点</em>：这个<code>Stream</code>和<code>List</code>也不一样，<code>List</code>存储的每个元素都是已经存储在内存中的某个Java对象，而<code>Stream</code>输出的元素可能并没有预先存储在内存中，而是实时计算出来的。</p>
<p>换句话说，<code>List</code>的用途是操作一组已存在的Java对象，而<code>Stream</code>实现的是惰性计算，两者对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">java.util.List</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">元素</td>
<td style="text-align:left">已分配并存储在内存</td>
<td>可能未分配，实时计算</td>
</tr>
<tr>
<td style="text-align:left">用途</td>
<td style="text-align:left">操作一组已存在的Java对象</td>
<td>惰性计算</td>
</tr>
</tbody>
</table>
<p><code>Stream</code>看上去有点不好理解，但我们举个例子就明白了。</p>
<p>如果我们要表示一个全体自然数的集合，显然，用<code>List</code>是不可能写出来的，因为自然数是无限的，内存再大也没法放到<code>List</code>中：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;BigInteger&gt; <span class="built_in">list</span> = ??? <span class="comment">// 全体自然数?</span></span><br></pre></td></tr></table></figure>
<p>但是，用<code>Stream</code>可以做到。写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br></pre></td></tr></table></figure>
<p>我们先不考虑<code>createNaturalStream()</code>这个方法是如何实现的，我们看看如何使用这个<code>Stream</code>。</p>
<p>首先，我们可以对每个自然数做一个平方，这样我们就把这个<code>Stream</code>转换成了另一个<code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br><span class="line">Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); <span class="comment">// 全体自然数的平方</span></span><br></pre></td></tr></table></figure>
<p>因为这个<code>streamNxN</code>也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用<code>limit()</code>方法截取前100个元素，最后用<code>forEach()</code>处理每个元素，这样，我们就打印出了前100个自然数的平方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream();</span><br><span class="line">naturals.map(n -&gt; n.multiply(n)) <span class="comment">// 1, 4, 9, 16, 25...</span></span><br><span class="line">        .limit(<span class="number">100</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>我们总结一下<code>Stream</code>的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>
<p><code>Stream</code>的另一个特点是，一个<code>Stream</code>可以轻易地转换为另一个<code>Stream</code>，而不是修改原<code>Stream</code>本身。</p>
<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s3 = s2.limit(<span class="number">100</span>); <span class="comment">// 不计算</span></span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure>
<p>惰性计算的特点是：一个<code>Stream</code>转换为另一个<code>Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</p>
<p>例如，创建一个全体自然数的<code>Stream</code>，不会进行计算，把它转换为上述<code>s2</code>这个<code>Stream</code>，也不会进行计算。再把<code>s2</code>这个无限<code>Stream</code>转换为<code>s3</code>这个有限的<code>Stream</code>，也不会进行计算。只有最后，调用<code>forEach</code>确实需要<code>Stream</code>输出的元素时，才进行计算。我们通常把<code>Stream</code>的操作写成链式操作，代码更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">createNaturalStream()</span><br><span class="line">    .map(BigInteger::multiply)</span><br><span class="line">    .limit(<span class="number">100</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>因此，Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result = createNaturalStream() <span class="comment">// 创建Stream</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure>
<h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3>
<p>Stream API的特点是：</p>
<ul>
<li>Stream API提供了一套新的流式处理的抽象序列；</li>
<li>Stream API支持函数式编程和链式操作；</li>
<li>Stream可以表示无限序列，并且大多数情况下是惰性求值的。</li>
</ul>
<h3 id="创建Stream"><a class="header-anchor" href="#创建Stream">¶</a>创建Stream</h3>
<p>要使用<code>Stream</code>，就必须现创建它。创建<code>Stream</code>有很多种方法，我们来一一介绍。</p>
<h4 id="Stream-of"><a class="header-anchor" href="#Stream-of">¶</a>Stream.of()</h4>
<p>创建<code>Stream</code>最简单的方式是直接用<code>Stream.of()</code>静态方法，传入可变参数即创建了一个能输出确定元素的<code>Stream</code>：</p>
<p><code>import java.util.stream.Stream; </code> Run</p>
<p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p>
<h4 id="基于数组或Collection"><a class="header-anchor" href="#基于数组或Collection">¶</a>基于数组或Collection</h4>
<p>第二种创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者<code>Collection</code>持有的元素：</p>
<p><code>import java.util.*; import java.util.stream.*; </code> Run</p>
<p>把数组变成<code>Stream</code>使用<code>Arrays.strem()</code>方法。对于<code>Collection</code>（<code>List</code>、<code>Set</code>、<code>Queue</code>等），直接调用<code>stream()</code>方法就可以获得<code>Stream</code>。</p>
<p>上述创建<code>Stream</code>的方法都是把一个现有的序列变为<code>Stream</code>，它的元素是固定的。</p>
<h4 id="基于Supplier"><a class="header-anchor" href="#基于Supplier">¶</a>基于Supplier</h4>
<p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; s = <span class="built_in">Stream</span>.generate(Supplier&lt;<span class="keyword">String</span>&gt; sp);</span><br></pre></td></tr></table></figure>
<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>
<p><code>import java.util.function.*; import java.util.stream.*; </code> Run</p>
<p>上述代码我们用一个<code>Supplier</code>模拟了一个无限序列（当然受<code>int</code>范围限制不是真的无限大）。如果用<code>List</code>表示，即便在<code>int</code>范围内，也会占用巨大的内存，而<code>Stream</code>几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>
<p>对于无限序列，如果直接调用<code>forEach()</code>或者<code>count()</code>这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用<code>limit()</code>方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用<code>forEach()</code>或者<code>count()</code>操作就没有问题。</p>
<h4 id="其他方法"><a class="header-anchor" href="#其他方法">¶</a>其他方法</h4>
<p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p>
<p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"/path/to/file.txt"</span>))) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法对于按行遍历文本文件十分有用。</p>
<p>另外，正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"\\s+"</span>);</span><br><span class="line">Stream&lt;String&gt; s = p.splitAsStream(<span class="string">"The quick brown fox jumps over the lazy dog"</span>);</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="基本类型"><a class="header-anchor" href="#基本类型">¶</a>基本类型</h4>
<p>因为Java的范型不支持基本类型，所以我们无法用<code>Stream</code>这样的类型，会发生编译错误。为了保存<code>int</code>，只能使用<code>String</code>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>，它们的使用方法和范型<code>Stream</code>没有大的区别，设计这三个<code>Stream</code>的目的是提高运行效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int[]数组变为IntStream:</span></span><br><span class="line">IntStream is = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class="line">LongStream ls = List.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure>
<p>创建<code>Stream</code>的方法有 ：</p>
<ul>
<li>通过指定元素、指定数组、指定<code>Collection</code>创建<code>Stream</code>；</li>
<li>通过<code>Supplier</code>创建<code>Stream</code>，可以是无限序列；</li>
<li>通过其他类的相关方法创建。</li>
</ul>
<p>基本类型的<code>Stream</code>有<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code></p>
<h2 id="方法引用"><a class="header-anchor" href="#方法引用">¶</a>方法引用</h2>
<p>转载：</p>
<p><a href="https://www.runoob.com/java/java8-method-references.html" target="_blank" rel="noopener">Java 8 方法引用</a></p>
<p>方法引用通过方法的名字来指向一个方法</p>
<p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>方法引用使用一对冒号 <strong>::</strong> 。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collided "</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Following the "</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>**构造器引用：**它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**静态方法引用：**它的语法是Class::static_method，实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**特定类的任意对象的方法引用：**它的语法是Class::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**特定对象的方法引用：**它的语法是instance::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"> cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>方法引用一般都是调用静态方法，如果是类对象调用的话，就需要进行传参处理，将该对象传递过去</p>
<h2 id="默认方法"><a class="header-anchor" href="#默认方法">¶</a>默认方法</h2>
<p>Java 8 新增了接口的默认方法。</p>
<p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>
<p>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件RabbitMQ</title>
    <url>/2020/03/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/</url>
    <content><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<ol>
<li>
<p>大多应用中，可通过消息服务中间件来提升系统异步通信，扩展解耦能力</p>
</li>
<li>
<p>消息服务中两个重要概念：</p>
<p>​	<strong>消息代理(message broker) 和 目的地(destination)</strong>,当消息发送者发送消息以后，将有消息代理接管，消息代理保证消息传递到指定目的地</p>
</li>
<li>
<p>消息队列主要有两种形式的目的地</p>
<ol>
<li>队列(queue): 点对点消息通信</li>
<li>主题(topic): 发布(publish)/订阅(subscribe) 消息通信</li>
</ol>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200309155537186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h2 id="RabbitMQ"><a class="header-anchor" href="#RabbitMQ">¶</a>RabbitMQ</h2>
<p>RabbitMQ 是一个由 erlang 开发的 AMQP(Advanced Message Queue Protocol) 的开源实现</p>
<h3 id="核心概念"><a class="header-anchor" href="#核心概念">¶</a>核心概念</h3>
<blockquote>
<h4 id="Message"><a class="header-anchor" href="#Message">¶</a>Message</h4>
</blockquote>
<p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key(路由键) , priority，delivery-mode</p>
<blockquote>
<h4 id="Publisher"><a class="header-anchor" href="#Publisher">¶</a>Publisher</h4>
</blockquote>
<p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
<blockquote>
<h4 id="Exchange"><a class="header-anchor" href="#Exchange">¶</a>Exchange</h4>
</blockquote>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<p>Exchange 有4种类型：</p>
<ul>
<li>direct(默认)</li>
<li>fanout</li>
<li>topic</li>
<li>headers</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155601426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Direct 模型</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155616695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>fanout模型(广播模型)</li>
<li>topic(模式匹配模式)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155629666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<h4 id="routeKey"><a class="header-anchor" href="#routeKey">¶</a>routeKey</h4>
</blockquote>
<p>路由Key键，交换器根据这个 key 键将 message 转发到对应的队列中</p>
<h2 id="RabbitListener-和-RabbitHandler"><a class="header-anchor" href="#RabbitListener-和-RabbitHandler">¶</a>@RabbitListener 和 @RabbitHandler</h2>
<p>转载：<a href="https://www.jianshu.com/p/911d987b5f11" target="_blank" rel="noopener">RabbitMQ：@RabbitListener 与 @RabbitHandler 及 消息序列化</a></p>
<ul>
<li>RabbitMQ 的序列化是指 Message 的 body 属性，即我们真正需要传输的内容，<strong>RabbitMQ 抽象出一个 MessageConvert 接口处理消息的序列化</strong>，其实现有 SimpleMessageConverter（默认）、Jackson2JsonMessageConverter 等</li>
<li>当调用了 convertAndSend 方法时会使用 MessageConvert 进行消息的序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"consumer_queue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(<span class="keyword">byte</span>[] message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用 @RabbitListener 注解标记方法，当监听到队列中有消息时则会进行接收并处理</p>
</li>
<li>
<p>@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用</p>
</li>
<li>
<p>@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型</p>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>消息处理方法参数是由 MessageConverter 转化，若使用自定义 MessageConverter 则需要在 RabbitListenerContainerFactory 实例中去设置（默认 Spring 使用的实现是 SimpleRabbitListenerContainerFactory）</li>
<li>消息的 content_type 属性表示消息 body 数据以什么数据格式存储，接收消息除了使用 Message 对象接收消息（包含消息属性等信息）之外，还可直接使用对应类型接收消息 body 内容，但若方法参数类型不正确会抛异常：
<ul>
<li><strong>application/octet-stream</strong>：二进制字节数组存储，使用 byte[]</li>
<li><strong>application/x-java-serialized-object</strong>：java 对象序列化格式存储，使用 Object、相应类型（反序列化时类型应该同包同名，否者会抛出找不到类异常）</li>
<li><strong>text/plain</strong>：文本数据类型存储，使用 String</li>
<li><strong>application/json</strong>：JSON 格式，使用 Object、相应类型</li>
</ul>
</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/9434708-77b9d3222ae376cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="死信队列-dead-message-queue"><a class="header-anchor" href="#死信队列-dead-message-queue">¶</a>死信队列(dead-message-queue)</h2>
<p>转载自: <a href="https://blog.csdn.net/zhangcongyi420/article/details/100126666" target="_blank" rel="noopener">rabbitmq死信队列详解与使用</a></p>
<p>死信,顾名思义就是无法被消费的消息。</p>
<p>一般来说，producer 将消息投递到 broker 或者直接到 queue 里，consumer 从queue 取出消息进行消费，但某些时候由于特定的原因无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列；</p>
<p><em><strong>产生的原因</strong></em></p>
<ul>
<li>消息被拒绝**(basic.reject或basic.nack)并且requeue=false.**</li>
<li>消息 TTL 过期</li>
<li>队列达到最大长度（队列满了，无法再添加数据到mq中）</li>
</ul>
<p><em><strong>处理方式</strong></em></p>
<ol>
<li>丢弃，如果不是很重要，可以选择丢弃</li>
<li>记录死信入库，然后做后续的业务分析或处理</li>
<li>通过死信队列，由负责监听死信的应用程序进行处理</li>
</ol>
<h2 id="入门示例"><a class="header-anchor" href="#入门示例">¶</a>入门示例</h2>
<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_09" target="_blank" rel="noopener">http://www.macrozheng.com/#/architect/mall_arch_09</a></p>
<p>1.添加关键依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息队列相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.application.yml 关键配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># rabbitmq的连接地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># rabbitmq的连接端口号</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">/mall</span> <span class="comment"># rabbitmq的虚拟host</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的用户名</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的密码</span></span><br><span class="line">        <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#如果对异步消息需要回调必须设置为true</span></span><br></pre></td></tr></table></figure>
<p>3.配置消息队列基本信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消息队列枚举配置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:35</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> QueueEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_ORDER_CANCEL(<span class="string">"mall.order.direct"</span>, <span class="string">"mall.order.cancel"</span>, <span class="string">"mall.order.cancel"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知ttl队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_TTL_ORDER_CANCEL(<span class="string">"mall.order.direct.ttl"</span>, <span class="string">"mall.order.cancel.ttl"</span>, <span class="string">"mall.order.cancel.ttl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey;</span><br><span class="line"></span><br><span class="line">    QueueEnum(String exchange, String name, String routeKey) &#123;</span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.routeKey = routeKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.消息队列的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消息队列配置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:38</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单消息实际消费队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">orderDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">orderTtlDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单实际消费队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QueueEnum.QUEUE_ORDER_CANCEL.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列(死信队列)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderTtlQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getName())</span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-exchange"</span>,QueueEnum.QUEUE_ORDER_CANCEL.getExchange())<span class="comment">//到期后转发的交换机</span></span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-routing-key"</span>, QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey())<span class="comment">//到期后转发的路由键</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">orderBinding</span><span class="params">(DirectExchange orderDirect, Queue orderQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderQueue)</span><br><span class="line">                .to(orderDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单延迟队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">orderTtlBinding</span><span class="params">(DirectExchange orderTtlDirect,Queue orderTtlQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderTtlQueue)</span><br><span class="line">                .to(orderTtlDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.取消订单消息的发出者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取消订单消息的发出者</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 12:06</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(CancelOrderSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Long orderId,<span class="keyword">final</span> <span class="keyword">long</span> delayTimes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//给延迟队列发送消息,配置交换器和路由key和队列，自动序列化发送的消息</span></span><br><span class="line">        amqpTemplate.convertAndSend(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange(), QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey(), orderId, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">                <span class="comment">//给消息设置延迟毫秒值</span></span><br><span class="line">                message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LOGGER.info(<span class="string">"send delay message orderId:&#123;&#125;"</span>,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.取消订单消息的处理者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取消订单消息的处理者</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:56</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//RabbitListener 监听队列 mall.order.cancel</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"mall.order.cancel"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CancelOrderReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OmsPortalOrderService portalOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当该类有消息需要处理时，即交给该方法处理</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Long orderId)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"receive delay message orderId:&#123;&#125;"</span>,orderId);</span><br><span class="line">        portalOrderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它可参考大神的项目：<a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-08" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-08</a></p>
<ul>
<li>具体流程</li>
</ul>
<p>是模拟订单下单，下单完成后开启一个延迟消息(<em>sendDelayMessageCancelOrder()</em>)，用于当用户没有付款时取消订单(orderId应该在下单后生成)。 CancelOrderSender 给延迟队列发送消息,配置交换器和路由key和队列(<em>sendMessage()</em>)，自动序列化发送的消息。CancelOrderReceiver 监听消息队列(<u>mall.order.cancel</u>),当有消息的时候接收并消费该消息(<em>cancelOrder()</em>)。</p>
<ul>
<li>运行截图如下所示</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020030915571585.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Swagger</title>
    <url>/2020/03/07/SpringBoot%E6%95%B4%E5%90%88Swagger/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_02" target="_blank" rel="noopener">SpringBoot整合Swagger</a></p>
<h2 id="添加项目依赖"><a class="header-anchor" href="#添加项目依赖">¶</a>添加项目依赖</h2>
<blockquote>
<p>在pom.xml中新增Swagger-UI相关依</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Swagger-UI API文档生产工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1><a href="http://www.macrozheng.com/#/architect/mall_arch_02?id=%E6%B7%BB%E5%8A%A0swagger-ui%E7%9A%84%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">添加Swagger-UI的配置</a></h1>
<blockquote>
<p>添加Swagger-UI的Java配置文件</p>
</blockquote>
<p>注意：Swagger对生成API文档的范围有三种不同的选择</p>
<ul>
<li>生成指定包下面的类的API文档</li>
<li>生成有指定注解的类的API文档</li>
<li>生成有指定注解的方法的API文档</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger2API文档的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            <span class="comment">//为当前包下controller生成API文档</span></span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">"org.developer.es.api.controller"</span>))</span><br><span class="line">            <span class="comment">//为有@Api注解的Controller生成API文档</span></span><br><span class="line">            <span class="comment">//                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span></span><br><span class="line">            <span class="comment">//为有@ApiOperation注解的方法生成API文档</span></span><br><span class="line">            <span class="comment">//                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span></span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            .title(<span class="string">"SwaggerUI演示"</span>)</span><br><span class="line">            .description(<span class="string">"es-demo"</span>)</span><br><span class="line">            .contact(<span class="string">"mikelv"</span>)</span><br><span class="line">            .version(<span class="string">"1.0"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Controller模板</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span>(tags = SwaggerApiConfig.GENERATOR_CONTROLLER)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DDD 模型生成代码, 前端为swagger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"DDD模型生成"</span>,produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/ddd/code"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; generateByDDD(</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"表名"</span>,required = <span class="keyword">true</span>,defaultValue = <span class="string">"a,b"</span>)<span class="meta">@RequestParam</span> String[] tables,</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"表前缀"</span>,required = <span class="keyword">true</span>)<span class="meta">@RequestParam</span> String tablePrefix,</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"包名"</span>,required = <span class="keyword">true</span>)<span class="meta">@RequestParam</span> String pkg,</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"作者"</span>,required = <span class="keyword">true</span>)<span class="meta">@RequestParam</span> String author,</span><br><span class="line">            HttpServletResponse response) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Swagger接口配置类</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerApiConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERATOR_CONTROLLER = <span class="string">"generator controller"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwaggerApiConfig</span><span class="params">(Docket docket)</span></span>&#123;</span><br><span class="line">        docket.tags(<span class="keyword">new</span> Tag(GENERATOR_CONTROLLER,<span class="string">"代码自动生成服务"</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot多数据源切换学习总结</title>
    <url>/2020/03/05/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>主要参考：<a href="https://www.cnblogs.com/shihaiming/p/11067623.html" target="_blank" rel="noopener">SpringBoot之多数据源动态切换数据源</a></p>
<p>其它参考：</p>
<p><a href="https://blog.csdn.net/catoop/article/details/50575038" target="_blank" rel="noopener">Spring Boot 动态数据源(多数据源自动切换)</a></p>
<p><a href="https://blog.csdn.net/qq_37502106/article/details/91044952" target="_blank" rel="noopener">spring boot使用AbstractRoutingDataSource实现动态数据源切换</a></p>
<p><a href="https://www.jianshu.com/p/b158476dd33c" target="_blank" rel="noopener">AbstractRoutingDataSource – Spring提供的轻量级数据源切换方式</a></p>
<p><a href="https://www.jianshu.com/p/a042ff2ee2ae" target="_blank" rel="noopener">【Spring】使用Spring的AbstractRoutingDataSource实现多数据源切换</a></p>
<p><a href="https://www.jianshu.com/p/3c5d7f09dfbd" target="_blank" rel="noopener">ThreadLocal</a></p>
<p><a href="https://juejin.im/post/5ac2eb52518825555e5e06ee" target="_blank" rel="noopener">ThreadLocal就是这么简单</a></p>
<p><a href="https://blog.csdn.net/rainbow702/article/details/52185827" target="_blank" rel="noopener">Spring AOP @Before @Around @After 等 advice 的执行顺序</a></p>
<p><a href="https://blog.csdn.net/u010502101/article/details/78823056" target="_blank" rel="noopener">AspectJ 切面注解中五种通知注解：@Before、@After、@AfterRunning、@AfterThrowing、@Around</a></p>
<p><a href="https://www.xiefayang.com/2019/04/01/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Spring Boot 2.0源码解析-配置绑定</a></p>
<p><a href="http://blog.didispace.com/Spring-Boot-2-0-feature-1-relaxed-binding-2/" target="_blank" rel="noopener">Spring Boot 2.0 新特性（一）：配置绑定 2.0 全解析</a></p>
<p><a href="https://www.cnblogs.com/aheizi/p/7071181.html" target="_blank" rel="noopener">Java注解–实现动态数据源切换</a></p>
<p><a href="https://webfuse.cn/2017/08/10/%E5%88%A9%E7%94%A8Spring%E7%9A%84AbstractRoutingDataSource%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">利用Spring的AbstractRoutingDataSource解决多数据源的问题</a></p>
<a id="more"></a>
<blockquote>
<h3 id="数据源定义"><a class="header-anchor" href="#数据源定义">¶</a>数据源定义</h3>
</blockquote>
<p>Java中的数据源就是连接到数据库的一条路径，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接。DataSource的创建可以有不同的实现。DataSource通常被称为数据源，它包含连接池 和连接池管理 两部分，习惯上也经常把DataSource称为连接池</p>
<blockquote>
<h3 id="SpringBoot-读取配置文件方式"><a class="header-anchor" href="#SpringBoot-读取配置文件方式">¶</a>SpringBoot 读取配置文件方式</h3>
</blockquote>
<p>SpringBoot2.x 开始推荐读取配置文件的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Binder binder = Binder.get(environment);<span class="comment">//简单绑定</span></span><br><span class="line"><span class="keyword">this</span>.defaultDataSourceProperties = binder.bind(<span class="string">"spring.datasource.master"</span>,Map<span class="class">.<span class="keyword">class</span>).<span class="title">get</span>()</span>;</span><br></pre></td></tr></table></figure>
<p><strong>推荐使用 Binder 读取配置文件</strong></p>
<h2 id="AbstractRoutingDataSource"><a class="header-anchor" href="#AbstractRoutingDataSource">¶</a>AbstractRoutingDataSource</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object defaultTargetDataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lenientFallback = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> DataSourceLookup dataSourceLookup = <span class="keyword">new</span> JndiDataSourceLookup();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRoutingDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetDataSources</span><span class="params">(Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDataSources = targetDataSources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTargetDataSource</span><span class="params">(Object defaultTargetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultTargetDataSource = defaultTargetDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLenientFallback</span><span class="params">(<span class="keyword">boolean</span> lenientFallback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lenientFallback = lenientFallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceLookup</span><span class="params">(@Nullable DataSourceLookup dataSourceLookup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSourceLookup = (DataSourceLookup)(dataSourceLookup != <span class="keyword">null</span> ? dataSourceLookup : <span class="keyword">new</span> JndiDataSourceLookup());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.targetDataSources == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'targetDataSources' is required"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resolvedDataSources = <span class="keyword">new</span> HashMap(<span class="keyword">this</span>.targetDataSources.size());</span><br><span class="line">            <span class="keyword">this</span>.targetDataSources.forEach((key, value) -&gt; &#123;</span><br><span class="line">                Object lookupKey = <span class="keyword">this</span>.resolveSpecifiedLookupKey(key);</span><br><span class="line">                DataSource dataSource = <span class="keyword">this</span>.resolveSpecifiedDataSource(value);</span><br><span class="line">                <span class="keyword">this</span>.resolvedDataSources.put(lookupKey, dataSource);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultTargetDataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resolvedDefaultDataSource = <span class="keyword">this</span>.resolveSpecifiedDataSource(<span class="keyword">this</span>.defaultTargetDataSource);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">resolveSpecifiedLookupKey</span><span class="params">(Object lookupKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookupKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">resolveSpecifiedDataSource</span><span class="params">(Object dataSource)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> DataSource) &#123;</span><br><span class="line">            <span class="keyword">return</span> (DataSource)dataSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.dataSourceLookup.getDataSource((String)dataSource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal data source value - only [javax.sql.DataSource] and String supported: "</span> + dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>) ? <span class="keyword">this</span> : <span class="keyword">this</span>.determineTargetDataSource().unwrap(iface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>) || <span class="keyword">this</span>.determineTargetDataSource().isWrapperFor(iface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">        Object lookupKey = <span class="keyword">this</span>.determineCurrentLookupKey();</span><br><span class="line">        DataSource dataSource = (DataSource)<span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractRoutingDataSource是spring-jdbc包提供的一个了AbstractDataSource的抽象类，它<strong>实现了DataSource接口</strong>的用于获取数据库连接的方法。</p>
<p>可以看到源码中也是通过 determineTargetDataSource() 获取到 datasource 对象，再从这个配置好的 datasource 获取到数据库连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection(username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看 <strong>determineTargetDataSource()方法代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">    Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">    DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法的返回值就是项目中所要用的DataSource的key值，拿到该key后就可以在resolvedDataSource中取出对应的DataSource，如果key找不到对应的DataSource就使用默认的数据源。</span></span><br></pre></td></tr></table></figure>
<p><strong>determineCurrentLookupKey 用于在获得数据库连接之前执行，以便在出现多数据源的情况下，由该方法确定调用哪个数据源key。且每切换一次数据源就会被调用一次</strong></p>
<p>总结：</p>
<p>SpringBoot 提供了 AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样在执行查询之前，设置使用的数据源。实现可动态路由的数据源，在每次数据库查询操作前执行。通过它的抽象方法 <em><strong>determineCurrentLookupKey()</strong></em> 获取到数据源对应的key，<em><strong>determineTargetDataSource()</strong></em> 拿到该key后就可以在resolvedDataSource中取出对应的DataSource。</p>
<h2 id="MutablePropertyValues"><a class="header-anchor" href="#MutablePropertyValues">¶</a>MutablePropertyValues</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title">PropertyValues</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>用过类的实现关系可知 <strong>MutablePropertyValues</strong> 实现了 <em><strong>PropertyValues接口</strong></em></p>
<ul>
<li>PropertyValues 源码</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306132937475.png" alt="image-20200306132937475"></p>
<p>由图可知，PropertyValues接口类 包含了许多对属性的基本操作：迭代，分割，获取，等</p>
<ul>
<li>MutablePropertyValues源码</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306133216584.png" alt="image-20200306133216584"></p>
<p>可见 MutablePropertyValues 丰富了 PropertyValues 对属性值的操作</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306134129694.png" alt="image-20200306134129694"></p>
<p>且通过类的继承关系可以发现，PropertyValues 只有一个实现类：**MutablePropertyValues **</p>
<h2 id="ThreadLocal"><a class="header-anchor" href="#ThreadLocal">¶</a>ThreadLocal</h2>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/image-20200306143529330.png" alt="image-20200306143529330"></p>
<p>Threadlocal 是一个线程内部的 <strong>存储类</strong>，可以在指定内存存储数据，数据存储以后，<strong>只有指定的线程可以得到存储数据</strong></p>
<p>ThreadLocal 提供了线程的局部变量，每个线程都可以通过 <code>set()</code> 和 <code>get()</code> 来对这个局部变量进行操作，但不会和其它线程的局部变量进行冲突，<strong>实现了线程的数据隔离</strong></p>
<h3 id="ThreadLocalMap"><a class="header-anchor" href="#ThreadLocalMap">¶</a>ThreadLocalMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....很长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看源码可知，ThreadLocalMap 是 ThreadLocal 的一个内部类。用 Entry 类来进行存储。</p>
<p>先来看 set()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的<strong>值都是存储到这个 Map 上的，key 是当前 ThreadLocal 对象</strong></p>
<p><strong>Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象</strong></p>
<p>有了上面的基础，我们看get()方法就一点都不难理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
</blockquote>
<ol>
<li>每个Thread维护着一个ThreadLocalMap的引用</li>
<li>ThreadLocalMap是ThreadLocal的内部类，用<strong>Entry</strong>来进行存储</li>
<li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li>
<li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li>
<li><strong>ThreadLocal本身并不存储值</strong>，它只是<strong>作为一个key来让线程从ThreadLocalMap获取value</strong>。</li>
</ol>
<blockquote>
<h3 id="避免内存泄漏"><a class="header-anchor" href="#避免内存泄漏">¶</a>避免内存泄漏</h3>
</blockquote>
<p>我们来看一下ThreadLocal的对象关系引用图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC80LzMvMTYyODk2YWIxYTFkMWUyZQ?x-oss-process=image/format,png" alt="img"></p>
<p>ThreadLocal内存泄漏的根源是：<strong>由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用</strong>。</p>
<p>想要避免内存泄露就要<strong>手动remove()掉</strong>！</p>
<h2 id="AOP"><a class="header-anchor" href="#AOP">¶</a>AOP</h2>
<p>要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面<strong>相匹配的 Bean 创建代理</strong>。</p>
<p>在切面类中需要定义切面方法用于响应响应的目标方法，切面方法即为通知方法，通知方法需要用注解标识，AspectJ 支持 5 种类型的通知注解:</p>
<ul>
<li><strong>@Before</strong>: 前置通知, 在方法执行之前执行</li>
<li><strong>@After</strong>: 后置通知, 在方法执行之后执行 。</li>
<li><strong>@AfterRunning</strong>: 返回通知, 在方法返回结果之后执行</li>
<li><strong>@AfterThrowing</strong>: 异常通知, 在方法抛出异常之后</li>
<li><strong>@Around</strong>: 环绕通知, 围绕着方法执行</li>
</ul>
<p>以上5种类型的通知注解的值可以为 <em><strong>@annotation</strong></em>表示标注了某个注解的所有方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span></span><br></pre></td></tr></table></figure>
<p>执行的顺序如下：</p>
<p><strong>正常情况：</strong><br>
<img src="https://img-blog.csdn.net/20160811192425854" alt="one-ok"></p>
<hr>
<p><strong>异常情况：</strong><br>
<img src="https://img-blog.csdn.net/20160811192446479" alt="one-exception"></p>
<h3 id="JoinPoint"><a class="header-anchor" href="#JoinPoint">¶</a>JoinPoint</h3>
<p>JoinPoint 对象封装了 SpringAop 中<strong>切面方法的信息</strong>，在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    String dsId = ds.value();</span><br><span class="line">    <span class="keyword">if</span>(DynamicDataSourceContextHolder.dataSourceIds.contains(dsId))&#123;</span><br><span class="line">        <span class="comment">//当日志级别为 debug 时输出</span></span><br><span class="line">        <span class="comment">//point.getSignature() 获取切入点的方法名</span></span><br><span class="line">        logger.debug(<span class="string">"Use DataSourceKey :&#123;&#125; &gt;"</span>, dsId, point.getSignature());</span><br><span class="line">        <span class="comment">//设置数据源的 key</span></span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceRouterKey(dsId);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//point.getSignature() 获取切入点的方法名</span></span><br><span class="line">        logger.info(<span class="string">"数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&#123;&#125;"</span>, dsId, point.getSignature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Logger"><a class="header-anchor" href="#Logger">¶</a>Logger</h2>
<p>在编程中尽量用 Logger(org.slf4j.Logger) 来输出信息，避免使用 sout</p>
<p>因为 Logger 提供了 5 种日志级别的输出：</p>
<ol>
<li><strong>error</strong></li>
<li><strong>warn</strong></li>
<li><strong>info</strong></li>
<li><strong>debug</strong></li>
<li><strong>trace</strong></li>
</ol>
<p>可在 application.yml 等配置日志输出级别，实现输出不同级别的日志信息按照需求输出，不像 sout 无法控制</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    String dsId = ds.value();</span><br><span class="line">    <span class="keyword">if</span>(DynamicDataSourceContextHolder.dataSourceIds.contains(dsId))&#123;</span><br><span class="line">        logger.debug(<span class="string">"Use DataSourceKey :&#123;&#125; &gt;"</span>, dsId, point.getSignature());</span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceRouterKey(dsId);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&#123;&#125;"</span>, dsId, point.getSignature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    logger.debug(<span class="string">"Revert DataSourceKey : "</span> + ds.value() + <span class="string">" &gt; "</span> + point.getSignature());</span><br><span class="line">    <span class="comment">//移除 ThreadLocalMap 中存储的 ThreadLocal对象和值，避免内存溢出</span></span><br><span class="line">    DynamicDataSourceContextHolder.removeDataSourceRouterKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有两个输出级别：debug 和 info</p>
<p>当在 application.yml 中配置 logging.level.root=info 时，info级别的日志得到输出，debug同理</p>
<p><img src="https://img-blog.csdnimg.cn/20200306232559114.png" alt="image-20200306154105726"></p>
<h2 id="DataSourceBuilder"><a class="header-anchor" href="#DataSourceBuilder">¶</a>DataSourceBuilder</h2>
<p>示例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">customize.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/blue?serverTimezone=UTC</span></span><br><span class="line"><span class="meta">customize.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">customize.datasource.password</span>=<span class="string">wan4380797</span></span><br><span class="line"><span class="meta">customize.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp2.BasicDataSource;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2DataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"myDbcp2DataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"customize.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().type(BasicDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>未完待续…</p>
<h2 id="Binder"><a class="header-anchor" href="#Binder">¶</a>Binder</h2>
<p>对于 Binder，只要会用就差不多了，等功力达到以后再深入源码</p>
<blockquote>
<h3 id="示例1-简单类型"><a class="header-anchor" href="#示例1-简单类型">¶</a>示例1 简单类型</h3>
</blockquote>
<p>假设在propertes配置中有这样一个配置：<code>com.didispace.foo=bar</code></p>
<p>我们为它创建对应的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"com.didispace"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String foo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，通过最新的<code>Binder</code>就可以这样来拿配置信息了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Binder binder = Binder.get(context.getEnvironment());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定简单配置</span></span><br><span class="line">        FooProperties foo = binder.bind(<span class="string">"com.didispace"</span>, Bindable.of(FooProperties<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">        System.out.println(foo.getFoo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="示例2-List类型"><a class="header-anchor" href="#示例2-List类型">¶</a>示例2 List类型</h3>
</blockquote>
<p>如果配置内容是List类型呢？比如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">com.didispace.post[0]</span>=<span class="string">Why Spring Boot</span></span><br><span class="line"><span class="meta">com.didispace.post[1]</span>=<span class="string">Why Spring Cloud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">com.didispace.posts[0].title</span>=<span class="string">Why Spring Boot</span></span><br><span class="line"><span class="meta">com.didispace.posts[0].content</span>=<span class="string">It is perfect!</span></span><br><span class="line"><span class="meta">com.didispace.posts[1].title</span>=<span class="string">Why Spring Cloud</span></span><br><span class="line"><span class="meta">com.didispace.posts[1].content</span>=<span class="string">It is perfect too!</span></span><br></pre></td></tr></table></figure>
<p>要获取这些配置依然很简单，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">Binder binder = Binder.get(context.getEnvironment());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定List配置</span></span><br><span class="line">List&lt;String&gt; post = binder.bind(<span class="string">"com.didispace.post"</span>, Bindable.listOf(String<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">System.out.println(post);</span><br><span class="line"></span><br><span class="line">List&lt;PostInfo&gt; posts = binder.bind(<span class="string">"com.didispace.posts"</span>, Bindable.listOf(PostInfo<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">System.out.println(posts)</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3>
<p>里面 bind() 方法有许多重载，重点关注这个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">    Assert.notNull(target, <span class="string">"Target must not be null"</span>);</span><br><span class="line">    handler = handler != <span class="keyword">null</span> ? handler : <span class="keyword">this</span>.defaultBindHandler;</span><br><span class="line">    Binder.Context context = <span class="keyword">new</span> Binder.Context();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bind(name, target, handler, context, <span class="keyword">false</span>, create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还不是真正的绑定阶段，但有两个点需要说明：</p>
<ul>
<li>参数<strong>ConfigurationPropertyName</strong>：是对前面传入的配置前缀 prefix 进行一些基本校验和处理</li>
<li>返回值<strong>BindResult</strong>：里面有<code>of()</code>, <code>get()</code>, <code>isBound()</code>, <code>orElse()</code>等</li>
<li><strong>Context</strong>：在这里是绑定上下文, 由前面说过的<code>BindHandler</code>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BindContext</span> </span>&#123;</span><br><span class="line">    <span class="function">Binder <span class="title">getBinder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterable&lt;ConfigurationPropertySource&gt; <span class="title">getSources</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConfigurationProperty <span class="title">getConfigurationProperty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟着代码往下，看 Binder 中的下一个bind() 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    context.clearConfigurationProperty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bindable&lt;T&gt; replacementTarget = handler.onStart(name, target, context);</span><br><span class="line">        <span class="keyword">if</span> (replacementTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleBindResult(name, target, handler, context, (Object)<span class="keyword">null</span>, create);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object bound = <span class="keyword">this</span>.bindObject(name, replacementTarget, handler, context, allowRecursiveBinding);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleBindResult(name, replacementTarget, handler, context, bound, create);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handleBindError(name, target, handler, context, var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>留意 onStart ，这里就有一个 BindHandler 回调接口中的一个方法，也就是绑定的开始但还未完成阶段</p>
<p>接下来在<code>Binder</code>中, 会陆续看到其它几个阶段的方法</p>
<p>再来看返回, 是通过<code>handleBindResult()</code>和<code>handleBindError()</code>来处理的.</p>
<p>点开这两个handleBindXXX()能看到在里面进行了onSuccess, onFinish, onFailure的调用</p>
<ul>
<li>handleBindResult() 源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">handleBindResult</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, Object result, <span class="keyword">boolean</span> create)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = handler.onSuccess(name, target, context, result);</span><br><span class="line">        result = context.getConverter().convert(result, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; create) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.create(target, context);</span><br><span class="line">        result = handler.onCreate(name, target, context, result);</span><br><span class="line">        result = context.getConverter().convert(result, target);</span><br><span class="line">        Assert.state(result != <span class="keyword">null</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unable to create instance for "</span> + target.getType();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler.onFinish(name, target, context, result);</span><br><span class="line">    <span class="keyword">return</span> context.getConverter().convert(result, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>handleBindError() 源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">handleBindError</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, Exception error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object result = handler.onFailure(name, target, context, error);</span><br><span class="line">        <span class="keyword">return</span> context.getConverter().convert(result, target);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var7 <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BindException)var7;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindException(name, target, context.getConfigurationProperty(), var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点来看 <em><strong>bindObject()</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Object <span class="title">bindObject</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">    ConfigurationProperty property = <span class="keyword">this</span>.findProperty(name, context);</span><br><span class="line">    <span class="keyword">if</span> (property == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsNoDescendantOf(context.getSources(), name) &amp;&amp; context.depth != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AggregateBinder&lt;?&gt; aggregateBinder = <span class="keyword">this</span>.getAggregateBinder(target, context);</span><br><span class="line">        <span class="keyword">if</span> (aggregateBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bindAggregate(name, target, handler, context, aggregateBinder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.bindProperty(target, context, property);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConverterNotFoundException var10) &#123;</span><br><span class="line">                Object instance = <span class="keyword">this</span>.bindDataObject(name, target, handler, context, allowRecursiveBinding);</span><br><span class="line">                <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bindDataObject(name, target, handler, context, allowRecursiveBinding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里过程比较多，可以分为 2 个部分</p>
<p><strong>Part1</strong>：寻找属性和匹配的过程</p>
<p>开头的<code>findProperty()</code>和一个匹配方法:<code>containsNoDescendantOf()</code>, 它们的参数都有<code>context</code></p>
<p>上面说过了–&gt;提供绑定的上下文信息</p>
<p><strong>Part2</strong>：绑定过程</p>
<p>接下来是 bindXXX 这三个私有方法：</p>
<ul>
<li>
<p><code>bindAggregate()</code>: 从注释上看出, 主要是负责处理Map, Collections, Array的绑定策略, 及完成多层属性的递归</p>
</li>
<li>
<p><code>bindProperty()</code>: 是返回属性值的过程(其中包含类型转换)</p>
<p>例如属性资源文件中配置的<code>name=thank</code> -&gt; <code>java.lang.String thank</code></p>
</li>
<li>
<p><code>bindBean()</code>: 会继续调用另外一个私有的重载函数<code>bindBean()</code></p>
</li>
</ul>
<p>重点看看这个方法 — bindDataObject()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">bindDataObject</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isUnbindableBean(name, target, context)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; type = target.getType().resolve(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!allowRecursiveBinding &amp;&amp; context.isBindingDataObject(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DataObjectPropertyBinder propertyBinder = (propertyName, propertyTarget) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.bind(name.append(propertyName), propertyTarget, handler, context, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> context.withDataObject(type, () -&gt; &#123;</span><br><span class="line">                Iterator var5 = <span class="keyword">this</span>.dataObjectBinders.iterator();</span><br><span class="line"></span><br><span class="line">                Object instance;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!var5.hasNext()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DataObjectBinder dataObjectBinder = (DataObjectBinder)var5.next();</span><br><span class="line">                    instance = dataObjectBinder.bind(name, target, context, propertyBinder);</span><br><span class="line">                &#125; <span class="keyword">while</span>(instance == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面又调用了上层的<code>Binder.bind()</code>, 递归完成绑定</p>
<p>终止条件是上面提到过的<code>containsNoDescendantOf()</code>和另外一个判断<code>isUnbindableBean()</code></p>
<p>关注一下最终的返回结果, 是调用了另外一个类: <code>JavaBeanBinder</code>的<code>bind</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;BeanBinder&gt; BEAN_BINDERS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        List&lt;BeanBinder&gt; binders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        binders.add(<span class="keyword">new</span> JavaBeanBinder());</span><br><span class="line">        BEAN_BINDERS = Collections.unmodifiableList(binders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="bind"><a class="header-anchor" href="#bind">¶</a>bind()</h5>
<p>进入<code>JavaBeanBinder#bind()</code>之后看到继续调用了另一个私有的重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">bind</span><span class="params">(BeanPropertyBinder propertyBinder, Bean&lt;T&gt; bean, BeanSupplier&lt;T&gt; beanSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BeanProperty&gt; entry : bean.getProperties().entrySet()) &#123;</span><br><span class="line">        bound |= bind(beanSupplier, propertyBinder, entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面会迭代该配置bean中的所有属性, 调试模式下随便取一个来看看:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">0 = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7470</span>&#125; <span class="string">"name"</span> -&gt; </span><br><span class="line">  key = <span class="string">"name"</span></span><br><span class="line">  value = &#123;JavaBeanBinder<span class="variable">$BeanProperty</span><span class="variable">@7475</span>&#125; </span><br><span class="line">    name = <span class="string">"name"</span></span><br><span class="line">    declaringClassType = &#123;ResolvableType<span class="variable">@7481</span>&#125; <span class="string">"com.example.cache.config.CustomProperties"</span></span><br><span class="line">    getter = &#123;Method<span class="variable">@7482</span>&#125; <span class="string">"public java.lang.String com.example.cache.config.CustomProperties.getName()"</span></span><br><span class="line">    setter = &#123;Method<span class="variable">@7483</span>&#125; <span class="string">"public void com.example.cache.config.CustomProperties.setName(java.lang.String)"</span></span><br><span class="line">    field = &#123;Field<span class="variable">@7484</span>&#125; <span class="string">"private java.lang.String com.example.cache.config.CustomProperties.name"</span></span><br><span class="line"><span class="number">1</span> = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7471</span>&#125; <span class="string">"age"</span> -&gt; </span><br><span class="line"><span class="number">2</span> = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7472</span>&#125; <span class="string">"email"</span> -&gt;</span><br></pre></td></tr></table></figure>
<p>没错, 配置bean中: 的属性名, Setter和Getter 该有的都有了</p>
<p>下面来到<code>JavaBeanBinder</code>的最后一个重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">bind</span><span class="params">(BeanSupplier&lt;T&gt; beanSupplier, </span></span></span><br><span class="line"><span class="function"><span class="params">                         BeanPropertyBinder propertyBinder, BeanProperty property)</span> </span>&#123;</span><br><span class="line">    String propertyName = property.getName();</span><br><span class="line">    ResolvableType type = property.getType();</span><br><span class="line">    Supplier&lt;Object&gt; value = property.getValue(beanSupplier);</span><br><span class="line">    Annotation[] annotations = property.getAnnotations();</span><br><span class="line">    Object bound = propertyBinder.bindProperty(</span><br><span class="line">        propertyName, Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (bound == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (property.isSettable()) &#123;</span><br><span class="line">        property.setValue(beanSupplier, bound);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="keyword">null</span> || !bound.equals(value.get())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No setter found for property: "</span> + property.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就比较简单了, 分步拿到了配置Bean属性的定义和值:</p>
<ul>
<li>
<p>field: 即propertyName, e.g. <code>name</code></p>
</li>
<li>
<p>属性类型: type, e.g. <code>java.lang.String</code></p>
</li>
<li>
<p>getter and setter</p>
<p>e.g.<code>public void com.example.cache.config.CustomProperties.setName(java.lang.String)</code></p>
</li>
<li>
<p>以及调用<code>propertyBinder.bindProperty()</code>拿到了资源属性文件中的属性值<code>bound</code></p>
<p>该方法的作用前面也提到过(e.g. <code>thank</code> )</p>
</li>
</ul>
<p>然后调用了属性的<code>setValue()</code>方法: 执行<code>property.setValue(beanSupplier, bound);</code></p>
<p>至此, 看到了调用属性的set方法, 终于可以放心了!</p>
<p>从<code>ConfigurationPropertiesBindingPostProcessor</code>开始到调用setter结束, 完整的调用栈如下:</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">bind:85, JavaBeanBinder &#123;<span class="attribute">org.springframework.boot.context.properties.bind&#125;</span></span><br><span class="line"><span class="attribute">bind</span>:62, JavaBeanBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:54, JavaBeanBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">lambda$null$5:341, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">apply:-1, 1445225850 &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span><span class="variable">.Binder</span>$$Lambda$267&#125;</span><br><span class="line">accept:193, ReferencePipeline$3$1 &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">tryAdvance:1351, ArrayList$ArrayListSpliterator &#123;java<span class="variable">.util</span>&#125;</span><br><span class="line">forEachWithCancel:126, ReferencePipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">copyIntoWithCancel:498, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">copyInto:485, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">wrapAndCopyInto:471, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">evaluateSequential:152, FindOps$FindOp &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">evaluate:234, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">findFirst:464, ReferencePipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">lambda$bindBean$6:342, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">get:-1, 2008619427 &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span><span class="variable">.Binder</span>$$Lambda$266&#125;</span><br><span class="line">withIncreasedDepth:441, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">withBean:427, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">access$400:381, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bindBean:339, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bindObject:278, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:221, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:210, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:192, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:82, ConfigurationPropertiesBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br><span class="line">bind:107, ConfigurationPropertiesBindingPostProcessor &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br><span class="line">postProcessBeforeInitialization:93, ConfigurationPropertiesBindingPostProcessor &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Import"><a class="header-anchor" href="#Import">¶</a>@Import</h2>
<p>参考：</p>
<p><a href="https://blog.csdn.net/pange1991/article/details/81356594" target="_blank" rel="noopener">Spring @Import注解 —— 导入资源</a></p>
<p><a href="https://blog.csdn.net/tuoni123/article/details/80213050" target="_blank" rel="noopener">SpringBoot @Import 详解</a></p>
<p><a href="https://juejin.im/post/5c761c096fb9a049b41d2299" target="_blank" rel="noopener">Spring Boot 自动配置之@Enable* 与@Import注解</a></p>
<p>SpringBoot 的 @Import 用于将指定的类示例注入到 Spring IOC Container 中。</p>
<p>提供了三种方法：</p>
<ul>
<li>直接注入(@Import)</li>
<li>实现 ImportBeanDefinitionRegistrar 接口 注入</li>
<li>实现 ImportSelector 注入</li>
</ul>
<h2 id="流程图"><a class="header-anchor" href="#流程图">¶</a>流程图</h2>
<p><img src="https://img-blog.csdnimg.cn/20200307165337725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>多数据源</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之BeanDefinitionRegistry</title>
    <url>/2020/03/04/Spring%E4%B9%8BBeanDefinitionRegistry/</url>
    <content><![CDATA[<p>Spring 的 Bean 是以 BeanDefinition 的形式存在的</p>
<h2 id="BeanDefinitionRegistry-源码"><a class="header-anchor" href="#BeanDefinitionRegistry-源码">¶</a><em>BeanDefinitionRegistry 源码</em></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否存在 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition 名称</span></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition 的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bean 的名字是否被使用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>BeanDefinitionRegistry 是 BeanDefnition 的注册中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父子关系</span></span><br><span class="line">BeanDefinitionRegistry</span><br><span class="line">|</span><br><span class="line">--- SimpleBeanDefinitionRegistry</span><br><span class="line">|</span><br><span class="line">--- DefaultListableBeanFactory(核心)</span><br><span class="line">|</span><br><span class="line">--- GenericApplicationContext(核心)</span><br></pre></td></tr></table></figure>
<h2 id="SimpleBeanDefinitionRegistry-源码"><a class="header-anchor" href="#SimpleBeanDefinitionRegistry-源码">¶</a><em>SimpleBeanDefinitionRegistry 源码</em></h2>
<p>SimpleBeanDefinitionRegistry 的源码看起来比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.hasText(beanName, <span class="string">"'beanName' must not be empty"</span>);</span><br><span class="line">        Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanDefinitionMap.remove(beanName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAlias(beanName) || containsBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DefaultListableBeanFactory-源码"><a class="header-anchor" href="#DefaultListableBeanFactory-源码">¶</a><em>DefaultListableBeanFactory 源码</em></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; javaxInjectProviderClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaxInjectProviderClass =</span><br><span class="line">                ClassUtils.forName(<span class="string">"javax.inject.Provider"</span>, DefaultListableBeanFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// JSR-330 API not available - Provider interface simply not supported then.</span></span><br><span class="line">            javaxInjectProviderClass = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map from serialized id to factory instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Optional id for this factory, for serialization purposes. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> String serializationId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether to allow re-registration of a different definition with the same name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowBeanDefinitionOverriding = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether to allow eager class loading even for lazy-init beans. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowEagerClassLoading = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Optional OrderComparator for dependency Lists and arrays. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;Object&gt; dependencyComparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resolver to use for checking if a bean definition is an autowire candidate. */</span></span><br><span class="line">    <span class="keyword">private</span> AutowireCandidateResolver autowireCandidateResolver = <span class="keyword">new</span> SimpleAutowireCandidateResolver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map from dependency type to corresponding autowired value. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of singleton and non-singleton bean names, keyed by dependency type. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of singleton-only bean names, keyed by dependency type. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of bean definition names, in registration order. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of names of manually registered singletons, in registration order. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cached array of bean definition names in case of frozen configuration. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String[] frozenBeanDefinitionNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether bean definition metadata may be cached for all beans. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> configurationFrozen = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new DefaultListableBeanFactory with the given parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parentBeanFactory the parent BeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Specify an id for serialization purposes, allowing this BeanFactory to be</span></span><br><span class="line"><span class="comment">	 * deserialized from this id back into the BeanFactory object, if needed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSerializationId</span><span class="params">(@Nullable String serializationId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            serializableFactories.put(serializationId, <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            serializableFactories.remove(<span class="keyword">this</span>.serializationId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.serializationId = serializationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an id for serialization purposes, if specified, allowing this BeanFactory</span></span><br><span class="line"><span class="comment">	 * to be deserialized from this id back into the BeanFactory object, if needed.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSerializationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serializationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * If not, an exception will be thrown. This also applies to overriding aliases.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowBeanDefinitionOverriding</span><span class="params">(<span class="keyword">boolean</span> allowBeanDefinitionOverriding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowBeanDefinitionOverriding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowBeanDefinitionOverriding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether the factory is allowed to eagerly load bean classes</span></span><br><span class="line"><span class="comment">	 * even for bean definitions that are marked as "lazy-init".</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true". Turn this flag off to suppress class loading</span></span><br><span class="line"><span class="comment">	 * for lazy-init beans unless such a bean is explicitly requested.</span></span><br><span class="line"><span class="comment">	 * In particular, by-type lookups will then simply ignore bean definitions</span></span><br><span class="line"><span class="comment">	 * without resolved class name, instead of loading the bean classes on</span></span><br><span class="line"><span class="comment">	 * demand just to perform a type check.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> AbstractBeanDefinition#setLazyInit</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowEagerClassLoading</span><span class="params">(<span class="keyword">boolean</span> allowEagerClassLoading)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allowEagerClassLoading = allowEagerClassLoading;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether the factory is allowed to eagerly load bean classes</span></span><br><span class="line"><span class="comment">	 * even for bean definitions that are marked as "lazy-init".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowEagerClassLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowEagerClassLoading;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a &#123;<span class="doctag">@link</span> java.util.Comparator&#125; for dependency Lists and arrays.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.OrderComparator</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.annotation.AnnotationAwareOrderComparator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependencyComparator</span><span class="params">(@Nullable Comparator&lt;Object&gt; dependencyComparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependencyComparator = dependencyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the dependency comparator for this BeanFactory (may be &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparator&lt;Object&gt; <span class="title">getDependencyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dependencyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a custom autowire candidate resolver for this BeanFactory to use</span></span><br><span class="line"><span class="comment">	 * when deciding whether a bean definition should be considered as a</span></span><br><span class="line"><span class="comment">	 * candidate for autowiring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutowireCandidateResolver</span><span class="params">(<span class="keyword">final</span> AutowireCandidateResolver autowireCandidateResolver)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(autowireCandidateResolver, <span class="string">"AutowireCandidateResolver must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (autowireCandidateResolver <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(DefaultListableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.autowireCandidateResolver = autowireCandidateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the autowire candidate resolver for this BeanFactory (never &#123;<span class="doctag">@code</span> null&#125;).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AutowireCandidateResolver <span class="title">getAutowireCandidateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autowireCandidateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyConfigurationFrom</span><span class="params">(ConfigurableBeanFactory otherFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.copyConfigurationFrom(otherFactory);</span><br><span class="line">        <span class="keyword">if</span> (otherFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            DefaultListableBeanFactory otherListableFactory = (DefaultListableBeanFactory) otherFactory;</span><br><span class="line">            <span class="keyword">this</span>.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;</span><br><span class="line">            <span class="keyword">this</span>.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;</span><br><span class="line">            <span class="keyword">this</span>.dependencyComparator = otherListableFactory.dependencyComparator;</span><br><span class="line">            <span class="comment">// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware...</span></span><br><span class="line">            setAutowireCandidateResolver(BeanUtils.instantiateClass(getAutowireCandidateResolver().getClass()));</span><br><span class="line">            <span class="comment">// Make resolvable dependencies (e.g. ResourceLoader) available here as well...</span></span><br><span class="line">            <span class="keyword">this</span>.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of remaining BeanFactory methods</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBean(requiredType, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, @Nullable Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) resolved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanProvider(ResolvableType.forRawClass(requiredType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanObjectProvider&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                T resolved = resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resolved;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                T resolved = resolveBean(requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resolved;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.stream(getBeanNamesForTypedStream(requiredType))</span><br><span class="line">                    .map(name -&gt; (T) getBean(name))</span><br><span class="line">                    .filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Stream&lt;T&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String[] beanNames = getBeanNamesForTypedStream(requiredType);</span><br><span class="line">                Map&lt;String, T&gt; matchingBeans = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    Object beanInstance = getBean(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                        matchingBeans.put(beanName, (T) beanInstance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Stream&lt;T&gt; stream = matchingBeans.values().stream();</span><br><span class="line">                <span class="keyword">return</span> stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">resolveBean</span><span class="params">(ResolvableType requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> </span>&#123;</span><br><span class="line">        NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">        <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> namedBean.getBeanInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((DefaultListableBeanFactory) parent).resolveBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ObjectProvider&lt;T&gt; parentProvider = parent.getBeanProvider(requiredType);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> parentProvider.getObject(args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] getBeanNamesForTypedStream(ResolvableType requiredType) &#123;</span><br><span class="line">        <span class="keyword">return</span> BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of ListableBeanFactory interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        String[] frozenNames = <span class="keyword">this</span>.frozenBeanDefinitionNames;</span><br><span class="line">        <span class="keyword">if</span> (frozenNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> frozenNames.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(ResolvableType type) &#123;</span><br><span class="line">        Class&lt;?&gt; resolved = type.resolve();</span><br><span class="line">        <span class="keyword">if</span> (resolved != <span class="keyword">null</span> &amp;&amp; !type.hasGenerics()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getBeanNamesForType(resolved, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doGetBeanNamesForType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanNamesForType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isConfigurationFrozen() || type == <span class="keyword">null</span> || !allowEagerInit) &#123;</span><br><span class="line">            <span class="keyword">return</span> doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, String[]&gt; cache =</span><br><span class="line">            (includeNonSingletons ? <span class="keyword">this</span>.allBeanNamesByType : <span class="keyword">this</span>.singletonBeanNamesByType);</span><br><span class="line">        String[] resolvedBeanNames = cache.get(type);</span><br><span class="line">        <span class="keyword">if</span> (resolvedBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">        &#125;</span><br><span class="line">        resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCacheSafe(type, getBeanClassLoader())) &#123;</span><br><span class="line">            cache.put(type, resolvedBeanNames);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] doGetBeanNamesForType(ResolvableType type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check all bean definitions.</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            <span class="comment">// Only consider bean as eligible if the bean name</span></span><br><span class="line">            <span class="comment">// is not defined as alias for some other bean.</span></span><br><span class="line">            <span class="keyword">if</span> (!isAlias(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                    <span class="comment">// Only check bean definition if it is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">                                              (mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">                                              !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">                        <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">                        <span class="keyword">boolean</span> isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">                        BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">                        <span class="keyword">boolean</span> matchFound =</span><br><span class="line">                            (allowEagerInit || !isFactoryBean ||</span><br><span class="line">                             (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">                            (includeNonSingletons ||</span><br><span class="line">                             (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">                            isTypeMatch(beanName, type);</span><br><span class="line">                        <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">                            <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line">                            beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">                            matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">                            result.add(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (CannotLoadBeanClassException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (allowEagerInit) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Probably a class name with a placeholder: let's ignore it for type matching purposes.</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignoring bean class loading failure for bean '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    onSuppressedException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (allowEagerInit) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Probably some metadata with a placeholder: let's ignore it for type matching purposes.</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignoring unresolvable metadata in bean definition '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    onSuppressedException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check manually registered singletons too.</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.manualSingletonNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((includeNonSingletons || isSingleton(beanName)) &amp;&amp; isTypeMatch(beanName, type)) &#123;</span><br><span class="line">                        result.add(beanName);</span><br><span class="line">                        <span class="comment">// Match found for this bean: do not match FactoryBean itself anymore.</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// In case of FactoryBean, try to match FactoryBean itself next.</span></span><br><span class="line">                    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Match raw bean instance (might be raw FactoryBean).</span></span><br><span class="line">                <span class="keyword">if</span> (isTypeMatch(beanName, type)) &#123;</span><br><span class="line">                    result.add(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                <span class="comment">// Shouldn't happen - probably a result of circular reference resolution...</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Failed to check manually registered singleton with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the specified bean would need to be eagerly initialized</span></span><br><span class="line"><span class="comment">	 * in order to determine its type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> factoryBeanName a factory-bean reference that the bean definition</span></span><br><span class="line"><span class="comment">	 * defines a factory method for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether eager initialization is necessary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requiresEagerInitForType</span><span class="params">(@Nullable String factoryBeanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (factoryBeanName != <span class="keyword">null</span> &amp;&amp; isFactoryBean(factoryBeanName) &amp;&amp; !containsSingleton(factoryBeanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeansOfType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">        Map&lt;String, T&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object beanInstance = getBean(beanName);</span><br><span class="line">                <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                    result.put(beanName, (T) beanInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">                <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                    BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">                    String exBeanName = bce.getBeanName();</span><br><span class="line">                    <span class="keyword">if</span> (exBeanName != <span class="keyword">null</span> &amp;&amp; isCurrentlyInCreation(exBeanName)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                            logger.trace(<span class="string">"Ignoring match to currently created bean '"</span> + exBeanName + <span class="string">"': "</span> +</span><br><span class="line">                                         ex.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        onSuppressedException(ex);</span><br><span class="line">                        <span class="comment">// Ignore: indicates a circular reference when autowiring constructors.</span></span><br><span class="line">                        <span class="comment">// We want to find matches other than the currently created bean itself.</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!beanDefinition.isAbstract() &amp;&amp; findAnnotationOnBean(beanName, annotationType) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.manualSingletonNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.contains(beanName) &amp;&amp; findAnnotationOnBean(beanName, annotationType) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">        String[] beanNames = getBeanNamesForAnnotation(annotationType);</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            Object beanInstance = getBean(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                result.put(beanName, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Find a &#123;<span class="doctag">@link</span> Annotation&#125; of &#123;<span class="doctag">@code</span> annotationType&#125; on the specified</span></span><br><span class="line"><span class="comment">	 * bean, traversing its interfaces and super classes if no annotation can be</span></span><br><span class="line"><span class="comment">	 * found on the given class itself, as well as checking its raw bean class</span></span><br><span class="line"><span class="comment">	 * if not found on the exposed bean reference (e.g. in case of a proxy).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        A ann = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; beanType = getType(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ann = AnnotationUtils.findAnnotation(beanType, annotationType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ann == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            BeanDefinition bd = getMergedBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                AbstractBeanDefinition abd = (AbstractBeanDefinition) bd;</span><br><span class="line">                <span class="keyword">if</span> (abd.hasBeanClass()) &#123;</span><br><span class="line">                    Class&lt;?&gt; beanClass = abd.getBeanClass();</span><br><span class="line">                    <span class="keyword">if</span> (beanClass != beanType) &#123;</span><br><span class="line">                        ann = AnnotationUtils.findAnnotation(beanClass, annotationType);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ann;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of ConfigurableListableBeanFactory interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerResolvableDependency</span><span class="params">(Class&lt;?&gt; dependencyType, @Nullable Object autowiredValue)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(dependencyType, <span class="string">"Dependency type must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (autowiredValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(autowiredValue <span class="keyword">instanceof</span> ObjectFactory || dependencyType.isInstance(autowiredValue))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Value ["</span> + autowiredValue +</span><br><span class="line">                                                   <span class="string">"] does not implement specified dependency type ["</span> + dependencyType.getName() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.resolvableDependencies.put(dependencyType, autowiredValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, DependencyDescriptor descriptor)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span></span><br><span class="line"><span class="comment">	 * to be injected into other beans which declare a dependency of matching type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the bean should be considered as autowire candidate</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">        <span class="keyword">if</span> (containsBeanDefinition(beanDefinitionName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isAutowireCandidate(beanName, <span class="keyword">new</span> RootBeanDefinition(getType(beanName)), descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            <span class="comment">// No bean definition found in this factory -&gt; delegate to parent.</span></span><br><span class="line">            <span class="keyword">return</span> ((DefaultListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            <span class="comment">// If no DefaultListableBeanFactory, can't pass the resolver along.</span></span><br><span class="line">            <span class="keyword">return</span> ((ConfigurableListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span></span><br><span class="line"><span class="comment">	 * to be injected into other beans which declare a dependency of matching type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mbd the merged bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the bean should be considered as autowire candidate</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">        resolveBeanClass(mbd, beanDefinitionName);</span><br><span class="line">        <span class="keyword">if</span> (mbd.isFactoryMethodUnique &amp;&amp; mbd.factoryMethodToIntrospect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).resolveFactoryMethodIfPossible(mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolver.isAutowireCandidate(</span><br><span class="line">            <span class="keyword">new</span> BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">getBeanNamesIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompositeIterator&lt;String&gt; iterator = <span class="keyword">new</span> CompositeIterator&lt;&gt;();</span><br><span class="line">        iterator.add(<span class="keyword">this</span>.beanDefinitionNames.iterator());</span><br><span class="line">        iterator.add(<span class="keyword">this</span>.manualSingletonNames.iterator());</span><br><span class="line">        <span class="keyword">return</span> iterator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMetadataCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clearMetadataCache();</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configurationFrozen = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConfigurationFrozen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configurationFrozen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Considers all beans as eligible for metadata caching</span></span><br><span class="line"><span class="comment">	 * if the factory's configuration has been marked as frozen.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #freezeConfiguration()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isBeanEligibleForMetadataCaching</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.configurationFrozen || <span class="keyword">super</span>.isBeanEligibleForMetadataCaching(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">        <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                        <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                        <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                                        ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                                        getAccessControlContext());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                           ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                            getBean(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            Object singletonInstance = getSingleton(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">                <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of BeanDefinitionRegistry interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">        Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                       <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">                <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                                <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                                existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                                 <span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                                 <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                                 <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                                 <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">                <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                    List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                    updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                    updatedDefinitions.add(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                        Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                        updatedSingletons.remove(beanName);</span><br><span class="line">                        <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Still in startup registration phase</span></span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">            resetBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        Assert.hasText(beanName, <span class="string">"'beanName' must not be empty"</span>);</span><br><span class="line"></span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.remove(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.remove(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset all bean definition caches for the given bean,</span></span><br><span class="line"><span class="comment">	 * including the caches of beans that are derived from it.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Called after an existing bean definition has been replaced or removed,</span></span><br><span class="line"><span class="comment">	 * triggering &#123;<span class="doctag">@link</span> #clearMergedBeanDefinition&#125;, &#123;<span class="doctag">@link</span> #destroySingleton&#125;</span></span><br><span class="line"><span class="comment">	 * and &#123;<span class="doctag">@link</span> MergedBeanDefinitionPostProcessor#resetBeanDefinition&#125; on the</span></span><br><span class="line"><span class="comment">	 * given bean and on all bean definitions that have the given bean as parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean to reset</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #removeBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove the merged bean definition for the given bean, if already created.</span></span><br><span class="line">        clearMergedBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove corresponding bean from singleton cache, if any. Shouldn't usually</span></span><br><span class="line">        <span class="comment">// be necessary, rather just meant for overriding a context's default beans</span></span><br><span class="line">        <span class="comment">// (e.g. the default StaticMessageSource in a StaticApplicationContext).</span></span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify all post-processors that the specified bean definition has been reset.</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processor <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset all bean definitions that have the given bean as parent (recursively).</span></span><br><span class="line">        <span class="keyword">for</span> (String bdName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beanName.equals(bdName)) &#123;</span><br><span class="line">                BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(bdName);</span><br><span class="line">                <span class="keyword">if</span> (beanName.equals(bd.getParentName())) &#123;</span><br><span class="line">                    resetBeanDefinition(bdName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Only allows alias overriding if bean definition overriding is allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">allowAliasOverriding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAllowBeanDefinitionOverriding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.registerSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames.size() + <span class="number">1</span>);</span><br><span class="line">                    updatedSingletons.addAll(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.add(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.manualSingletonNames.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroySingletons();</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames.clear();</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Remove any assumptions about by-type mappings.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearByTypeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allBeanNamesByType.clear();</span><br><span class="line">        <span class="keyword">this</span>.singletonBeanNamesByType.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Dependency resolution functionality</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> namedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AutowireCapableBeanFactory) parent).resolveNamedBean(requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ResolvableType requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(requiredType, <span class="string">"Required type must not be null"</span>);</span><br><span class="line">        String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateNames.length);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">                    autowireCandidates.add(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">                candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">            String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object beanInstance = getBean(beanName);</span><br><span class="line">                    candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    candidates.put(beanName, getType(beanName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line">            <span class="keyword">if</span> (candidateName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidateName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object beanInstance = candidates.get(candidateName);</span><br><span class="line">                <span class="keyword">if</span> (beanInstance == <span class="keyword">null</span> || beanInstance <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!nonUniqueAsNull) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">        <span class="keyword">if</span> (Optional<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType() ||</span><br><span class="line">                 ObjectProvider<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">                descriptor, requestingBeanName);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> shortcut;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">            Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">                    BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">                                         getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">                    value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">                &#125;</span><br><span class="line">                TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">                    <span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">                    <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">                            converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                            converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">            <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> multipleBeans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String autowiredBeanName;</span><br><span class="line">            Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">                <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">                        <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">                        <span class="comment">// (before 4.3 in particular when we didn't even look for collection beans).</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We have exactly one match.</span></span><br><span class="line">                Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">                autowiredBeanName = entry.getKey();</span><br><span class="line">                instanceCandidate = entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result = instanceCandidate;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">                &#125;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            Stream&lt;Object&gt; stream = matchingBeans.keySet().stream()</span><br><span class="line">                .map(name -&gt; descriptor.resolveCandidate(name, type, <span class="keyword">this</span>))</span><br><span class="line">                .filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">            <span class="keyword">if</span> (((StreamDependencyDescriptor) descriptor).isOrdered()) &#123;</span><br><span class="line">                stream = stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = type.getComponentType();</span><br><span class="line">            ResolvableType resolvableType = descriptor.getResolvableType();</span><br><span class="line">            Class&lt;?&gt; resolvedArrayType = resolvableType.resolve(type);</span><br><span class="line">            <span class="keyword">if</span> (resolvedArrayType != type) &#123;</span><br><span class="line">                componentType = resolvableType.getComponentType().resolve();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (componentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">                Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">                <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Arrays.sort((Object[]) result, comparator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) &amp;&amp; <span class="title">type</span>.<span class="title">isInterface</span>()) </span>&#123;</span><br><span class="line">            Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</span><br><span class="line">            <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            Object result = converter.convertIfNecessary(matchingBeans.values(), type);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">                Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">                <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ((List&lt;?&gt;) result).sort(comparator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Map<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            ResolvableType mapType = descriptor.getResolvableType().asMap();</span><br><span class="line">            Class&lt;?&gt; keyType = mapType.resolveGeneric(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (String<span class="class">.<span class="keyword">class</span> !</span>= keyType) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; valueType = mapType.resolveGeneric(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (valueType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> matchingBeans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">(DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAutowireCandidateResolver().isRequired(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">indicatesMultipleBeans</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (type.isArray() || (type.isInterface() &amp;&amp;</span><br><span class="line">                                   (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) || <span class="title">Map</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>))))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Comparator&lt;Object&gt; <span class="title">adaptDependencyComparator</span><span class="params">(Map&lt;String, ?&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = getDependencyComparator();</span><br><span class="line">        <span class="keyword">if</span> (comparator <span class="keyword">instanceof</span> OrderComparator) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((OrderComparator) comparator).withSourceProvider(</span><br><span class="line">                createFactoryAwareOrderSourceProvider(matchingBeans));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> comparator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Comparator&lt;Object&gt; <span class="title">adaptOrderComparator</span><span class="params">(Map&lt;String, ?&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; dependencyComparator = getDependencyComparator();</span><br><span class="line">        OrderComparator comparator = (dependencyComparator <span class="keyword">instanceof</span> OrderComparator ?</span><br><span class="line">                                      (OrderComparator) dependencyComparator : OrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">return</span> comparator.withSourceProvider(createFactoryAwareOrderSourceProvider(matchingBeans));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderComparator.<span class="function">OrderSourceProvider <span class="title">createFactoryAwareOrderSourceProvider</span><span class="params">(Map&lt;String, ?&gt; beans)</span> </span>&#123;</span><br><span class="line">        IdentityHashMap&lt;Object, String&gt; instancesToBeanNames = <span class="keyword">new</span> IdentityHashMap&lt;&gt;();</span><br><span class="line">        beans.forEach((beanName, instance) -&gt; instancesToBeanNames.put(instance, beanName));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FactoryAwareOrderSourceProvider(instancesToBeanNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Find bean instances that match the required type.</span></span><br><span class="line"><span class="comment">	 * Called during autowiring for the specified bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean that is about to be wired</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the actual type of bean to look for</span></span><br><span class="line"><span class="comment">	 * (may be an array component type or collection element type)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a Map of candidate names and candidate instances that match</span></span><br><span class="line"><span class="comment">	 * the required type (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #autowireByType</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">findAutowireCandidates</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">            <span class="keyword">this</span>, requiredType, <span class="keyword">true</span>, descriptor.isEager());</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; classObjectEntry : <span class="keyword">this</span>.resolvableDependencies.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; autowiringType = classObjectEntry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">                Object autowiringValue = classObjectEntry.getValue();</span><br><span class="line">                autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">                <span class="keyword">if</span> (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">                    result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">                addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> multiple = indicatesMultipleBeans(requiredType);</span><br><span class="line">            <span class="comment">// Consider fallback matches if the first pass failed to find anything...</span></span><br><span class="line">            DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();</span><br><span class="line">            <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, fallbackDescriptor) &amp;&amp;</span><br><span class="line">                    (!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) &#123;</span><br><span class="line">                    addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.isEmpty() &amp;&amp; !multiple) &#123;</span><br><span class="line">                <span class="comment">// Consider self references as a final pass...</span></span><br><span class="line">                <span class="comment">// but in the case of a dependency collection, not the very same bean itself.</span></span><br><span class="line">                <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isSelfReference(beanName, candidate) &amp;&amp;</span><br><span class="line">                        (!(descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) || !beanName.equals(candidate)) &amp;&amp;</span><br><span class="line">                        isAutowireCandidate(candidate, fallbackDescriptor)) &#123;</span><br><span class="line">                        addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Add an entry to the candidate map: a bean instance if available or just the resolved</span></span><br><span class="line"><span class="comment">	 * type, preventing early bean initialization ahead of primary candidate selection.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCandidateEntry</span><span class="params">(Map&lt;String, Object&gt; candidates, String candidateName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   DependencyDescriptor descriptor, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) &#123;</span><br><span class="line">            Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                candidates.put(candidateName, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(candidateName) || (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor &amp;&amp;</span><br><span class="line">                                                      ((StreamDependencyDescriptor) descriptor).isOrdered())) &#123;</span><br><span class="line">            Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">            candidates.put(candidateName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            candidates.put(candidateName, getType(candidateName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the autowire candidate in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Looks for &#123;<span class="doctag">@code</span> <span class="doctag">@Primary</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@Priority</span>&#125; (in that order).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * that match the required type, as returned by &#123;<span class="doctag">@link</span> #findAutowireCandidates&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the target dependency to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the autowire candidate, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineAutowireCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; requiredType = descriptor.getDependencyType();</span><br><span class="line">        String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (primaryCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryCandidate;</span><br><span class="line">        &#125;</span><br><span class="line">        String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (priorityCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> priorityCandidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fallback</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> ((beanInstance != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.resolvableDependencies.containsValue(beanInstance)) ||</span><br><span class="line">                matchesBeanName(candidateName, descriptor.getDependencyName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidateName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the primary candidate in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * (or candidate classes if not created yet) that match the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the target dependency type to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the primary candidate, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isPrimary(String, Object)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determinePrimaryCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        String primaryBeanName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateBeanName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (isPrimary(candidateBeanName, beanInstance)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (primaryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> candidateLocal = containsBeanDefinition(candidateBeanName);</span><br><span class="line">                    <span class="keyword">boolean</span> primaryLocal = containsBeanDefinition(primaryBeanName);</span><br><span class="line">                    <span class="keyword">if</span> (candidateLocal &amp;&amp; primaryLocal) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                                                                  <span class="string">"more than one 'primary' bean found among candidates: "</span> + candidates.keySet());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (candidateLocal) &#123;</span><br><span class="line">                        primaryBeanName = candidateBeanName;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    primaryBeanName = candidateBeanName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primaryBeanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the candidate with the highest priority in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Based on &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.annotation.Priority&#125;. As defined by the related</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered&#125; interface, the lowest value has</span></span><br><span class="line"><span class="comment">	 * the highest priority.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * (or candidate classes if not created yet) that match the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the target dependency type to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the candidate with the highest priority,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPriority(Object)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineHighestPriorityCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        String highestPriorityBeanName = <span class="keyword">null</span>;</span><br><span class="line">        Integer highestPriority = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateBeanName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Integer candidatePriority = getPriority(beanInstance);</span><br><span class="line">                <span class="keyword">if</span> (candidatePriority != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (highestPriorityBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (candidatePriority.equals(highestPriority)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                                                                      <span class="string">"Multiple beans found with the same priority ('"</span> + highestPriority +</span><br><span class="line">                                                                      <span class="string">"') among candidates: "</span> + candidates.keySet());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (candidatePriority &lt; highestPriority) &#123;</span><br><span class="line">                            highestPriorityBeanName = candidateBeanName;</span><br><span class="line">                            highestPriority = candidatePriority;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        highestPriorityBeanName = candidateBeanName;</span><br><span class="line">                        highestPriority = candidatePriority;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> highestPriorityBeanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether the bean definition for the given bean name has been</span></span><br><span class="line"><span class="comment">	 * marked as a primary bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanInstance the corresponding bean instance (can be null)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the given bean qualifies as primary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">(String beanName, Object beanInstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getMergedLocalBeanDefinition(beanName).isPrimary();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">return</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory &amp;&amp;</span><br><span class="line">                ((DefaultListableBeanFactory) parent).isPrimary(beanName, beanInstance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the priority assigned for the given bean instance by</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@code</span> javax.annotation.Priority&#125; annotation.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation delegates to the specified</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> #setDependencyComparator dependency comparator&#125;, checking its</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> OrderComparator#getPriority method&#125; if it is an extension of</span></span><br><span class="line"><span class="comment">	 * Spring's common &#123;<span class="doctag">@link</span> OrderComparator&#125; - typically, an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.AnnotationAwareOrderComparator&#125;.</span></span><br><span class="line"><span class="comment">	 * If no such comparator is present, this implementation returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanInstance the bean instance to check (can be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the priority assigned to that bean or &#123;<span class="doctag">@code</span> null&#125; if none is set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">getPriority</span><span class="params">(Object beanInstance)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = getDependencyComparator();</span><br><span class="line">        <span class="keyword">if</span> (comparator <span class="keyword">instanceof</span> OrderComparator) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((OrderComparator) comparator).getPriority(beanInstance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given candidate name matches the bean name or the aliases</span></span><br><span class="line"><span class="comment">	 * stored in this bean definition.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesBeanName</span><span class="params">(String beanName, @Nullable String candidateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (candidateName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given beanName/candidateName pair indicates a self reference,</span></span><br><span class="line"><span class="comment">	 * i.e. whether the candidate points back to the original bean or to a factory method</span></span><br><span class="line"><span class="comment">	 * on the original bean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSelfReference</span><span class="params">(@Nullable String beanName, @Nullable String candidateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (beanName != <span class="keyword">null</span> &amp;&amp; candidateName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (beanName.equals(candidateName) || (containsBeanDefinition(candidateName) &amp;&amp;</span><br><span class="line">                                                    beanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName()))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException</span></span><br><span class="line"><span class="comment">	 * for an unresolvable dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">raiseNoMatchingBeanFound</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; type, ResolvableType resolvableType, DependencyDescriptor descriptor)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        checkBeanNotOfRequiredType(type, descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(resolvableType,</span><br><span class="line">                                                <span class="string">"expected at least 1 bean which qualifies as autowire candidate. "</span> +</span><br><span class="line">                                                <span class="string">"Dependency annotations: "</span> + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,</span></span><br><span class="line"><span class="comment">	 * i.e. if the target type of the bean would match but an exposed proxy doesn't.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkBeanNotOfRequiredType</span><span class="params">(Class&lt;?&gt; type, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            Class&lt;?&gt; targetType = mbd.getTargetType();</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; type.isAssignableFrom(targetType) &amp;&amp;</span><br><span class="line">                isAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) &#123;</span><br><span class="line">                <span class="comment">// Probably a proxy interfering with target type match -&gt; throw meaningful exception.</span></span><br><span class="line">                Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">                Class&lt;?&gt; beanType = (beanInstance != <span class="keyword">null</span> &amp;&amp; beanInstance.getClass() != NullBean<span class="class">.<span class="keyword">class</span> ?</span></span><br><span class="line">                                     beanInstance.getClass() : predictBeanType(beanName, mbd));</span><br><span class="line">                <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; !type.isAssignableFrom(beanType)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(beanName, type, beanType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            ((DefaultListableBeanFactory) parent).checkBeanNotOfRequiredType(type, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an &#123;<span class="doctag">@link</span> Optional&#125; wrapper for the specified dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;?&gt; createOptionalDependency(</span><br><span class="line">        DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName, <span class="keyword">final</span> Object... args) &#123;</span><br><span class="line"></span><br><span class="line">        DependencyDescriptor descriptorToUse = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :</span><br><span class="line">                        <span class="keyword">super</span>.resolveCandidate(beanName, requiredType, beanFactory));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object result = doResolveDependency(descriptorToUse, beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Optional ? (Optional&lt;?&gt;) result : Optional.ofNullable(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(ObjectUtils.identityToString(<span class="keyword">this</span>));</span><br><span class="line">        sb.append(<span class="string">": defining beans ["</span>);</span><br><span class="line">        sb.append(StringUtils.collectionToCommaDelimitedString(<span class="keyword">this</span>.beanDefinitionNames));</span><br><span class="line">        sb.append(<span class="string">"]; "</span>);</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"root of factory hierarchy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(<span class="string">"parent: "</span>).append(ObjectUtils.identityToString(parent));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Serialization support</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(<span class="string">"DefaultListableBeanFactory itself is not deserializable - "</span> +</span><br><span class="line">                                           <span class="string">"just a SerializedBeanFactoryReference is"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SerializedBeanFactoryReference(<span class="keyword">this</span>.serializationId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(<span class="string">"DefaultListableBeanFactory has no serialization id"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Minimal id reference to the factory.</span></span><br><span class="line"><span class="comment">	 * Resolved to the actual factory instance on deserialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedBeanFactoryReference</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SerializedBeanFactoryReference</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Reference&lt;?&gt; ref = serializableFactories.get(<span class="keyword">this</span>.id);</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object result = ref.get();</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lenient fallback: dummy factory in case of original factory not found...</span></span><br><span class="line">            DefaultListableBeanFactory dummyFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">            dummyFactory.serializationId = <span class="keyword">this</span>.id;</span><br><span class="line">            <span class="keyword">return</span> dummyFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor marker for nested elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedDependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">DependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NestedDependencyDescriptor</span><span class="params">(DependencyDescriptor original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">            increaseNestingLevel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor for a multi-element declaration with nested elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiElementDescriptor</span> <span class="keyword">extends</span> <span class="title">NestedDependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiElementDescriptor</span><span class="params">(DependencyDescriptor original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor marker for stream access to multiple elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">DependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StreamDependencyDescriptor</span><span class="params">(DependencyDescriptor original, <span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">            <span class="keyword">this</span>.ordered = ordered;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.ordered;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanObjectProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ObjectProvider</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyObjectProvider</span> <span class="keyword">implements</span> <span class="title">BeanObjectProvider</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DependencyDescriptor descriptor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> optional;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DependencyObjectProvider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor);</span><br><span class="line">            <span class="keyword">this</span>.optional = (<span class="keyword">this</span>.descriptor.getDependencyType() == Optional<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Object result = doResolveDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="keyword">this</span>.descriptor.getResolvableType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> beanFactory.getBean(beanName, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                Object result = doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="keyword">this</span>.descriptor.getResolvableType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@Nullable</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">resolveNotUnique</span><span class="params">(ResolvableType type, Map&lt;String, Object&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(descriptorToUse, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Stream&lt;Object&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolveStream(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Stream&lt;Object&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolveStream(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Stream&lt;Object&gt; <span class="title">resolveStream</span><span class="params">(<span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">            DependencyDescriptor descriptorToUse = <span class="keyword">new</span> StreamDependencyDescriptor(<span class="keyword">this</span>.descriptor, ordered);</span><br><span class="line">            Object result = doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Stream ? (Stream&lt;Object&gt;) result : Stream.of(result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Separate inner class for avoiding a hard dependency on the &#123;<span class="doctag">@code</span> javax.inject&#125; API.</span></span><br><span class="line"><span class="comment">	 * Actual &#123;<span class="doctag">@code</span> javax.inject.Provider&#125; implementation is nested here in order to make it</span></span><br><span class="line"><span class="comment">	 * invisible for Graal's introspection of DefaultListableBeanFactory's nested classes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Jsr330Factory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">createDependencyProvider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Provider(descriptor, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Jsr330Provider</span> <span class="keyword">extends</span> <span class="title">DependencyObjectProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Jsr330Provider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(descriptor, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * An &#123;<span class="doctag">@link</span> org.springframework.core.OrderComparator.OrderSourceProvider&#125; implementation</span></span><br><span class="line"><span class="comment">	 * that is aware of the bean metadata of the instances to sort.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Lookup for the method factory of an instance to sort, if any, and let the</span></span><br><span class="line"><span class="comment">	 * comparator retrieve the &#123;<span class="doctag">@link</span> org.springframework.core.annotation.Order&#125;</span></span><br><span class="line"><span class="comment">	 * value defined on it. This essentially allows for the following construct:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryAwareOrderSourceProvider</span> <span class="keyword">implements</span> <span class="title">OrderComparator</span>.<span class="title">OrderSourceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, String&gt; instancesToBeanNames;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FactoryAwareOrderSourceProvider</span><span class="params">(Map&lt;Object, String&gt; instancesToBeanNames)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.instancesToBeanNames = instancesToBeanNames;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getOrderSource</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            RootBeanDefinition beanDefinition = getRootBeanDefinition(<span class="keyword">this</span>.instancesToBeanNames.get(obj));</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Object&gt; sources = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            Method factoryMethod = beanDefinition.getResolvedFactoryMethod();</span><br><span class="line">            <span class="keyword">if</span> (factoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sources.add(factoryMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; targetType = beanDefinition.getTargetType();</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType != obj.getClass()) &#123;</span><br><span class="line">                sources.add(targetType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sources.toArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> RootBeanDefinition <span class="title">getRootBeanDefinition</span><span class="params">(@Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                BeanDefinition bd = getMergedBeanDefinition(beanName);</span><br><span class="line">                <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (RootBeanDefinition) bd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GenericApplicationContext-源码"><a class="header-anchor" href="#GenericApplicationContext-源码">¶</a><em>GenericApplicationContext 源码</em></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> customClassLoader = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean refreshed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the DefaultListableBeanFactory instance to use for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanFactory, <span class="string">"BeanFactory must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent the parent application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the DefaultListableBeanFactory instance to use for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent the parent application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory, ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(beanFactory);</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set the parent of this application context, also setting</span></span><br><span class="line"><span class="comment">	 * the parent of the internal BeanFactory accordingly.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setParent(parent);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setParentBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * If not, an exception will be thrown. Default is "true".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowBeanDefinitionOverriding</span><span class="params">(<span class="keyword">boolean</span> allowBeanDefinitionOverriding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether to allow circular references between beans - and automatically</span></span><br><span class="line"><span class="comment">	 * try to resolve them.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true". Turn this off to throw an exception when encountering</span></span><br><span class="line"><span class="comment">	 * a circular reference, disallowing them completely.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowCircularReferences</span><span class="params">(<span class="keyword">boolean</span> allowCircularReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setAllowCircularReferences(allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a ResourceLoader to use for this context. If set, the context will</span></span><br><span class="line"><span class="comment">	 * delegate all &#123;<span class="doctag">@code</span> getResource&#125; calls to the given ResourceLoader.</span></span><br><span class="line"><span class="comment">	 * If not set, default resource loading will apply.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The main reason to specify a custom ResourceLoader is to resolve</span></span><br><span class="line"><span class="comment">	 * resource paths (without URL prefix) in a specific fashion.</span></span><br><span class="line"><span class="comment">	 * The default behavior is to resolve such paths as class path locations.</span></span><br><span class="line"><span class="comment">	 * To resolve resource paths as file system locations, specify a</span></span><br><span class="line"><span class="comment">	 * FileSystemResourceLoader here.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;You can also pass in a full ResourcePatternResolver, which will</span></span><br><span class="line"><span class="comment">	 * be autodetected by the context and used for &#123;<span class="doctag">@code</span> getResources&#125;</span></span><br><span class="line"><span class="comment">	 * calls as well. Else, default resource pattern matching will apply.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getResource</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.DefaultResourceLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.FileSystemResourceLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.support.ResourcePatternResolver</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getResources</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ResourceLoader / ResourcePatternResolver override if necessary</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation delegates to this context's ResourceLoader if set,</span></span><br><span class="line"><span class="comment">	 * falling back to the default superclass behavior else.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getResource(location);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResource(location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation delegates to this context's ResourceLoader if it</span></span><br><span class="line"><span class="comment">	 * implements the ResourcePatternResolver interface, falling back to the</span></span><br><span class="line"><span class="comment">	 * default superclass behavior else.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ResourcePatternResolver) <span class="keyword">this</span>.resourceLoader).getResources(locationPattern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassLoader</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">this</span>.customClassLoader = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.customClassLoader) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementations of AbstractApplicationContext's template methods</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Do nothing: We hold a single internal BeanFactory and rely on callers</span></span><br><span class="line"><span class="comment">	 * to register beans through our public methods (or the BeanFactory's).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cancelRefresh</span><span class="params">(BeansException ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">super</span>.cancelRefresh(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Not much to do: We hold a single internal BeanFactory that will never</span></span><br><span class="line"><span class="comment">	 * get released.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the single internal BeanFactory held by this context</span></span><br><span class="line"><span class="comment">	 * (as ConfigurableListableBeanFactory).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the underlying bean factory of this context,</span></span><br><span class="line"><span class="comment">	 * available for registering bean definitions.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; You need to call &#123;<span class="doctag">@link</span> #refresh()&#125; to initialize the</span></span><br><span class="line"><span class="comment">	 * bean factory and its contained beans with application context semantics</span></span><br><span class="line"><span class="comment">	 * (autodetecting BeanFactoryPostProcessors, etc).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the internal bean factory (as DefaultListableBeanFactory)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> DefaultListableBeanFactory <span class="title">getDefaultListableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of BeanDefinitionRegistry</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.removeBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.isBeanNameInUse(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String beanName, String alias)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAlias</span><span class="params">(String alias)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.removeAlias(alias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlias</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.isAlias(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Convenient methods for registering individual beans</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, optionally customizing its</span></span><br><span class="line"><span class="comment">	 * bean definition metadata (typically declared as a lambda expression</span></span><br><span class="line"><span class="comment">	 * or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean (resolving a public constructor</span></span><br><span class="line"><span class="comment">	 * to be autowired, possibly simply the default constructor)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; beanClass, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line">        registerBean(<span class="keyword">null</span>, beanClass, <span class="keyword">null</span>, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean (resolving a public constructor</span></span><br><span class="line"><span class="comment">	 * to be autowired, possibly simply the default constructor)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String beanName, Class&lt;T&gt; beanClass, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registerBean(beanName, beanClass, <span class="keyword">null</span>, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> supplier a callback for creating an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;T&gt; beanClass, Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registerBean(<span class="keyword">null</span>, beanClass, supplier, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method can be overridden to adapt the registration mechanism for</span></span><br><span class="line"><span class="comment">	 * all &#123;<span class="doctag">@code</span> registerBean&#125; methods (since they all delegate to this one).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> supplier a callback for creating an instance of the bean (in case</span></span><br><span class="line"><span class="comment">	 * of &#123;<span class="doctag">@code</span> null&#125;, resolving a public constructor to be autowired instead)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(@Nullable String beanName, Class&lt;T&gt; beanClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassDerivedBeanDefinition beanDefinition = <span class="keyword">new</span> ClassDerivedBeanDefinition(beanClass);</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanDefinition.setInstanceSupplier(supplier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">            customizer.customize(beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String nameToUse = (beanName != <span class="keyword">null</span> ? beanName : beanClass.getName());</span><br><span class="line">        registerBeanDefinition(nameToUse, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> RootBeanDefinition&#125; marker subclass for &#123;<span class="doctag">@code</span> #registerBean&#125; based</span></span><br><span class="line"><span class="comment">	 * registrations with flexible autowiring for public constructors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDerivedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">RootBeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClassDerivedBeanDefinition</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(beanClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClassDerivedBeanDefinition</span><span class="params">(ClassDerivedBeanDefinition original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> Constructor&lt;?&gt;[] getPreferredConstructors() &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = getBeanClass();</span><br><span class="line">            Constructor&lt;?&gt; primaryCtor = BeanUtils.findPrimaryConstructor(clazz);</span><br><span class="line">            <span class="keyword">if</span> (primaryCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryCtor&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            Constructor&lt;?&gt;[] publicCtors = clazz.getConstructors();</span><br><span class="line">            <span class="keyword">if</span> (publicCtors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> publicCtors;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RootBeanDefinition <span class="title">cloneBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ClassDerivedBeanDefinition(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>todo: 未完待续…</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant知识点</title>
    <url>/2020/03/04/Vagrant%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-什么是vagrant"><a class="header-anchor" href="#1-什么是vagrant">¶</a><strong>1.什么是vagrant</strong></h2>
<p>vagrant 是一个通过命令行，来管理虚拟机的工具，vagrant 本身并没有提供虚拟化的功能，vagrant 可以用来管理virtualbox，可以通过vagrant 提供的命令创建，启动和关闭virtualbox里面的虚拟机</p>
<h2 id="2-为什么要使用vagrant"><a class="header-anchor" href="#2-为什么要使用vagrant">¶</a>2.<strong>为什么要使用vagrant</strong></h2>
<p>vagrant提供一个配置文件 vagrantfile,可以通过该配置文件快速创建或者复制一个虚拟机，同时是用命令行来管理虚拟机非常简单</p>
<h2 id="3-必须要有virtualbox才能正常安装vagrant"><a class="header-anchor" href="#3-必须要有virtualbox才能正常安装vagrant">¶</a>3.<strong>必须要有virtualbox才能正常安装vagrant</strong></h2>
<a id="more"></a>
<h2 id="4-vagrant常用命令"><a class="header-anchor" href="#4-vagrant常用命令">¶</a>4.<strong>vagrant常用命令</strong></h2>
<ul>
<li>
<p>初始化vagrant工程</p>
<p>vagrant init ubuntu/trusty64：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">该命令会在当前目录下创建vagrantfile,并且指定所使用的<span class="built_in">box</span>为ubuntu/trusty64，该<span class="built_in">box</span>由Hashicorp官网提供。此时，vagrant发现<span class="built_in">box</span>的名字的格式为<span class="string">"用户名/box名"</span>,则会使用<span class="string">"https://atlas.hashicorp.com/用户名/box名"</span>来下载该<span class="built_in">box</span>.</span><br><span class="line">对于非官网提供的<span class="built_in">box</span>，可以通过以下命令创建：</span><br><span class="line">vagrant init my-<span class="built_in">box</span> https://boxes.company.com/my.<span class="built_in">box</span>(其中，my-<span class="built_in">box</span>为该<span class="built_in">box</span>的名字，后面的URL为该<span class="built_in">box</span>的下载地址。)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关闭虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant halt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重启虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant reload</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>登录虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>挂起虚拟机(非常实用，节省内存)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant suspend</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>唤醒虚拟机</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vagrant resume</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看虚拟机状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant status</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant destroy</span><br><span class="line"></span><br><span class="line">注：vagrant destroy只会删除虚拟机本身，也即你在Virtualbox将看不到该虚拟机，但是不会删除该虚拟机所使用的box。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>列出本地所有的box</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant box list</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除某个box</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant box remove boxname</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-provision"><a class="header-anchor" href="#4-provision">¶</a>4.provision</h2>
<p>Provisioner 是 Vagrant 中的一个概念，表示用户在 Vagrantfile 中所提供的自动或手动执行的虚拟机任务。任务的类型也有很多种，比如执行 Shell 脚本，文件拷贝等等。</p>
<p>vagrant 执行特定任务的通用语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant provision --provision-with &lt;provisioner&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle VM VirtualBox + vagrant</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>shell</tag>
        <tag>vagrant</tag>
        <tag>快速部署</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2020/03/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1>2020-03-03 22:17</h1>
<p>我的博客系统上线啦！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
