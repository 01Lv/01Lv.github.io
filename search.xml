<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hutool工具类关于FileReader文件读取的见解</title>
    <url>/2020/06/09/Hutool%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%85%B3%E4%BA%8EFileReader%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E8%A7%81%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java之HttpServletResponse学习</title>
    <url>/2020/06/09/Java%E4%B9%8BHttpServletResponse%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="http://tomcat.apache.org/tomcat-7.0-doc/api/javax/servlet/http/HttpServletResponse.html" target="_blank" rel="noopener">HttpServletResponse官网</a></p>
<p><a href="https://www.cnblogs.com/xdp-gacl/p/3789624.html" target="_blank" rel="noopener">javaweb学习总结(七)——HttpServletResponse对象(一)</a></p>
<blockquote>
<p>excel 导出需要用到流的处理，不太熟悉，恶补下</p>
</blockquote>
<a id="more"></a>

<p>Web 服务器收到客户端的 http 请求,会针对每一次请求,分别创建一个用于代表请求的 request 对象，和代表响应的 response 对象</p>
<p>HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端 <strong>发送数据</strong>、<strong>发送响应头</strong>，<strong>发送响应状态码</strong> 的方法。</p>
<h2><span id="使用outputstream流向客户端浏览器输出中文数据">使用OutputStream流向客户端浏览器输出中文数据</span></h2><p><strong>使用OutputStream流输出中文注意问题：</strong></p>
<p>　　在服务器端，数据是以哪个码表输出的，那么就要控制客户端浏览器以相应的码表打开，比如：outputStream.write(“中国”.getBytes(“UTF-8”));使用OutputStream流向客户端浏览器输出中文，以UTF-8的编码进行输出，此时就要控制客户端浏览器以UTF-8的编码打开，否则显示的时候就会出现中文乱码，那么在服务器端如何控制客户端浏览器以以UTF-8的编码显示数据呢？可以通过设置响应头控制浏览器的行为，例如：response.setHeader(“content-type”, “text/html;charset=UTF-8”);通过设置响应头控制浏览器以UTF-8的编码显示数据。</p>
<p><strong>范例：使用OutputStream流向客户端浏览器输出”中国”这两个汉字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gacl.response.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDemo01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4312868947607181532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        outputChineseByOutputStream(response);<span class="comment">//使用OutputStream流输出中文</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用OutputStream流输出中文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputChineseByOutputStream</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">/**使用OutputStream输出中文注意问题：</span></span><br><span class="line"><span class="comment">         * 在服务器端，数据是以哪个码表输出的，那么就要控制客户端浏览器以相应的码表打开，</span></span><br><span class="line"><span class="comment">         * 比如：outputStream.write("中国".getBytes("UTF-8"));//使用OutputStream流向客户端浏览器输出中文，以UTF-8的编码进行输出</span></span><br><span class="line"><span class="comment">         * 此时就要控制客户端浏览器以UTF-8的编码打开，否则显示的时候就会出现中文乱码，那么在服务器端如何控制客户端浏览器以以UTF-8的编码显示数据呢？</span></span><br><span class="line"><span class="comment">         * 可以通过设置响应头控制浏览器的行为，例如：</span></span><br><span class="line"><span class="comment">         * response.setHeader("content-type", "text/html;charset=UTF-8");//通过设置响应头控制浏览器以UTF-8的编码显示数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String data = <span class="string">"中国"</span>;</span><br><span class="line">        OutputStream outputStream = response.getOutputStream();<span class="comment">//获取OutputStream输出流</span></span><br><span class="line">        response.setHeader(<span class="string">"content-type"</span>, <span class="string">"text/html;charset=UTF-8"</span>);<span class="comment">//通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * data.getBytes()是一个将字符转换成字节数组的过程，这个过程中一定会去查码表，</span></span><br><span class="line"><span class="comment">         * 如果是中文的操作系统环境，默认就是查找查GB2312的码表，</span></span><br><span class="line"><span class="comment">         * 将字符转换成字节数组的过程就是将中文字符转换成GB2312的码表上对应的数字</span></span><br><span class="line"><span class="comment">         * 比如： "中"在GB2312的码表上对应的数字是98</span></span><br><span class="line"><span class="comment">         *         "国"在GB2312的码表上对应的数字是99</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * getBytes()方法如果不带参数，那么就会根据操作系统的语言环境来选择转换码表，如果是中文操作系统，那么就使用GB2312的码表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] dataByteArr = data.getBytes(<span class="string">"UTF-8"</span>);<span class="comment">//将字符转换成字节数组，指定以UTF-8编码进行转换</span></span><br><span class="line">        outputStream.write(dataByteArr);<span class="comment">//使用OutputStream流向客户端输出字节数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="使用printwriter流向客户端浏览器输出中文数据">使用PrintWriter流向客户端浏览器输出中文数据</span></h3><p><strong>使用PrintWriter流输出中文注意问题：</strong></p>
<p>　　在获取PrintWriter输出流之前首先使用”response.setCharacterEncoding(charset)”设置字符以什么样的编码输出到浏览器，如：response.setCharacterEncoding(“UTF-8”);设置将字符以”UTF-8”编码输出到客户端浏览器，然后再使用response.getWriter();获取PrintWriter输出流，这两个步骤不能颠倒，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setCharacterEncoding(<span class="string">"UTF-8"</span>);<span class="comment">//设置将字符以"UTF-8"编码输出到客户端浏览器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* PrintWriter out = response.getWriter();这句代码必须放在response.setCharacterEncoding("UTF-8");之后</span></span><br><span class="line"><span class="comment">* 否则response.setCharacterEncoding("UTF-8")这行代码的设置将无效，浏览器显示的时候还是乱码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PrintWriter out = response.getWriter();<span class="comment">//获取PrintWriter输出流</span></span><br></pre></td></tr></table></figure>

<p>然后再使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头，控制浏览器以指定的字符编码编码进行显示，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码</span></span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>, <span class="string">"text/html;charset=UTF-8"</span>)</span><br></pre></td></tr></table></figure>

<p>除了可以使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头来控制浏览器以指定的字符编码编码进行显示这种方式之外，还可以用如下的方式来模拟响应头的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 多学一招：使用HTML语言里面的&lt;meta&gt;标签来控制浏览器行为，模拟通过设置响应头控制浏览器行为</span></span><br><span class="line"><span class="comment"> *response.getWriter().write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;");</span></span><br><span class="line"><span class="comment">* 等同于response.setHeader("content-type", "text/html;charset=UTF-8");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">response.getWriter().write(<span class="string">"&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>范例：使用PrintWriter流向客户端浏览器输出”中国”这两个汉字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDemo01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4312868947607181532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        outputChineseByPrintWriter(response);<span class="comment">//使用PrintWriter流输出中文</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用PrintWriter流输出中文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputChineseByPrintWriter</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        String data = <span class="string">"中国"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码</span></span><br><span class="line">        <span class="comment">//response.setHeader("content-type", "text/html;charset=UTF-8");</span></span><br><span class="line"></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);<span class="comment">//设置将字符以"UTF-8"编码输出到客户端浏览器</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * PrintWriter out = response.getWriter();这句代码必须放在response.setCharacterEncoding("UTF-8");之后</span></span><br><span class="line"><span class="comment">         * 否则response.setCharacterEncoding("UTF-8")这行代码的设置将无效，浏览器显示的时候还是乱码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PrintWriter out = response.getWriter();<span class="comment">//获取PrintWriter输出流</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 多学一招：使用HTML语言里面的&lt;meta&gt;标签来控制浏览器行为，模拟通过设置响应头控制浏览器行为</span></span><br><span class="line"><span class="comment">         * out.write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;");</span></span><br><span class="line"><span class="comment">         * 等同于response.setHeader("content-type", "text/html;charset=UTF-8");</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out.write(<span class="string">"&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;"</span>);</span><br><span class="line">        out.write(data);<span class="comment">//使用PrintWriter流向客户端输出字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="文件下载">文件下载</span></h2><p>文件下载功能是web开发中经常使用到的功能，使用HttpServletResponse对象就可以实现文件的下载</p>
<p>文件下载功能的实现思路：</p>
<ol>
<li>获取要下载的文件的绝对路径</li>
<li>获取要下载的文件名</li>
<li>设置 content-disposition响应头 <strong>控制</strong> 浏览器以下载的形式打开文件</li>
<li>获取要下载的文件输入流</li>
<li>创建数据缓冲区</li>
<li>通过response对象获取OutputStream流</li>
<li>将FileInputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区的数据输出到客户端浏览器</li>
</ol>
<p><strong>范例：使用Response实现文件下载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gacl.response.study;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gacl</span></span><br><span class="line"><span class="comment"> * 文件下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDemo02</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        downloadFileByOutputStream(response);<span class="comment">//下载文件，通过OutputStream流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件，通过OutputStream流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadFileByOutputStream</span><span class="params">(HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取要下载的文件的绝对路径</span></span><br><span class="line">        String realPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/download/1.JPG"</span>);</span><br><span class="line">        <span class="comment">//2.获取要下载的文件名</span></span><br><span class="line">        String fileName = realPath.substring(realPath.lastIndexOf(<span class="string">"\\"</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3.设置content-disposition响应头控制浏览器以下载的形式打开文件</span></span><br><span class="line">        response.setHeader(<span class="string">"content-disposition"</span>, <span class="string">"attachment;filename="</span>+fileName);</span><br><span class="line">        <span class="comment">//4.获取要下载的文件输入流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//5.创建数据缓冲区</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//6.通过response对象获取OutputStream流</span></span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        <span class="comment">//7.将FileInputStream流写入到buffer缓冲区</span></span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//8.使用OutputStream将缓冲区的数据输出到客户端浏览器</span></span><br><span class="line">            out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下载中文文件时，需要注意的地方就是中文文件名要使用URLEncoder.encode方法进行编码(URLEncoder.encode(fileName, “字符编码”))，否则会出现文件名乱码。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HttpServletResponse</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven项目整合Slf4j</title>
    <url>/2020/06/06/Maven%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88Slf4j/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/chw0629/article/details/80567936" target="_blank" rel="noopener">log4j:WARN No appenders could be found for logger 解决办法</a></p>
<blockquote>
<p>最近在使用 Maven 项目的时候(没有加入 Spring 的依赖)，所以日志系统需要手动配置继承到 Maven 项目当中去。</p>
</blockquote>
<a id="more"></a>

<h1><span id="依赖">依赖</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- slf4j-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j-log4j12 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="logproperties配置">log.properties配置</span></h1><p>将 <code>log.properties</code> 文件放到 <code>resouces</code> 下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration 开发时候建议使用 INFO,因为 debug 打印的日志太多，不好排查</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO, stdout</span></span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>= <span class="string">%d - %c -%-4r [%t] %-5p %c %x - %m%n</span></span><br></pre></td></tr></table></figure>

<p>然后在代码中就可以使用 <code>Slf4j</code> 组件了。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Slf4j</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Hutools工具类的使用</title>
    <url>/2020/06/05/Java%E4%B9%8BHutools%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://www.hutool.cn/" target="_blank" rel="noopener">hutool官网</a></p>
<blockquote>
<p>发现一个贼好用的 Java 工具类</p>
</blockquote>
<a id="more"></a>

<h1><span id="依赖">依赖</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hutool --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要用到的是 hutool 的 <strong>ExcelUtil</strong></p>
<h1><span id="读-excel">读 Excel</span></h1><blockquote>
<p>读取Excel内容的封装，通过构造ExcelReader对象，指定被读取的Excel文件、流或工作簿，然后调用readXXX方法读取内容为指定格式。</p>
</blockquote>
<p>读取为Bean列表，Bean中的字段名为标题，字段值为标题对应的单元格值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExcelReader reader = ExcelUtil.getReader(<span class="string">"d:/aaa.xlsx"</span>);</span><br><span class="line">List&lt;ExcelImportEntity&gt; all = reader.readAll(ExcelImportEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelImportEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String question;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="写-excel">写 Excel</span></h2><blockquote>
<p>Hutool将Excel写出封装为<code>ExcelWriter</code>，原理为包装了Workbook对象，每次调用<code>merge</code>（合并单元格）或者<code>write</code>（写出数据）方法后只是将数据写入到Workbook，并不写出文件，只有调用<code>flush</code>或者<code>close</code>方法后才会真正写出文件。</p>
<p>由于机制原因，在写出结束后需要关闭<code>ExcelWriter</code>对象，调用<code>close</code>方法即可关闭，此时才会释放Workbook对象资源，否则带有数据的Workbook一直会常驻内存。</p>
</blockquote>
<p>我是用写出 Bean 数据</p>
<p>JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelExportEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String col1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String col2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String col3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按官方指导文档的意思是，将需要写出到 excel 的 bean 构造成一个 List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestBean bean1 = <span class="keyword">new</span> TestBean();</span><br><span class="line">bean1.setName(<span class="string">"张三"</span>);</span><br><span class="line">bean1.setAge(<span class="number">22</span>);</span><br><span class="line">bean1.setPass(<span class="keyword">true</span>);</span><br><span class="line">bean1.setScore(<span class="number">66.30</span>);</span><br><span class="line">bean1.setExamDate(DateUtil.date());</span><br><span class="line"></span><br><span class="line">TestBean bean2 = <span class="keyword">new</span> TestBean();</span><br><span class="line">bean2.setName(<span class="string">"李四"</span>);</span><br><span class="line">bean2.setAge(<span class="number">28</span>);</span><br><span class="line">bean2.setPass(<span class="keyword">false</span>);</span><br><span class="line">bean2.setScore(<span class="number">38.50</span>);</span><br><span class="line">bean2.setExamDate(DateUtil.date());</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造为 List</span></span><br><span class="line">List&lt;TestBean&gt; rows = CollUtil.newArrayList(bean1, bean2);</span><br></pre></td></tr></table></figure>

<p>写出数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过工具类创建writer</span></span><br><span class="line">ExcelWriter writer = ExcelUtil.getWriter(<span class="string">"d:/writeBeanTest.xlsx"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义标题别名</span></span><br><span class="line">writer.addHeaderAlias(<span class="string">"name"</span>, <span class="string">"姓名"</span>);</span><br><span class="line">writer.addHeaderAlias(<span class="string">"age"</span>, <span class="string">"年龄"</span>);</span><br><span class="line">writer.addHeaderAlias(<span class="string">"score"</span>, <span class="string">"分数"</span>);</span><br><span class="line">writer.addHeaderAlias(<span class="string">"isPass"</span>, <span class="string">"是否通过"</span>);</span><br><span class="line">writer.addHeaderAlias(<span class="string">"examDate"</span>, <span class="string">"考试时间"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并单元格后的标题行，使用默认标题样式</span></span><br><span class="line">writer.merge(<span class="number">4</span>, <span class="string">"一班成绩单"</span>);</span><br><span class="line"><span class="comment">// 一次性写出内容，使用默认样式，强制输出标题</span></span><br><span class="line">writer.write(rows, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 关闭writer，释放内存</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200606144721205.png#pic_center" alt="240"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hutools</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之serialVersionUID学习</title>
    <url>/2020/06/05/Java%E4%B9%8BserialVersionUID%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u014750606/article/details/80040130" target="_blank" rel="noopener">java类中serialVersionUID的作用</a></p>
<blockquote>
<p>在接收请求参数和返回结果时，都会在相应的 DTO 上加上这个参数。这个参数在序列化和反序列化的时候发挥重要的作用</p>
</blockquote>
<a id="more"></a>

<p><code>serialVersionUID</code> 适用于 Java 的序列化机制。简单来说，Java 序列化机制是通过判断类的 <code>serialVersionUID</code> 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 <code>serialVersionUID</code> 与本地相应的实体类的 <code>serialVersionUID</code> 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即 <code>InvalidCastException</code>。</p>
<p><strong>具体序列化过程是这样的:</strong></p>
<p>序列化操作的时候系统会把当前类的 <code>serialVersionUID</code> 写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。</p>
<p><strong>serialVersionUID有两种显示的生成方式</strong>：</p>
<ol>
<li><p>是默认的1L，比如：private static final long serialVersionUID = 1L;     </p>
</li>
<li><p>根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如：   </p>
<p>private static final long  serialVersionUID = xxxxL;</p>
</li>
</ol>
<p>当实现java.io.Serializable接口的类没有显式地定义一个serialVersionUID变量时候，Java序列化机制会根据编译的Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID也不会变化的。</p>
<p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>serialVersionUID</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven打包可直接运行的jar</title>
    <url>/2020/06/05/Maven%E6%89%93%E5%8C%85%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E7%9A%84jar/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/xiao__gui/article/details/47341385?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">Maven生成可以直接运行的jar包的多种方式</a></p>
<blockquote>
<p>最近在做一个自动化工具，由于业务十分的简单，就不需要用到较臃肿的Spring 容器了。因为一个单纯的 maven 项目(不包含 Spring 依赖)，仅仅只有 12 k左右。</p>
</blockquote>
<a id="more"></a>

<p>Maven可以使用mvn package指令对项目进行打包，如果使用java -jar xxx.jar执行运行jar文件，会出现”no main manifest attribute, in xxx.jar”（没有设置Main-Class）、ClassNotFoundException（找不到依赖包）等错误。</p>
<p>要想jar包能直接通过java -jar xxx.jar运行，需要满足：</p>
<p>1、在jar包中的META-INF/MANIFEST.MF中指定Main-Class，这样才能确定程序的入口在哪里；</p>
<p>2、要能加载到依赖包。</p>
<p>使用Maven有以下几种方法可以生成能直接运行的jar包，可以根据需要选择一种合适的方法。</p>
<h1><span id="方法一使用maven-jar-plugin和maven-dependency-plugin插件打包">方法一：使用maven-jar-plugin和maven-dependency-plugin插件打包</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>配置自己的主类reference<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用到了lambda --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>maven-jar-plugin用于生成META-INF/MANIFEST.MF文件的部分内容，、&lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;：指定MANIFEST.MF中的Main-Class，、&lt;addClasspath&gt;true&lt;/addClasspath&gt;会在MANIFEST.MF加上Class-Path项并配置依赖包，&lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;指定依赖包所在目录。</p>
<p>例如下面是一个通过maven-jar-plugin插件生成的MANIFEST.MF文件片段：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span>-Path: <span class="keyword">lib</span>/commons-logging<span class="number">-1.2</span>.jar <span class="keyword">lib</span>/commons-io<span class="number">-2.4</span>.jar</span><br><span class="line">Main-<span class="keyword">Class</span>: com.xxg.Main</span><br></pre></td></tr></table></figure>

<p>只是生成MANIFEST.MF文件还不够，maven-dependency-plugin插件用于将依赖包拷贝到&lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;指定的位置，即lib目录下。</p>
<p>配置完成后，通过mvn package指令打包，会在target目录下生成jar包，并将依赖包拷贝到target/lib目录下，目录结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200605193157978.png#pic_center" alt="238"></p>
<p>指定了Main-Class，有了依赖包，那么就可以直接通过java -jar xxx.jar运行jar包。</p>
<p>这种方式生成jar包有个缺点，就是生成的jar包太多不便于管理，下面两种方式只生成一个jar文件，包含项目本身的代码、资源以及所有的依赖包。</p>
<h1><span id="方法二使用maven-assembly-plugin插件打包">方法二：使用maven-assembly-plugin插件打包</span></h1><p>在pom.xml中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.xxg.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">mvn package assembly:single</span><br></pre></td></tr></table></figure>

<p>打包后会在target目录下生成一个xxx-jar-with-dependencies.jar文件，这个文件不但包含了自己项目中的代码和资源，还包含了所有依赖包的内容。所以可以直接通过java -jar来运行。</p>
<p>此外还可以直接通过mvn package来打包，无需assembly:single，不过需要加上一些配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>主类的reference<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中&lt;phase&gt;package&lt;/phase&gt;、&lt;goal&gt;single&lt;/goal&gt;即表示在执行package打包时，执行assembly:single，所以可以直接使用mvn package打包。<br>不过，如果项目中用到Spring Framework，用这种方式打出来的包运行时会出错，使用下面的方法三可以处理。</p>
<h1><span id="方法三使用maven-shade-plugin插件打包">方法三：使用maven-shade-plugin插件打包</span></h1><p>在pom.xml中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.xxg.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，执行mvn package即可打包。在target目录下会生成两个jar包，注意不是original-xxx.jar文件，而是另外一个。和maven-assembly-plugin一样，生成的jar文件包含了所有依赖，所以可以直接运行。<br>如果项目中用到了Spring Framework，将依赖打到一个jar包中，运行时会出现读取XML schema文件出错。原因是Spring Framework的多个jar包中包含相同的文件spring.handlers和spring.schemas，如果生成一个jar包会互相覆盖。为了避免互相影响，可以使用AppendingTransformer来对文件内容追加合并：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.xxg.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.AppendingTransformer"</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.handlers<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.AppendingTransformer"</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.schemas<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="结果">结果</span></h1><p><img src="https://img-blog.csdnimg.cn/20200605193214711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="239"></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Maven打包</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之HttpClient的学习</title>
    <url>/2020/06/05/Java%E4%B9%8BHttpClient%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/justry_deng/article/details/81042379" target="_blank" rel="noopener">HttpClient详细使用示例</a></p>
<blockquote>
<p>最近有需求要开发一个自动化测试工具，由于业务需求十分简单，所以并没有通过搭建 SpringBoot 的服务来实现，只是简单的一个 maven 项目而已。所以之间用习惯的注解，容器管理bean等之类好用的方法都用不上了。根本就不需要容器，并不是一个 web 服务。所以 restemplate 种工具也用不上咯。只能使用 HttpClient 啦</p>
</blockquote>
<a id="more"></a>

<h1><span id="依赖">依赖</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="结果">结果</span></h1><p>参考模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * post请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String asr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    CloseableHttpClient httpClient = HttpClientBuilder.create().build();</span><br><span class="line">    </span><br><span class="line">    HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">"http://xxx"</span>);</span><br><span class="line"></span><br><span class="line">    PostEntity entity = <span class="keyword">new</span> PostEntity();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line"></span><br><span class="line">    String body = JSON.toJSONString(entity);</span><br><span class="line">    StringEntity post = <span class="keyword">new</span> StringEntity(body,<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="comment">//设置请求体</span></span><br><span class="line">    httpPost.setEntity(post);</span><br><span class="line">    <span class="comment">//设置请求头</span></span><br><span class="line">    httpPost.setHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf8"</span>);</span><br><span class="line">    <span class="comment">//响应模型</span></span><br><span class="line">    CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行post请求</span></span><br><span class="line">        response = httpClient.execute(httpPost);</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        HttpEntity responseEntity = response.getEntity();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"响应状态=&#123;&#125;"</span>,response.getStatusLine());</span><br><span class="line">        <span class="keyword">if</span>(responseEntity != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            log.debug(<span class="string">"响应内容长度为=&#123;&#125;"</span>,responseEntity.getContentLength());</span><br><span class="line"></span><br><span class="line">            String natResult = EntityUtils.toString(responseEntity, StandardCharsets.UTF_8);</span><br><span class="line">            log.info(<span class="string">"响应内容为=&#123;&#125;"</span>,natResult);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> natResult;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (httpClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合ElasticSearch</title>
    <url>/2020/06/03/SpringBoot%E6%95%B4%E5%90%88ElasticSearch/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/lifengdi/p/11554923.html" target="_blank" rel="noopener">SpringBoot整合Elasticsearch详细步骤以及代码示例（附源码）</a></p>
<p><a href="https://segmentfault.com/a/1190000018625101" target="_blank" rel="noopener">Elasticsearch实战篇——Spring Boot整合ElasticSearch</a></p>
<p><a href="https://www.jianshu.com/p/085f6da128a6" target="_blank" rel="noopener">第九篇 : SpringBoot 整合 elasticsearch</a></p>
<blockquote>
<p>之前一直是用 mongoDB 保存语音板的日志数据，偶然发现 ElasticSearch 也能实现业务需求。</p>
</blockquote>
<a id="more"></a>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8之Base64学习</title>
    <url>/2020/06/03/Java8%E4%B9%8BBase64%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.runoob.com/java/java8-base64.html" target="_blank" rel="noopener">Java8 Base64</a></p>
<p><a href="https://baike.baidu.com/item/base64/8545775?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
<blockquote>
<p>今天要处理老项目的迁移，由于当时没有搭建文件系统,所以只好将人脸的数据存储到通过Base64转码存储到数据库中。现在需要将这些用 Base64 编码的照片解码以后转为 byte[] 再存储到文件系统上。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>Base64是网络上最常见的用于传输8Bit<a href="https://baike.baidu.com/item/字节码/9953683" target="_blank" rel="noopener">字节码</a>的编码方式之一，Base64就是一种基于64个可打印字符来表示<a href="https://baike.baidu.com/item/二进制/361457" target="_blank" rel="noopener">二进制</a>数据的方法。</p>
</blockquote>
<h1><span id="编码">编码</span></h1><p><strong>Base64 编码是从二进制到字符的过程</strong>。</p>
<p>Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3*8 = 4*6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。</p>
<ul>
<li>关于这个编码的规则：</li>
</ul>
<p>①.把3个字节变成4个字节。</p>
<p>②每76个字符加一个换行符。</p>
<p>③.最后的结束符也要处理。</p>
<p>转换表</p>
<table>
<thead>
<tr>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
<th><strong>索引</strong></th>
<th><strong>对应字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><strong>A</strong></td>
<td>17</td>
<td><strong>R</strong></td>
<td>34</td>
<td><strong>i</strong></td>
<td>51</td>
<td><strong>z</strong></td>
</tr>
<tr>
<td>1</td>
<td><strong>B</strong></td>
<td>18</td>
<td><strong>S</strong></td>
<td>35</td>
<td><strong>j</strong></td>
<td>52</td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>2</td>
<td><strong>C</strong></td>
<td>19</td>
<td><strong>T</strong></td>
<td>36</td>
<td><strong>k</strong></td>
<td>53</td>
<td><strong>1</strong></td>
</tr>
<tr>
<td>3</td>
<td><strong>D</strong></td>
<td>20</td>
<td><strong>U</strong></td>
<td>37</td>
<td><strong>l</strong></td>
<td>54</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>4</td>
<td><strong>E</strong></td>
<td>21</td>
<td><strong>V</strong></td>
<td>38</td>
<td><strong>m</strong></td>
<td>55</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>5</td>
<td><strong>F</strong></td>
<td>22</td>
<td><strong>W</strong></td>
<td>39</td>
<td><strong>n</strong></td>
<td>56</td>
<td><strong>4</strong></td>
</tr>
<tr>
<td>6</td>
<td><strong>G</strong></td>
<td>23</td>
<td><strong>X</strong></td>
<td>40</td>
<td><strong>o</strong></td>
<td>57</td>
<td><strong>5</strong></td>
</tr>
<tr>
<td>7</td>
<td><strong>H</strong></td>
<td>24</td>
<td><strong>Y</strong></td>
<td>41</td>
<td><strong>p</strong></td>
<td>58</td>
<td><strong>6</strong></td>
</tr>
<tr>
<td>8</td>
<td><strong>I</strong></td>
<td>25</td>
<td><strong>Z</strong></td>
<td>42</td>
<td><strong>q</strong></td>
<td>59</td>
<td><strong>7</strong></td>
</tr>
<tr>
<td>9</td>
<td><strong>J</strong></td>
<td>26</td>
<td><strong>a</strong></td>
<td>43</td>
<td><strong>r</strong></td>
<td>60</td>
<td><strong>8</strong></td>
</tr>
<tr>
<td>10</td>
<td><strong>K</strong></td>
<td>27</td>
<td><strong>b</strong></td>
<td>44</td>
<td><strong>s</strong></td>
<td>61</td>
<td><strong>9</strong></td>
</tr>
<tr>
<td>11</td>
<td><strong>L</strong></td>
<td>28</td>
<td><strong>c</strong></td>
<td>45</td>
<td><strong>t</strong></td>
<td>62</td>
<td><strong>+</strong></td>
</tr>
<tr>
<td>12</td>
<td><strong>M</strong></td>
<td>29</td>
<td><strong>d</strong></td>
<td>46</td>
<td><strong>u</strong></td>
<td>63</td>
<td><strong>/</strong></td>
</tr>
<tr>
<td>13</td>
<td><strong>N</strong></td>
<td>30</td>
<td><strong>e</strong></td>
<td>47</td>
<td><strong>v</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td><strong>O</strong></td>
<td>31</td>
<td><strong>f</strong></td>
<td>48</td>
<td><strong>w</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><strong>P</strong></td>
<td>32</td>
<td><strong>g</strong></td>
<td>49</td>
<td><strong>x</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td><strong>Q</strong></td>
<td>33</td>
<td><strong>h</strong></td>
<td>50</td>
<td><strong>y</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">转换前 <span class="number">11111111</span>, <span class="number">11111111</span>, <span class="number">11111111</span> （二进制）</span><br><span class="line">转换后 <span class="number">00111111</span>, <span class="number">00111111</span>, <span class="number">00111111</span>, <span class="number">00111111</span> （二进制）</span><br><span class="line">上面的三个字节是原文，下面的四个字节是转换后的Base64编码，其前两位均为<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">转换前 <span class="number">10101101</span>,<span class="number">10111010</span>,<span class="number">01110110</span></span><br><span class="line">转换后 <span class="number">00101011</span>, <span class="number">00011011</span> ,<span class="number">00101001</span> ,<span class="number">00110110</span></span><br><span class="line">十进制 <span class="number">43</span> <span class="number">27</span> <span class="number">41</span> <span class="number">54</span></span><br><span class="line">对应码表中的值 r b p <span class="number">2</span></span><br><span class="line">所以上面的<span class="number">24</span>位编码，编码后的Base64值为 rbp2</span><br><span class="line">解码同理，把 rbq2 的二进制位连接上再重组得到三个<span class="number">8</span>位值，得出原码。</span><br></pre></td></tr></table></figure>

<h1><span id="解码">解码</span></h1><p>其实就是编码的逆序操作，待完善…</p>
<h1><span id="工具类和方法">工具类和方法</span></h1><p>Java 8 内置了 Base64 编码的编码器和解码器。</p>
<p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li><strong>基本：</strong>输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li><strong>URL：</strong>输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li><strong>MIME：</strong>输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h2><span id="内嵌类">内嵌类</span></h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">内嵌类 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>static class Base64.Decoder</strong>该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>static class Base64.Encoder</strong>该类实现一个编码器，使用 Base64 编码来编码字节数据。</td>
</tr>
</tbody></table>
<h2><span id="方法">方法</span></h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法名 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>static Base64.Decoder getDecoder()</strong>返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>static Base64.Encoder getEncoder()</strong>返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>static Base64.Decoder getMimeDecoder()</strong>返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>static Base64.Encoder getMimeEncoder()</strong>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</strong>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>static Base64.Decoder getUrlDecoder()</strong>返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>static Base64.Encoder getUrlEncoder()</strong>返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
</tbody></table>
<h2><span id="实例">实例</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 使用基本编码</span></span><br><span class="line">         String base64encodedString = Base64.getEncoder().encodeToString(<span class="string">"runoob?java8"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">         System.out.println(<span class="string">"Base64 编码字符串 (基本) :"</span> + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 解码</span></span><br><span class="line">         <span class="keyword">byte</span>[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">        </span><br><span class="line">         System.out.println(<span class="string">"原始字符串: "</span> + <span class="keyword">new</span> String(base64decodedBytes, <span class="string">"utf-8"</span>));</span><br><span class="line">         base64encodedString = Base64.getUrlEncoder().encodeToString(<span class="string">"runoob?java8"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">         System.out.println(<span class="string">"Base64 编码字符串 (URL) :"</span> + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">byte</span>[] mimeBytes = stringBuilder.toString().getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">         String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">         System.out.println(<span class="string">"Base64 编码字符串 (MIME) :"</span> + mimeEncodedString);</span><br><span class="line">         </span><br><span class="line">      &#125;<span class="keyword">catch</span>(UnsupportedEncodingException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"Error :"</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出以下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">原始字符串: runoob?java8</span><br><span class="line">Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg=</span><br><span class="line">Base64 编码字符串 (MIME) :M2Q4YmUxMTEtYWRkZi00NzBlLTgyZDgtN2MwNjgzOGY2NGFlOTQ3NDYyMWEtZDM4ZS00YWVhLTkz</span><br><span class="line">OTYtY2ZjMzZiMzFhNmZmOGJmOGI2OTYtMzkxZi00OTJiLWEyMTQtMjgwN2RjOGI0MTBmZWUwMGNk</span><br><span class="line">NTktY2ZiZS00MTMxLTgzODctNDRjMjFkYmZmNGM4Njg1NDc3OGItNzNlMC00ZWM4LTgxNzAtNjY3</span><br><span class="line">NTgyMGY3YzVhZWQyMmNiZGItOTIwZi00NGUzLTlkMjAtOTkzZTI1MjUwMDU5ZjdkYjg2M2UtZTJm</span><br><span class="line">YS00Y2Y2LWIwNDYtNWQ2MGRiOWQyZjFiMzJhMzYxOWQtNDE0ZS00MmRiLTk3NDgtNmM4NTczYjMx</span><br><span class="line">ZDIzNGRhOWU4NDAtNTBiMi00ZmE2LWE0M2ItZjU3MWFiNTI2NmQ2NTlmMTFmZjctYjg1NC00NmE1</span><br><span class="line">LWEzMWItYjk3MmEwZTYyNTdk</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-data-mongoDB之分页实现</title>
    <url>/2020/06/02/Spring-data-mongoDB%E4%B9%8B%E5%88%86%E9%A1%B5%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/24a44c4c7651" target="_blank" rel="noopener">spring data mongodb Query 及分页</a></p>
<p><a href="https://www.codeleading.com/article/655840925/" target="_blank" rel="noopener">Java使用MongoTemplate操作MangoDB，实现根据时间等条件组合查询，解决ISODate的问题</a></p>
<p><a href="https://www.cnblogs.com/Eilen/p/6939774.html" target="_blank" rel="noopener">Spring Data MongoDB 三：基本文档查询（Query、BasicQuery</a></p>
<blockquote>
<p>项目上开发有需求要用到对从 mongoDB 中查出的数据进行分页处理</p>
</blockquote>
<a id="more"></a>

<p>用到三个工具：<code>Query</code> , <code>Criteria</code> , <code>MongoTemplate</code></p>
<h1><span id="query">Query</span></h1><p> 构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Static factory method to create a &#123;<span class="doctag">@link</span> Query&#125; using the provided &#123;<span class="doctag">@link</span> CriteriaDefinition&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> criteriaDefinition must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Query <span class="title">query</span><span class="params">(CriteriaDefinition criteriaDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Query(criteriaDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Query</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Creates a new &#123;<span class="doctag">@link</span> Query&#125; using the given &#123;<span class="doctag">@link</span> CriteriaDefinition&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> criteriaDefinition must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Query</span><span class="params">(CriteriaDefinition criteriaDefinition)</span> </span>&#123;</span><br><span class="line">    addCriteria(criteriaDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受的参数是org.springframework.data.mongodb.core.query.Criteria</p>
<p><code>Criteria</code> 是标准查询接口，可以引用静态的 <code>Criteria.where</code> 把多个条件组合在一起。就可以轻松地将多个方法标准和查询连接起来，方便我们操作查询语句。</p>
<h2><span id="例子">例子</span></h2><ul>
<li>查询条件onumber=”002”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mongoTemplate.find (<span class="keyword">new</span> Query(Criteria.where(<span class="string">"onumber"</span>).is(<span class="string">"002"</span>)),entityClass)</span><br></pre></td></tr></table></figure>

<p>注：<code>entityClass</code> 为集合映射的实体哦！不是返回的dto</p>
<ul>
<li>多个条件组合查询时：onumber=”002” and cname=”zcy”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mongoTemplate.find (<span class="keyword">new</span> Query(Criteria.where(<span class="string">"onumber"</span>).is(<span class="string">"002"</span>).and(<span class="string">"cname"</span>).is(<span class="string">"zcy"</span>)),entityClass)</span><br></pre></td></tr></table></figure>

<ul>
<li>onumber=”002” or cname=”zcy”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mongoTemplate.findOne(newQuery(newCriteria().orOperator(Criteria.where(<span class="string">"onumber"</span>).is(<span class="string">"002"</span>),Criteria.where(<span class="string">"cname"</span>).is(<span class="string">"zcy"</span>))),entityClass);</span><br></pre></td></tr></table></figure>

<p>通过Criteria的and方法，把这个条件组合一起查询</p>
<table>
<thead>
<tr>
<th>Criteria</th>
<th>Mongodb</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Criteria and (String key)</td>
<td>$and</td>
<td>并且</td>
</tr>
<tr>
<td>Criteria andOperator (Criteria… criteria)</td>
<td>$and</td>
<td>并且</td>
</tr>
<tr>
<td>Criteria orOperator (Criteria… criteria)</td>
<td>$or</td>
<td>或者</td>
</tr>
<tr>
<td>Criteria gt (Object o)</td>
<td>$gt</td>
<td>大于</td>
</tr>
<tr>
<td>Criteria gte (Object o)</td>
<td>$gte</td>
<td>大于等于</td>
</tr>
<tr>
<td>Criteria in (Object… o)</td>
<td>$in</td>
<td>包含</td>
</tr>
<tr>
<td>Criteria is (Object o)</td>
<td>$is</td>
<td>等于</td>
</tr>
<tr>
<td>Criteria lt (Object o)</td>
<td>$lt</td>
<td>小于</td>
</tr>
<tr>
<td>Criteria lte (Object o)</td>
<td>$lte</td>
<td>小等于</td>
</tr>
<tr>
<td>Criteria nin (Object… o)</td>
<td>$nin</td>
<td>不包含</td>
</tr>
</tbody></table>
<h1><span id="mongotemplate">MongoTemplate</span></h1><p><a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html" target="_blank" rel="noopener">mongoDB官网</a></p>
<p><a href="https://juejin.im/post/5c3b3ba9e51d4551ec60a165" target="_blank" rel="noopener">SpringBoot之MongoTemplate的查询可以怎么耍</a></p>
<p>这次分页主要用到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">find</span><span class="params">(Query query, Class&lt;T&gt; entityClass, String collectionName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(query, <span class="string">"Query must not be null!"</span>);</span><br><span class="line">    Assert.notNull(collectionName, <span class="string">"CollectionName must not be null!"</span>);</span><br><span class="line">    Assert.notNull(entityClass, <span class="string">"EntityClass must not be null!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doFind(collectionName, query.getQueryObject(), query.getFieldsObject(), entityClass,</span><br><span class="line">                  <span class="keyword">new</span> QueryCursorPreparer(query, entityClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="结果">结果</span></h1><p>xxxServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;xxxDto&gt; <span class="title">listByPage</span><span class="params">(String sn, Long startTime,Long endTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   String json1, String json2, Integer pageNumber, Integer pageSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Query query = <span class="keyword">new</span> Query();</span><br><span class="line"></span><br><span class="line">    Sort sort = Sort.by(Sort.Direction.DESC,<span class="string">"xxxDate"</span>);</span><br><span class="line">    Pageable pageable = PageRequest.of(pageNumber,pageSize,sort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面有此方法</span></span><br><span class="line">    query.addCriteria(xxxCriteria.getCriteria(sn,startTime,endTime,json1,json2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里的 xxxEntity 是数据库集合映射的Java对象哦！不是返回的dto</span></span><br><span class="line">    <span class="keyword">long</span> total = mongoTemplate.count(query, xxxEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    log.info(<span class="string">"查询统计总条数=&#123;&#125;"</span>,total);</span><br><span class="line">    log.info(<span class="string">"分页参数=&#123;&#125;"</span>,pageable.getPageNumber() + <span class="string">";"</span> + pageable.getPageSize());</span><br><span class="line">    </span><br><span class="line">    query.with(pageable);</span><br><span class="line"></span><br><span class="line">    List&lt;xxxEntity&gt; xxxEntityList = mongoTemplate.find(query, xxxEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;xxxDTO&gt; result = xxxEntityList.stream().map(item -&gt; &#123;</span><br><span class="line">        xxxDto dto = <span class="keyword">new</span> xxxDto();</span><br><span class="line">        CglibBeanUtils.copy(dto, item);<span class="comment">//对象之间复制</span></span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line"></span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"查询结束=&#123;&#125;"</span>,result.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageImpl(result,pageable,total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xxxCriteria.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxCriteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">xxxCriteria</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Criteria <span class="title">getCriteria</span><span class="params">(String sn, Long startTime,Long endTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String json1, String json2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Criteria criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(sn))&#123;</span><br><span class="line"></span><br><span class="line">            criteria.and(<span class="string">"sn"</span>).regex(sn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(startTime != <span class="keyword">null</span> &amp;&amp; endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            String start = DateUtil.longToLongDate(startTime);</span><br><span class="line">            String end = DateUtil.longToLongDate(endTime);</span><br><span class="line"></span><br><span class="line">            criteria.and(<span class="string">"xxx"</span>).gte(DateUtil.DateToFormat(start)).lt(DateUtil.DateToFormat(end));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            String start = DateUtil.longToLongDate(startTime);</span><br><span class="line">            criteria.and(<span class="string">"xxx"</span>).gte(DateUtil.DateToFormat(start));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String end = DateUtil.longToLongDate(endTime);</span><br><span class="line">            criteria.and(<span class="string">"xxx"</span>).lt(DateUtil.DateToFormat(end));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(json1))&#123;</span><br><span class="line"></span><br><span class="line">            criteria.and(<span class="string">"json1"</span>).regex(json1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(json2))&#123;</span><br><span class="line"></span><br><span class="line">            criteria.and(<span class="string">"json2"</span>).regex(json2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> criteria;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Spring-data-mongoDB</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongodb之基础学习</title>
    <url>/2020/06/01/Mongodb%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.mongodb.com/" target="_blank" rel="noopener">mongodb官网</a></p>
<blockquote>
<p>最近有项目要要用到 mongodb, 可是之前虽然有了解，但连最基本的语法都不会。赶紧恶补。。</p>
</blockquote>
<a id="more"></a>

<p>mongodb 分为两部分</p>
<p><img src="https://img-blog.csdnimg.cn/2020060213535843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="237"></p>
<p>三大基础数据库</p>
<ul>
<li><code>admin</code> : 从权限角度来看，这是 “root” 数据库。要是将一个用户添加到这个数据库。这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有数据库或者关闭服务器</li>
<li><code>local</code> : 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li><code>config</code> : 当 Mongo 用于分片设置时，config 数据库在内部使用，用于保存分片相关信息</li>
</ul>
<h1><span id="查询">查询</span></h1><p><a href="https://www.runoob.com/mongodb/mongodb-query.html" target="_blank" rel="noopener">MongoDB 查询文档</a></p>
<ul>
<li><code>find()</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">db.集合名.find(&#123;字段名:字段值&#125;)，例如：db.comment.find(&#123;articleId:<span class="string">"1001"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">db.col.find().pretty()</span><br></pre></td></tr></table></figure>

<p>pretty() 方法以格式化的方式来显示所有文档。</p>
<p>以下实例我们查询了集合 col 中的数据：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt; db.col.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"_id"</span> : ObjectId(<span class="string">"56063f17ade2f21f36b03133"</span>),</span><br><span class="line">        <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line">        <span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line">        <span class="string">"by"</span> : <span class="string">"菜鸟教程"</span>,</span><br><span class="line">        <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">        <span class="string">"tags"</span> : [</span><br><span class="line">                <span class="string">"mongodb"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"likes"</span> : <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档</p>
<h2><span id="mongodb-与-rdbms-where-语句比较">MongoDB 与 RDBMS Where 语句比较</span></h2><p>如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">格式</th>
<th align="left">范例</th>
<th align="left">RDBMS中的类似语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">等于</td>
<td align="left">{&lt;key&gt;:&lt;value&gt;}</td>
<td align="left"><code>db.col.find({&quot;by&quot;:&quot;菜鸟教程&quot;}).pretty()</code></td>
<td align="left"><code>where by = &#39;菜鸟教程&#39;</code></td>
</tr>
<tr>
<td align="left">小于</td>
<td align="left">{&lt;key&gt;:{$lt:&lt;value&gt;}}</td>
<td align="left"><code>db.col.find({&quot;likes&quot;:{$lt:50}}).pretty()</code></td>
<td align="left"><code>where likes &lt; 50</code></td>
</tr>
<tr>
<td align="left">小于或等于</td>
<td align="left">{&lt;key&gt;:{$lte:&lt;value&gt;}}</td>
<td align="left"><code>db.col.find({&quot;likes&quot;:{$lte:50}}).pretty()</code></td>
<td align="left"><code>where likes &lt;= 50</code></td>
</tr>
<tr>
<td align="left">大于</td>
<td align="left">{&lt;key&gt;:{$gt:&lt;value&gt;}}</td>
<td align="left"><code>db.col.find({&quot;likes&quot;:{$gt:50}}).pretty()</code></td>
<td align="left"><code>where likes &gt; 50</code></td>
</tr>
<tr>
<td align="left">大于或等于</td>
<td align="left">{&lt;key&gt;:{$gte:&lt;value&gt;}}</td>
<td align="left"><code>db.col.find({&quot;likes&quot;:{$gte:50}}).pretty()</code></td>
<td align="left"><code>where likes &gt;= 50</code></td>
</tr>
<tr>
<td align="left">不等于</td>
<td align="left">{&lt;key&gt;:{$ne:&lt;value&gt;}}</td>
<td align="left"><code>db.col.find({&quot;likes&quot;:{$ne:50}}).pretty()</code></td>
<td align="left"><code>where likes != 50</code></td>
</tr>
</tbody></table>
<h2><span id="and">AND</span></h2><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。</p>
<p>语法格式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure>

<p>以下实例通过 <strong>by</strong> 和 <strong>title</strong> 键来查询 <strong>菜鸟教程</strong> 中 <strong>MongoDB 教程</strong> 的数据</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; db.col.<span class="builtin-name">find</span>(&#123;<span class="string">"by"</span>:<span class="string">"菜鸟教程"</span>, <span class="string">"title"</span>:<span class="string">"MongoDB 教程"</span>&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"_id"</span> : ObjectId(<span class="string">"56063f17ade2f21f36b03133"</span>),</span><br><span class="line">        <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line">        <span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line">        <span class="string">"by"</span> : <span class="string">"菜鸟教程"</span>,</span><br><span class="line">        <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">        <span class="string">"tags"</span> : [</span><br><span class="line">                <span class="string">"mongodb"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例中类似于 WHERE 语句：<strong>WHERE by=’菜鸟教程’ AND title=’MongoDB 教程’</strong></p>
<h2><span id="or">OR</span></h2><p>MongoDB OR 条件语句使用了关键字 <strong>$or</strong>,语法格式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt;db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure>

<p>以下实例中，我们演示了查询键 <strong>by</strong> 值为 菜鸟教程 或键 <strong>title</strong> 值为 <strong>MongoDB 教程</strong> 的文档。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;db.col.<span class="builtin-name">find</span>(&#123;<span class="variable">$or</span>:[&#123;<span class="string">"by"</span>:<span class="string">"菜鸟教程"</span>&#125;,&#123;<span class="string">"title"</span>: <span class="string">"MongoDB 教程"</span>&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"_id"</span> : ObjectId(<span class="string">"56063f17ade2f21f36b03133"</span>),</span><br><span class="line">        <span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line">        <span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line">        <span class="string">"by"</span> : <span class="string">"菜鸟教程"</span>,</span><br><span class="line">        <span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line">        <span class="string">"tags"</span> : [</span><br><span class="line">                <span class="string">"mongodb"</span>,</span><br><span class="line">                <span class="string">"database"</span>,</span><br><span class="line">                <span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="插入">插入</span></h1><p><a href="https://www.runoob.com/mongodb/mongodb-insert.html" target="_blank" rel="noopener">MongoDB 插入文档</a></p>
<p>文档的数据结构格式和 <code>JSON</code> 基本一样</p>
<p>所有存储在集合中的数据都是 <code>BSON</code> 格式。</p>
<p><strong>BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称。</strong></p>
<p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(<span class="built_in">document</span>)</span><br><span class="line">或</span><br><span class="line">db.COLLECTION_NAME.save(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 <strong>db.collection.insertOne()</strong> 或 <strong>db.collection.replaceOne()</strong> 来代替。</li>
<li>insert(): 若插入的数据主键已经存在，则会抛 <strong>org.springframework.dao.DuplicateKeyException</strong> 异常，提示主键重复，不保存当前数据。</li>
</ul>
<p><strong>3.2 版本之后新增了 db.collection.insertOne() 和 db.collection.insertMany()。</strong></p>
<p>db.collection.insertOne() 用于向集合插入一个新文档，语法格式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">db.collection.insertOne(</span><br><span class="line">   &lt;<span class="built_in">document</span>&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;<span class="built_in">document</span>&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>db.collection.insertMany() 用于向集合插入一个多个文档，语法格式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">db.collection.insertMany(</span><br><span class="line">   [ &lt;<span class="built_in">document</span> <span class="number">1</span>&gt; , &lt;<span class="built_in">document</span> <span class="number">2</span>&gt;, ... ],</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;<span class="built_in">document</span>&gt;,</span><br><span class="line">      ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>document：要写入的文档。</li>
<li>writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。</li>
<li>ordered：指定是否按顺序写入，默认 true，按顺序写入。</li>
</ul>
<p>以下文档可以存储在 MongoDB 的 runoob 数据库 的 col 集合中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt;db.col.insert(&#123;title: <span class="string">'MongoDB 教程'</span>, </span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'菜鸟教程'</span>,</span><br><span class="line">    url: <span class="string">'http://www.runoob.com'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上实例中 col 是我们的集合名，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7下安装mongodb</title>
    <url>/2020/06/01/Centos7%E4%B8%8B%E5%AE%89%E8%A3%85mongodb/</url>
    <content><![CDATA[<p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">官网下载</a></p>
<p><a href="https://www.runoob.com/mongodb/mongodb-linux-install.html" target="_blank" rel="noopener">Linux平台安装MongoDB</a></p>
<blockquote>
<p>我是使用 tgz 包来安装 mongodb的。系统：Centos7</p>
</blockquote>
<a id="more"></a>

<h1><span id="安装">安装</span></h1><p>把从官网下载下来的tgz包安装到指定文件夹，解压得到的目录结构如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200601123431568.png#pic_center" alt="235"></p>
<p>进入 <code>/bin</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200601123446548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="236"></p>
<p>配置 <code>/etc/profile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mongodb</span></span><br><span class="line">export MONGODB_HOME=mongodb的安装路径</span><br><span class="line">export PATH=$&#123;MONGODB_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>记得 <code>source /etc/profile</code></p>
<ul>
<li><code>mongod</code> : 相当于服务端，它打印的日志显示它在等待连接…</li>
<li><code>mongo</code> : 相当于客户端</li>
</ul>
<h1><span id="配置">配置</span></h1><p>配置用户名/密码，设置登录需验证</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">admin</span>  </span><br><span class="line">db.createUser(&#123;</span><br><span class="line">  <span class="keyword">user</span>: <span class="string">'admin'</span>,  // 用户名</span><br><span class="line">  pwd: <span class="string">'123456'</span>,  // 密码</span><br><span class="line">  <span class="keyword">roles</span>:[&#123;</span><br><span class="line">    <span class="keyword">role</span>: <span class="string">'root'</span>,  // 角色</span><br><span class="line">    db: <span class="string">'admin'</span>  // 数据库</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我把配置文件 <code>mongodb.conf</code> 放在了 <code>/bin</code> 目录下</p>
<p>mongodb.conf</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">port=<span class="number">27017</span> #端口</span><br><span class="line">dbpath=/xxx/db #数据库文件路径</span><br><span class="line"></span><br><span class="line">logappend=<span class="keyword">true</span> #日志追加</span><br><span class="line">fork=<span class="keyword">true</span> #是否以守护进程启动，即后台运行</span><br><span class="line">logpath=/xxx/mongodb.log #日志文件路径</span><br><span class="line">bind_ip=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> #任意ip可以访问</span><br><span class="line">auth=<span class="keyword">true</span> #是否授权访问</span><br></pre></td></tr></table></figure>

<h1><span id="启动">启动</span></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongodb启动命令: mongod -f ./mongodb.conf</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# mongod -f ./mongodb.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 232000</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure>

<h1><span id="系统内置角色请参考">系统内置角色请参考</span></h1><p><a href="https://www.cnblogs.com/dbabd/p/10811523.html" target="_blank" rel="noopener">MongoDB 4.X 用户和角色权限管理总结</a></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Rpm基础与原理的学习</title>
    <url>/2020/05/30/Rpm%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/d021380f6d02" target="_blank" rel="noopener">Linux软件安装管理之——RPM与YUM详解</a></p>
<a id="more"></a>

<h1><span id="简介">简介</span></h1><p>RPM 命名：”RedHat Package Manager”，简称为 <code>RPM</code>。这个机制最早由Red Hat这家公司开发出来的，后来实在很好用，因此很多distributons就使用这个机制来作为软件安装的管理方式，包括Fedora，CentOS，SuSE等知名的开发商都是用它。</p>
<p>RPM 最大的特点就是需要安装的软件已经编译过，并已经打包成 RPM 机制的安装包,通过里头默认的数据库记录这个软件安装时需要的依赖软件。当安装在你的Linux主机时，RPM会先依照软件里头的数据查询Linux主机的依赖属性软件是否满足，若满足则予以安装，若不满足则不予安装。</p>
<h1><span id="优缺点">优缺点</span></h1><p>优点：</p>
<blockquote>
<p>1）软件已经编译打包，所以传输和安装方便，让用户免除编译</p>
<p>2）在安装之前，会先检查系统的磁盘、操作系统版本等，避免错误安装</p>
<p>3）软件的信息都已经记录在linux主机的数据库上，方便查询、升级和卸载</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1）软件包安装的环境必须与打包时的环境一致或相当</p>
<p>2）必须安装了软件的依赖软件</p>
<p>3）卸载时，最底层的软件不能先移除，否则可能造成整个系统不能用</p>
</blockquote>
<h1><span id="命名的含义">命名的含义</span></h1><p>RPM包的命名格式：</p>
<blockquote>
<p>软件名称-版本号-发布次数.适合linux系统.硬件平台.rpm</p>
</blockquote>
<p>例如：ftp-0.17-74.fc27.i686.rpm</p>
<p><em>注意：</em></p>
<p>包全名：rpm操作没有安装的软件包，软件包使用的是包全名</p>
<p>包   名：rpm操作的已经安装的软件，软件包使用的是包名</p>
<p>例如上面的例子，包全名为ftp-0.17-74.fc27.i686.rpm，包名为ftp。</p>
<h1><span id="安装软件的默认路径">安装软件的默认路径</span></h1><blockquote>
<p>/etc 配置文件放置目录</p>
<p>/usr/bin 一些可执行文件</p>
<p>/usr/lib 一些程序使用的动态链接库</p>
<p>/usr/share/doc 一些基本的软件使用手册与说明文件</p>
<p>/usr/share/man 一些man page档案</p>
</blockquote>
<h1><span id="安装原理">安装原理</span></h1><p><img src="https://img-blog.csdnimg.cn/20200601085127629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="234"></p>
<h1><span id="命令">命令</span></h1><p><strong>1.软件安装（install）</strong></p>
<p>​    如你需要安装一个emac编辑器，首先要到网上下载一个emac的rpm包，如emacs-25.3-1.fc28.aarch64.rpm。最简单的安装命令如下：</p>
<blockquote>
<p>rpm -i emacs-25.3-1.fc28.aarch64.rpm</p>
</blockquote>
<p>不过，这样的参数其实无法显示安装的进度，所以通常我们执行的命令是这样：</p>
<p>rpm -ivh package-name</p>
<p>参数说明（后面括号内为英文说明）：</p>
<p>-i：install的意思，安装</p>
<p>-v：查看更详细的安装信息画面（provide more detailed output）</p>
<p>-h：以安装信息栏显示安装进度</p>
<blockquote>
<p>rpm -ivh emacs-25.3-1.fc28.aarch64.rpm</p>
</blockquote>
<p>如果想安装多个用空格间隔然后接上要安装的rpm包即可，同时也支持通过网址的资源来安装。</p>
<p><strong>2、软件升级</strong></p>
<p>参数说明（后面括号内为英文说明）：</p>
<p>-U：upgrade的意思，更新软件，若系统中没有该软件则进行安装（upgrade package(s)）</p>
<p>-F：freshen的意思，更新系统已安装的某个软件（upgrade package(s) if already instaalled）</p>
<blockquote>
<p>rpm –Uvh foo-2.0-1.i386.rpm</p>
</blockquote>
<p><strong>3、查询模式</strong></p>
<p>​    RPM在查询的时候，其实查询的地方是/var/lib/rpm/这个目录下的数据库文件。另外，RPM也可以查询未安装的RPM文件内的信息。</p>
<p>​    RPM的查询语法为：</p>
<blockquote>
<p>rpm {-q|–query} [select-options] [query-options]</p>
</blockquote>
<p>常用参数说明（后面括号内为英文说明）：</p>
<p>-a：all，列出已经安装在本机的所有软件（Query all instaled packages.）</p>
<p>-p：package，查询一个RPM文件的信息（Query an (uninstalled) package. ）</p>
<p>-f：file，由后面接的文件名称找出该文件属于哪狐假虎威已安装的软件（Query package owning file.）</p>
<p>-i：information，列出该软件的详细信息，包含开发商、版本与说明等（Display package information, including name, version, and description.）</p>
<p>-l：list，列出该软件所有的文件与目录所在完整文件名（List file in package）</p>
<p>-c：configuration，列出该软件的所有设置文件(找出在/etc/下面的文件名而已)（List only configuration files）</p>
<p>-d：documentation，列出该软件所有的帮助文档（List only documentation files）</p>
<p>-R：required，列出与该软件有关的依赖软件所含的文件（List capabilities on which this depends.）</p>
<p>注意：在查询的部分，所有的参数之前都要加上-q才是所谓的查询。</p>
<p>使用案例：</p>
<blockquote>
<p>1）查询你的Linux是否有安装某个软件</p>
<p>rpm -q yum</p>
<p>2）查询属于该软件所提供的所有目录与文件</p>
<p>rpm -ql yum</p>
<p>rpm -qc yum  #仅列出该软件的所有设置文件</p>
<p>rpm -qd yum  #仅列出该软件的所有帮助文档</p>
<p>3）列出gcc这个软件的相关数据说明</p>
<p>rpm -qi gcc</p>
<p>4）找出/bin/sh是由哪个软件提供的</p>
<p>rpm -qf /bin/sh</p>
<p>5）假设我有下载一个RPM文件,包名为wget-1.19.1-3.fc27.aarc64.rpm，想要知道该文件的需求文件，该如何办？</p>
<p>rpm -qpR wget-1.19.1-3.fc27.aarc64.rpm</p>
</blockquote>
<p><strong>4、卸载软件</strong></p>
<p>​    使用rpm的卸载过程一定要由最上层往下卸载，以rp-pppoe为例，这个软件主要是依据ppp这个软件来安装的，所以当你要卸载ppp的时候，就必须先卸载rp-pppoe才行！</p>
<p>​     删除的命令非常简单，通过-e参数就可以完成。不过，很常发生软件属性依赖导致无法山洼某些软件的问题。</p>
<p>例子：</p>
<blockquote>
<p>rpm -e gcc</p>
</blockquote>
<p>​    欲了解rpm的更多使用方法，可以自行去查阅rpm的man手册，这里只是列出了一些常用的操作。</p>
]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch之rpm包安装</title>
    <url>/2020/05/29/Elasticsearch%E4%B9%8Brpm%E5%8C%85%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/running-elasticsearch.html" target="_blank" rel="noopener">elastic 官网</a></p>
<blockquote>
<p>本次安装基于 Centos7</p>
</blockquote>
<a id="more"></a>]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Kibana之rpm包安装</title>
    <url>/2020/05/29/Kibana%E4%B9%8Brpm%E5%8C%85%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><a href="https://www.elastic.co/guide/cn/kibana/current/rpm.html" target="_blank" rel="noopener">Kibana rpm安装</a></p>
<blockquote>
<p>本次安装是基于 Centos7 安装</p>
</blockquote>
<a id="more"></a>]]></content>
      <categories>
        <category>Kibana</category>
      </categories>
      <tags>
        <tag>Kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级日志采集器filebeat见解</title>
    <url>/2020/05/28/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8filebeat%E8%A7%81%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.elastic.co/cn/beats/filebeat" target="_blank" rel="noopener">filebeat官网</a></p>
<p><a href="https://www.jianshu.com/p/1d29cd57b020" target="_blank" rel="noopener">centos7安装filebeat</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1634020" target="_blank" rel="noopener">Filebeat 收集日志的那些事儿</a></p>
<blockquote>
<p>最近项目组的大佬突然跟我说要搭一个日志采集系统，方便看日志。。。，好的，马上去搭建一个日志系统</p>
</blockquote>
<a id="more"></a>

<p>Q1: 既然filebeat可以直接把数据发送到es，为什么还要经过logstash呢？</p>
<ul>
<li>是因为filebeat没有filter，它是一个轻量级搬运工</li>
</ul>
<p>Q2: 既然logstash也可以从文件收集数据，为什么还要使用filebeat呢？</p>
<ul>
<li>filebeat是一个ELK官方推出的轻量级日志收集工具，用go语言编写，相比logstash占用资源更少，安装也更方便，可以通过包管理直接安装。缺点是不具备logstash的filter。8线程8GB内存下，logstash常驻内存660M（JAVA），filebeat常驻内存不到30M（GO），还不到logstash的零头。考虑logstash可能对生产应用存在影响，常采用filebeat替换logstash在服务器本地进行日志采集，然后输出到ELK端的logstash，filter由ELK端logstash完成。</li>
</ul>
<h1><span id="安装">安装</span></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf filebeat-7.x-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h1><span id="配置-filebeat">配置 filebeat</span></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /home/xxx/tools/filebeat/conf/filebeat.yml</span><br></pre></td></tr></table></figure>

<p>由于 logstash 消耗服务器的资源比较高，且我们暂时来说还没有 <strong>过滤的需求</strong>(logstash 强大之处), 所以没有该配置项</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#直连kibana</span></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">"172.17.2.89:5601"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#直连es</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["172.17.2.89:9200"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连接logstash  5044是logstash配置文件中input.beats.port的配置值</span></span><br><span class="line"><span class="comment">#output.logstash:</span></span><br><span class="line">  <span class="comment">#hosts: ["172.17.2.89:5044"]</span></span><br></pre></td></tr></table></figure>

<h1><span id="启动">启动</span></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/xxx/tools/filebeat/filebeat-7.7.0-linux-x86_64/filebeat -c ./filebeat.yml &amp;</span><br></pre></td></tr></table></figure>

<h1><span id="结果">结果</span></h1><p><img src="https://img-blog.csdnimg.cn/20200528202756369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="231"></p>
<h1><span id="原理">原理</span></h1><h2><span id="filebeat能做什么">FileBeat能做什么</span></h2><ul>
<li>Filebeat可以从多种不同的上游<strong>input</strong> 中接受需要收集的数据，可以从<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Fbeats%2Ffilebeat%2Fcurrent%2Fconfiguration-filebeat-options.html%23filebeat-input-types" target="_blank" rel="noopener">这里</a>看到当前所有被支持的input，其中我们最常用的就是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Fbeats%2Ffilebeat%2Fcurrent%2Ffilebeat-input-log.html" target="_blank" rel="noopener">log input</a>了，即从日志文件中收集数据；</li>
<li>Filebeat对收集来的数据进行加工，比如：多行合并，增加业务自定义字段，json等格式的encode;</li>
<li>Filebeat将加工好的数据发送到被称为<strong>output</strong>的下游，在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Fbeats%2Ffilebeat%2Fcurrent%2Fconfiguring-output.html" target="_blank" rel="noopener">这里</a>可以看到所有当前被支持的output， 其中我们最常用到的就是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Fbeats%2Ffilebeat%2Fcurrent%2Felasticsearch-output.html" target="_blank" rel="noopener">Elasticsearch</a>, <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Fbeats%2Ffilebeat%2Fcurrent%2Fkafka-output.html" target="_blank" rel="noopener">Kafka</a>了；</li>
<li>Filebeat具有ACK反馈确认机制，即成功发送到output后，会将当前进度反馈给input, 这样在进程重启后可以断点续传；</li>
<li>Filebeat在发送output失败后，会启动retry机制，和上一次ACK反馈确认机制一起，保证了每次消息<code>至少发送一次</code>的语义；</li>
<li>Filebeat在发送output时，由于网络等原因发生阻塞，则在input上游端会减慢收集，自适应匹配下游output的状态；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020052923110348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="232"></p>
<h2><span id="filebeat-背后的老大">FileBeat 背后的老大</span></h2><p>说到Filebeat，它其实只是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Felastic%2Fbeats%2Ftree%2Fmaster%2Flibbeat" target="_blank" rel="noopener">beats家族</a>众多成员中的一个。除了Filebeat, 还有很多其他的beat小伙伴：</p>
<table>
<thead>
<tr>
<th align="left">beat</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Filebeat</td>
<td align="left">收集日志文件</td>
</tr>
<tr>
<td align="left">Metricbeat</td>
<td align="left">收集各种指标数据</td>
</tr>
<tr>
<td align="left">Packetbeat</td>
<td align="left">收集网络数据包</td>
</tr>
<tr>
<td align="left">Auditbeat</td>
<td align="left">收集审计数据</td>
</tr>
<tr>
<td align="left">Heartbeat</td>
<td align="left">收集服务运行状态监测数据</td>
</tr>
</tbody></table>
<p>能实现以上这些beat，都离不开beats家族真正的“老大”—— libbeat， 它是beat体系的核心库。我们接下来看一下libbeat到底都作了些什么</p>
<ul>
<li>libbeat 提供了 <code>publisher</code> 组件，用于对接 <code>input</code></li>
<li>收集到的数据在进入 <code>libbeat</code> 后，首先会经过各种 <code>processor</code>的加工处理，比如过滤添加字段，多行合并等等；</li>
<li><code>input</code> 组件通过 <code>publisher</code> 组件将收集到的数据推送到 <code>publisher</code> 内部的队列；</li>
<li>libbeat本身实现了前面介绍过的多种<code>output</code>, 因此它负责将处理好的数据通过output组件发送出去；</li>
<li>libbeat本身封装了retry的逻辑；</li>
<li>libbeat负责将ACK反馈通过到input组件 ；</li>
</ul>
<p>由此可见，大部分活儿都是libbeat来作，当“老大”不容易啊～。</p>
<p><code>input</code>仅需要作两件事：</p>
<ul>
<li>从不同的介质中收集数据后投递给libbeat;</li>
<li>接收libbeat反馈回来的ACK, 作相应的持久化;</li>
</ul>
<h2><span id="log-input是如何从日志文件中收集日志的">Log input是如何从日志文件中收集日志的</span></h2><h6><span id="input的创建">input的创建</span></h6><ul>
<li>根据配置文件内容创建相应的Processors, 用于前面提到的对从文件中读取到的内容的加工处理;</li>
<li>创建Acker, 用于持久化libbeat反馈回来的收集发送进度;</li>
<li>使用libbeat提供的<code>Pipeline.queue.Producer</code>创建<code>producer</code>，用于将处理好的文件内容投递到libbeat的内部队列；</li>
</ul>
<h6><span id="收集文件内容">收集文件内容</span></h6><ul>
<li>input会根据配置文件中的收集路径（正则匹配）来<strong>轮询</strong>是否有新文件产生，文件是否已经过期，文件是否被删除或移动;</li>
<li>针对每一个文件创建一个Harvester来逐行读取文件内容；</li>
<li>将文件内容封装后通过producer发送到libbeat的内部队列；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200529231120384.png#pic_center" alt="233"></p>
<p>未完待续。。</p>
]]></content>
      <categories>
        <category>filebeat</category>
      </categories>
      <tags>
        <tag>filebeat</tag>
        <tag>日志收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell之expect脚本的学习</title>
    <url>/2020/05/28/Shell%E4%B9%8Bexpect%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.jellythink.com/archives/373" target="_blank" rel="noopener">Linux expect详解</a></p>
<p><a href="https://www.jellythink.com/archives/373" target="_blank" rel="noopener">Linux expect详解</a><a href="https://www.jianshu.com/p/70556b1ce932" target="_blank" rel="noopener">Linux Expect 简介和使用实例</a></p>
<p><a href="https://www.cnblogs.com/lzrabbit/p/4298794.html" target="_blank" rel="noopener">linux expect详解(ssh自动登录)</a></p>
<p><a href="https://man.linuxde.net/expect1" target="_blank" rel="noopener">expect - 自动交互脚本</a></p>
<blockquote>
<p>最近项目上总是有需要迁移相关工具(jdk,nacos,sentinel等)的需求,大多数都是一些重复的工作,所以我希望通过shell脚本来减少我的工作量</p>
</blockquote>
<a id="more"></a>

<h1><span id="是什么">是什么</span></h1><p><code>expect</code> 是一个用来实现自动交互功能的软件(免费)</p>
<p>在实际工作中,我们运行命令,脚本或程序时, 这些命令,脚本或程序都需要从终端输入某些继续运行的指令,而这些输入都需要人为的手工进行. 而利用 <code>expect</code>, 则可以根据程序的提示,模拟标准输入提供给程序,从而实现自动化交互执行。</p>
<h1><span id="expect基础">expect基础</span></h1><p>在使用<code>expect</code>时，基本上都是和以下四个命令打交道：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>send</td>
<td>用于向进程发送字符串</td>
</tr>
<tr>
<td>expect</td>
<td>从进程中接收字符串</td>
</tr>
<tr>
<td>spawn</td>
<td>启动新的进程</td>
</tr>
<tr>
<td>interact</td>
<td>允许用户交互</td>
</tr>
</tbody></table>
<ul>
<li><code>send</code>命令接收一个字符串参数，并将该参数发送到进程。</li>
<li><code>expect</code>命令和<code>send</code>命令相反，<code>expect</code>通常用来等待一个进程的反馈，我们根据进程的反馈，再发送对应的交互命令。</li>
<li><code>spawn</code>命令用来启动新的进程，<code>spawn</code>后的<code>send</code>和<code>expect</code>命令都是和使用<code>spawn</code>打开的进程进行交互。</li>
<li><code>interact</code>命令用的其实不是很多，一般情况下使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令就可以很好的完成我们的任务；但在一些特殊场合下还是需要使用<code>interact</code>命令的，<code>interact</code>命令主要用于退出自动化，进入人工交互。比如我们使用<code>spawn</code>、<code>send</code>和<code>expect</code>命令完成了ftp登陆主机，执行下载文件任务，但是我们希望在文件下载结束以后，仍然可以停留在ftp命令行状态，以便手动的执行后续命令，此时使用<code>interact</code>命令就可以很好的完成这个任务。</li>
</ul>
<h1><span id="示例分析">示例分析</span></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/tcl/bin/expect</span></span><br><span class="line"></span><br><span class="line">set timeout 30</span><br><span class="line">set host "101.200.241.109"</span><br><span class="line">set username "root"</span><br><span class="line">set password "123456"</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect "*password*" &#123;send "$password\r"&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>这是一段非常简单的<code>expect</code>示例代码，演示了<code>expect</code>的基本使用方法。</p>
<p><code>#!/usr/tcl/bin/expect</code>：使用<code>expect</code>来解释该脚本；<br><code>set timeout 30</code>：设置超时时间，单位为秒，默认情况下是10秒；<br><code>set host &quot;101.200.241.109&quot;</code>：设置变量；<br><code>spawn ssh $username@$host</code>：spawn是进入expect环境后才可以执行的expect内部命令，如果没有装expect或者直接在默认的SHELL下执行是找不到spawn命令的。它主要的功能是给ssh运行进程加个壳，用来传递交互指令；<br><code>expect &quot;*password*&quot;</code>：这里的expect也是expect的一个内部命令，这个命令的意思是判断上次输出结果里是否包含“password”的字符串，如果有则立即返回；否则就等待一段时间后返回，这里等待时长就是前面设置的30秒；<br><code>send &quot;$password\r&quot;</code>：当匹配到对应的输出结果时，就发送密码到打开的ssh进程，执行交互动作；<br><code>interact</code>：执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。</p>
<p>这就是对上述这段简单简单脚本的分析，在上述的示例中，涉及到<code>expect</code>中一个非常重要的概念——模式-动作；即上述<code>expect &quot;*password*&quot; {send &quot;$password\r&quot;}</code>这句代码表达出来的含义。</p>
<h1><span id="模式-动作">模式-动作</span></h1><p>结合着<code>expect &quot;*password*&quot; {send &quot;$password\r&quot;}</code>这句代码来说说“模式-动作”。简单的说就是匹配到一个模式, 就执行对应的动作, 匹配到 password 字符串，就输入密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">    "password" &#123;</span><br><span class="line">        send "$password\r"</span><br><span class="line">        exp_continue</span><br><span class="line">    &#125;</span><br><span class="line">    eof</span><br><span class="line">    &#123;</span><br><span class="line">        send "eof"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>exp_continue</code>表示循环式匹配，通常匹配之后都会退出语句，但如果有<code>exp_continue</code>则可以不断循环匹配，输入多条命令，简化写法。</p>
<h1><span id="传参">传参</span></h1><p>很多时候，我们需要传递参数到脚本中，现在通过下面这段代码来看看如何在<code>expect</code>中使用参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/tcl/bin/expect</span></span><br><span class="line"></span><br><span class="line">if &#123;$argc &lt; 3&#125; &#123;</span><br><span class="line">    puts "Usage:cmd &lt;host&gt; &lt;username&gt; &lt;password&gt;"</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set timeout -1</span><br><span class="line">set host [lindex $argv 0] </span><br><span class="line">set username [lindex $argv 1]</span><br><span class="line">set password [lindex $argv 2]</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect "*password*" &#123;send "$password\r"&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>在expect中，$argc表示参数个数，而参数值存放在$argv中，比如取第一个参数就是<code>[lindex $argv 0]</code>，以此类推。</p>
<h1><span id="结果">结果</span></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3个参数</span></span><br><span class="line">set localpath [lrange $argv 0 0]</span><br><span class="line">set ip [lrange $argv 1 1]</span><br><span class="line">set dir [lrange $argv 2 2]</span><br><span class="line"><span class="meta">#</span><span class="bash">设置超时时间</span></span><br><span class="line">set timeout 30</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">登录远程服务器创建文件夹</span></span><br><span class="line">spawn ssh root@$ip</span><br><span class="line">expect "*assword"</span><br><span class="line">send "xxx_\r"</span><br><span class="line">expect "root" &#123;send "mkdir -p /home/xxx/$dir\r"&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">两台服务器之间传递文件</span></span><br><span class="line">spawn scp -r $localpath root@$ip:/home/xxx/$dir</span><br><span class="line">expect "*assword"</span><br><span class="line">send "xxx_\r"</span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<ul>
<li>argv: 参数值</li>
<li>argc: 参数个数</li>
</ul>
<h1><span id="scp命令学习">SCP命令学习</span></h1><p><a href="https://www.runoob.com/linux/linux-comm-scp.html" target="_blank" rel="noopener">Linux scp命令</a></p>
<blockquote>
<p>scp 命令学习</p>
</blockquote>
<!-- more -->

<p>scp 命令用于 Linux 之间复制文件和目录</p>
<p>scp 是 secure copy 的缩写,scp 是 linux 系统下基于 ssh 登录进行安全的远程文件拷贝命令</p>
<p>scp 是加密的，<a href="https://www.runoob.com/linux/linux-comm-rcp.html" target="_blank" rel="noopener">rcp</a> 是不加密的，scp 是 rcp 的加强版。</p>
<h2><span id="从本地复制到远程">从本地复制到远程</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp local_file remote_user@remote_ip:remote_folder</span><br></pre></td></tr></table></figure>

<p>-p: 指定端口</p>
<p>-r: 传送文件夹</p>
<h3><span id="说明">说明</span></h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">scp 命令使用端口号 4588</span></span><br><span class="line">scp -P 4588 -r /localfile remote@www.runoob.com:/usr/local/sin.sh /home/administrator</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>expect脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark之RDD学习</title>
    <url>/2020/05/28/Spark%E4%B9%8BRDD%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://github.com/01Lv/BigData-Notes/blob/master/notes/Spark_RDD.md" target="_blank" rel="noopener">弹性数据集RDDs</a></p>
<a id="more"></a>

<p><code>RDD</code> 全称为 Resilient Distributed Datasets （弹性分布式数据集） , 是 Spark 最基本的数据抽象。代码中是一个抽象类，它代表一个不可变，可分区，里面元素可并行计算的集合。</p>
<ul>
<li>一个 RDD 由一个或者多个分区 (Partitions) 组成。对于 RDD 来说，每个分区会被一个计算任务所处理，用户可以在创建 RDD 时指定其分区个数，如果没有指定，则默认采用程序所分配到的 CPU 的核心数。</li>
<li>RDD 拥有一个用于计算分区的函数 compute</li>
<li>RDD 会保存彼此间的依赖关系，RDD 的每次转换都会生成一个新的依赖关系，这种 RDD 之间的依赖关系就像流水线一样。在部分分区数据丢失之后，可以通过这种依赖关系重新计算丢失的分区数据，而不是对 RDD 的所有分区进行重新计算</li>
<li>Key-Value 型 RDD 还拥有 Partitioner(分区器) , 用于决定数据被存储在哪个分区中，目前 Spark 中支持 HashPartitioner(安装哈希分区) 和 RangePartitioner(按照范围进行分区)</li>
</ul>
<p>RDD 其实实现的思想也是 <strong>装饰者模式</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/20200529092315677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="227"></p>
<p>spark 会优先计算数据存放在哪个 DataNode</p>
<p><img src="https://img-blog.csdnimg.cn/20200529092332525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="228"></p>
<p><strong>算子：</strong>解决问题其实是将问题的初始状态，通过一系列的操作(Operate:算子)对问题进行转换，然后达到完成(解决) 状态</p>
<p>Spark 中的所有的 RDD 方法都称为算子，但是分为<strong>两大类</strong>：转换算子 &amp; 行动算子</p>
<h1><span id="创建">创建</span></h1><p>创建方式有三种：</p>
<ul>
<li>从集合中创建 RDD</li>
<li>从外部存储创建 RDD</li>
<li>从其它 RDD 中创建 RDD</li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>RDD</tag>
      </tags>
  </entry>
  <entry>
    <title>监控系统之Grafana容器化安装</title>
    <url>/2020/05/28/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%B9%8BGrafana%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><a href="https://grafana.com/docs/grafana/latest/installation/docker/" target="_blank" rel="noopener">Grafana官网</a></p>
<a id="more"></a>

<p>安装，下载命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name grafana -p 3000:3000 -d docker.io/grafana/grafana</span><br></pre></td></tr></table></figure>

<p>web界面,初始登录密码为：admin/admin</p>
<p><img src="https://img-blog.csdnimg.cn/20200528222641165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="224"></p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>监控系统</category>
      </categories>
      <tags>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据之Spark的WorkCount相关demo</title>
    <url>/2020/05/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8BSpark%E7%9A%84WorkCount%E7%9B%B8%E5%85%B3demo/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV174411X7Pk?p=8" target="_blank" rel="noopener">尚硅谷</a></p>
<blockquote>
<p>这个 demo 我是参考尚硅谷视频里的代码，结合之前在 GitHub 上所学的。</p>
</blockquote>
<a id="more"></a>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.developer.bigdata.spark</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.RDD</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;SparkConf, SparkContext&#125;</span><br><span class="line"></span><br><span class="line">object WordCount &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">        <span class="comment">//创建 sparkConf 对象</span></span><br><span class="line">        <span class="comment">//设定 Spark 计算框架的运行环境</span></span><br><span class="line">        val config: SparkConf = <span class="keyword">new</span> SparkConf().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建spark上下文对象</span></span><br><span class="line">            val sc = <span class="keyword">new</span> SparkContext(config)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取文件,将文件内容一行一行的读取出来</span></span><br><span class="line">            val lines: RDD[String] = sc.textFile(<span class="string">"in/word.txt"</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将一行一行的数据分解一个一个的单词</span></span><br><span class="line">                val words: RDD[(String)] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将单词数据进行结构的转换</span></span><br><span class="line">                    val wordToOne: RDD[(String,Int)] = words.map((_, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//对转换结构后的数据进行分组聚合</span></span><br><span class="line">                        val wordToSum: RDD[(String,Int)] = wordToOne.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//将统计结果打印到控制台</span></span><br><span class="line">                            val result: Array[(String,Int)] = wordToSum.collect()</span><br><span class="line"></span><br><span class="line">                                result.foreach(println)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO ShuffleBlockFetcherIterator: Getting <span class="number">2</span> non-empty blocks out of <span class="number">2</span> blocks</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO ShuffleBlockFetcherIterator: Getting <span class="number">2</span> non-empty blocks out of <span class="number">2</span> blocks</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO ShuffleBlockFetcherIterator: Started <span class="number">0</span> remote fetches <span class="keyword">in</span> <span class="number">2</span> ms</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO ShuffleBlockFetcherIterator: Started <span class="number">0</span> remote fetches <span class="keyword">in</span> <span class="number">2</span> ms</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO Executor: Finished task <span class="number">1.0</span> <span class="keyword">in</span> stage <span class="number">1.0</span> (TID <span class="number">3</span>). <span class="number">1304</span> bytes result sent to driver</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO Executor: Finished task <span class="number">0.0</span> <span class="keyword">in</span> stage <span class="number">1.0</span> (TID <span class="number">2</span>). <span class="number">1329</span> bytes result sent to driver</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO TaskSetManager: Finished task <span class="number">1.0</span> <span class="keyword">in</span> stage <span class="number">1.0</span> (TID <span class="number">3</span>) <span class="keyword">in</span> <span class="number">22</span> ms <span class="keyword">on</span> localhost (executor driver) (<span class="number">1</span>/<span class="number">2</span>)</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO TaskSetManager: Finished task <span class="number">0.0</span> <span class="keyword">in</span> stage <span class="number">1.0</span> (TID <span class="number">2</span>) <span class="keyword">in</span> <span class="number">24</span> ms <span class="keyword">on</span> localhost (executor driver) (<span class="number">2</span>/<span class="number">2</span>)</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO TaskSchedulerImpl: Removed TaskSet <span class="number">1.0</span>, whose tasks have all completed, from pool </span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO DAGScheduler: ResultStage <span class="number">1</span> (collect at WordCount.scala:<span class="number">29</span>) finished <span class="keyword">in</span> <span class="number">0.025</span> s</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO DAGScheduler: Job <span class="number">0</span> finished: collect at WordCount.scala:<span class="number">29</span>, took <span class="number">0.269880</span> s</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO SparkContext: Invoking stop() from shutdown hook</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO SparkUI: Stopped Spark web UI at http:<span class="comment">//10.106.20.63:4040</span></span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO MemoryStore: MemoryStore cleared</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO BlockManager: BlockManager stopped</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO BlockManagerMaster: BlockManagerMaster stopped</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!</span><br><span class="line">(scala,<span class="number">1</span>)                   #结果</span><br><span class="line">(hello,<span class="number">4</span>)					#结果</span><br><span class="line">(bigdata,<span class="number">1</span>)</span><br><span class="line">(spark,<span class="number">1</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO SparkContext: Successfully stopped SparkContext</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO ShutdownHookManager: Shutdown hook called</span><br><span class="line"><span class="number">20</span>/<span class="number">05</span>/<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">28</span> INFO ShutdownHookManager: Deleting directory /tmp/spark<span class="number">-719285</span>ca<span class="number">-6713</span><span class="number">-44</span>c8<span class="number">-8181</span><span class="number">-87279</span>ed1b88f</span><br></pre></td></tr></table></figure>

<p>这是 <code>word.txt</code> 文本中的内容<br><img src="https://img-blog.csdnimg.cn/20200529091003180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="223"></p>
<h1><span id="解析">解析</span></h1><p>引用之前的一张图片，这是原理</p>
<p><img src="https://img-blog.csdnimg.cn/20200529090837264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="221"></p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>WordCount</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据之Spark学习</title>
    <url>/2020/05/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8BSpark%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="http://spark.apache.org/" target="_blank" rel="noopener">spark官网</a></p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200529090433236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="221"></p>
<h1><span id="yarn-模式">Yarn 模式</span></h1><p>Spark 客户端直接 Yarn,不需要额外构建 Spark 集群。有 <code>yarn-clien</code> 和 <code>yarn-cluster</code> 两种模式，</p>
<p><strong>主要区别在于：Driver 程序的运行节点</strong></p>
<ul>
<li><strong>yarn-client</strong> : Driver 程序运行在客户端，适用于交互，调试，希望立即看到 app 的输出</li>
<li><strong>yarn-cluster</strong> : Driver 程序运行在由 RM (Resource Manager) 启动的 AP(APPMaster) 适用于生产环境</li>
</ul>
<h1><span id="装饰者设计模式">装饰者设计模式</span></h1><p>字符流读取文件</p>
<p><img src="https://img-blog.csdnimg.cn/20200529090500938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="225"></p>
<p>字符流一行一行读取文本，懒加载，按需读取(readLine)</p>
<p><img src="https://img-blog.csdnimg.cn/2020052909054070.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="226"></p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka之基础学习</title>
    <url>/2020/05/27/Kafka%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>

<p>入门某一项技术都先从一个 demo 开始吧！</p>
<p>参照这篇 <a href="https://github.com/Snailclimb/springboot-kafka/blob/master/docs/2-5%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E4%BD%93%E9%AA%8C%E4%B8%80%E6%8A%8AKafka.md" target="_blank" rel="noopener">文章</a>，在 Centos7 上搭建了一个单机版的 Kafka 和 zk。在这里简单提几点</p>
<ul>
<li>在新建一个名为 <code>zk-single-kafka-multiple.yml</code> 的文件时候，在文件中加入 <code>privileged: true</code> ,<strong>赋予容器 root 的权限</strong>，否则无权限操作容器中的文件哦！</li>
<li>插件按自己需求来</li>
</ul>
<p>紧跟文章，最终都能实现效果滴，结果如下图：</p>
<h3><span id="使用命令行测试消息的生产和消费">使用命令行测试消息的生产和消费</span></h3><p>列出所有topic</p>
<p><img src="https://img-blog.csdnimg.cn/20200527101626791.png#pic_center" alt="212"></p>
<p>创建一个topic</p>
<p><img src="https://img-blog.csdnimg.cn/20200527101645250.png#pic_center" alt="213"></p>
<p>消费者成功消费消息</p>
<p><img src="https://img-blog.csdnimg.cn/20200527101556735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="211"></p>
<h3><span id="java-程序中简单使用kafka">Java 程序中简单使用Kafka</span></h3><p>最终结果</p>
<p><img src="https://img-blog.csdnimg.cn/20200527101704150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="214"></p>
<h3><span id="10分钟学会如何在springboot程序中使用kafka作为消息队列"></span></h3><p><a href="https://gitee.com/mikeLv01/kafka-demo.git" target="_blank" rel="noopener">项目代码</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200527101722946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="215"></p>
<h1><span id="基础概念">基础概念</span></h1><h2><span id="生产者与消费者">生产者与消费者</span></h2><p><img src="https://img-blog.csdnimg.cn/20200527111635159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="216"></p>
<h2><span id="主题topic与分区partition">主题(Topic)与分区(Partition)</span></h2><p><img src="https://img-blog.csdnimg.cn/20200527111651701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="217"></p>
<p>在 Kafka 中，消息以 <strong>主题(Topic)</strong> 来分类，每一个主题对应一个 <strong>消息队列</strong> ，有点类似于数据库中的表，但是如果我们把所有同类的消息都塞入到一个“中心”队列中，势必缺少可伸缩性，无论是生产者/消费者数目的增加，还是消息数量的增加，都可能耗尽系统的性能或存储。</p>
<p>我们使用一个生活中的例子来说明：现在 A 城市生产的某商品需要运输到 B 城市，走的是公路，那么单通道的高速公路不论是在「A 城市商品增多」还是「现在 C 城市也要往 B 城市运输东西」这样的情况下都会出现「吞吐量不足」的问题。所以我们现在引入<strong>分区（Partition）</strong>的概念，类似“允许多修几条道”的方式对我们的主题完成了水平扩展。</p>
<h2><span id="broker-和集群cluster">Broker 和集群(Cluster)</span></h2><p>一个 Kafka 服务器也称为 Broker，它接收生产者发送的消息并存入磁盘; Broker 同时服务消费者拉取分区消息的请求，返回目前已经提交的消息。使用特定的机器硬件，一个 Broker 每秒可以处理成千上万的分区和百万量级的消息。</p>
<p>若干个 Broker 组成一个集群（Cluster），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。在集群内，一个分区由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader；当然一个分区可以被复制到多个 Broker 上来实现冗余，这样当存在 Broker 故障时可以将其分区重新分配到其他 Broker 来负责。下图是一个样例：</p>
<p><img src="https://img-blog.csdnimg.cn/20200527111709408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="218"></p>
<p>Kafka 的一个关键性质是日志保留（retention），我们可以配置主题的消息保留策略，譬如只保留一段时间的日志或者只保留特定大小的日志。当超过这些限制时，老的消息会被删除。我们也可以针对某个主题单独设置消息过期策略，这样对于不同应用可以实现个性化。</p>
<h1><span id="设计与实现">设计与实现</span></h1><h2><span id="讨论一kafka-存储在文件系统上">讨论一：Kafka 存储在文件系统上</span></h2><p><strong>首先应该知道 Kafka 的消息是存在于文件系统之上的</strong>。Kafka 高度依赖于文件系统来存储和缓存消息。</p>
<p>一般的人认为 “磁盘是缓慢的”，所以对这样的设计持有怀疑态度。实际上，磁盘比人们预想的快很多也慢很多，这取决于它们如何被使用；一个好的磁盘结构设计可以使之跟网络速度一样快。</p>
<p>现代的操作系统针对磁盘的读写已经做了一些优化方案来加快磁盘的访问速度。比如，<strong>预读</strong>会提前将一个比较大的磁盘快读入内存。<strong>后写</strong>会将很多小的逻辑写操作合并起来组合成一个大的物理写操作。并且，操作系统还会将主内存剩余的所有空闲内存空间都用作<strong>磁盘缓存</strong>，所有的磁盘读写操作都会经过统一的磁盘缓存（除了直接 I/O 会绕过磁盘缓存）。综合这几点优化特点，<strong>如果是针对磁盘的顺序访问，某些情况下它可能比随机的内存访问都要快，甚至可以和网络的速度相差无几。</strong></p>
<p><strong>上述的 Topic 其实是逻辑上的概念，面相消费者和生产者，物理上存储的其实是 Partition</strong>，每一个 Partition 最终对应一个目录，里面存储所有的消息和索引文件。默认情况下，每一个 Topic 在创建时如果不指定 Partition 数量时只会创建 1 个 Partition。比如，我创建了一个 Topic 名字为 test ，没有指定 Partition 的数量，那么会默认创建一个 test-0 的文件夹，这里的命名规则是：<code>&lt;topic_name&gt;-&lt;partition_id&gt;</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200527111727106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="219"></p>
<p>任何发布到 Partition 的消息都会被追加到 Partition 数据文件的尾部，这样的顺序写磁盘操作让 Kafka 的效率非常高(经验证，顺序写磁盘效率比随机写内存还要高，这是 Kafka 高吞吐率的一个很重要的保证)</p>
<p>每一条消息被发送到 Broker 中，会根据 Partition 规则选择被存储到哪一个 Partition。如果 Partition 规则设置的合理，所有消息可以均匀分布到不同的 Partition中。</p>
<h2><span id="底层设计">底层设计</span></h2><p>假设现在 Kafka 集群只有一个 Broker，我们创建 2 个 Topic 名称分别为：「topic1」和「topic2」，Partition 数量分别为 1、2，那么我们的根目录下就会创建如下三个文件夹：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">| --topic1<span class="number">-0</span></span><br><span class="line">   | --topic2<span class="number">-0</span></span><br><span class="line">   | --topic2<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>在 Kafka 的文件存储中，同一个 Topic 下有多个不同的 Partition，<strong>每个 Partition 都为一个目录</strong>，而每一个目录又被平均分配成多个大小相等的 <strong>Segment File</strong> 中，Segment File 又由 <code>index file</code> 和 <code>data file</code> 组成，他们总是成对出现，后缀 “.index” 和 “.log” 分表表示 Segment 索引文件和数据文件。</p>
<p>现在假设我们设置每个 Segment 大小为 500 MB，并启动生产者向 topic1 中写入大量数据，topic1-0 文件夹中就会产生类似如下的一些文件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">| --topic1<span class="number">-0</span> </span><br><span class="line">      | -<span class="number">-00000000000000000000.</span>index </span><br><span class="line">      | -<span class="number">-00000000000000000000.</span>log </span><br><span class="line">      | -<span class="number">-00000000000000368769.</span>index </span><br><span class="line">      | -<span class="number">-00000000000000368769.</span>log </span><br><span class="line">      | -<span class="number">-00000000000000737337.</span>index </span><br><span class="line">      | -<span class="number">-00000000000000737337.</span>log </span><br><span class="line">      | -<span class="number">-00000000000001105814.</span>index | -<span class="number">-00000000000001105814.</span>log </span><br><span class="line">  | --topic2<span class="number">-0</span> </span><br><span class="line">  | --topic2<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>Segment 是 Kafka 文件存储的最小单位</strong>。Segment 文件命名规则：Partition 全局的第一个 Segment 从 0 开始，后续每个 Segment 文件名为上一个 Segment 文件最后一条消息的 offset 值。数值最大为 64 位 long 大小，19 位数字字符长度，没有数字用0填充。如 00000000000000368769.index 和 00000000000000368769.log。</p>
<p>以上面的一对 Segment File 为例，说明一下索引文件和数据文件对应关系：</p>
<p><img src="https://img-blog.csdnimg.cn/20200527111746477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="220"></p>
<p>其中以索引文件中元数据 <code>&lt;3, 497&gt;</code> 为例，依次在数据文件中表示第 3 个 message（在全局 Partition 表示第 368769 + 3 = 368772 个 message）以及该消息的物理偏移地址为 497。</p>
<p>注意该 index 文件并不是从0开始，也不是每次递增1的，这是因为 Kafka 采取稀疏索引存储的方式，每隔一定字节的数据建立一条索引，它减少了索引文件大小，使得能够把 index 映射到内存，降低了查询时的磁盘 IO 开销，同时也并没有给查询带来太多的时间消耗。</p>
<p>因为其文件名为上一个 Segment 最后一条消息的 offset ，所以当需要查找一个指定 offset 的 message 时，通过在所有 segment 的文件名中进行二分查找就能找到它归属的 segment ，再在其 index 文件中找到其对应到文件上的物理位置，就能拿出该 message 。</p>
<p>由于消息在 Partition 的 Segment 数据文件中是顺序读写的，且消息消费后不会删除（删除策略是针对过期的 Segment 文件），这种顺序磁盘 IO 存储设计是 Kafka 高性能很重要的原因。</p>
<blockquote>
<p>Kafka 是如何准确的知道 message 的偏移的呢？这是因为在 Kafka 定义了标准的数据存储结构，在 Partition 中的每一条 message 都包含了以下三个属性：</p>
<ul>
<li>offset：表示 message 在当前 Partition 中的偏移量，是一个逻辑上的值，唯一确定了 Partition 中的一条 message，可以简单的认为是一个 id；</li>
<li>MessageSize：表示 message 内容 data 的大小；</li>
<li>data：message 的具体内容</li>
</ul>
</blockquote>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins定时任务curl结果为moved错误</title>
    <url>/2020/05/26/Jenkins%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1curl%E7%BB%93%E6%9E%9C%E4%B8%BAmoved%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/zz0412/p/jenkins_jj_12.html" target="_blank" rel="noopener">Jenkins进阶系列之——12详解Jenkins节点配置</a></p>
<p><a href="https://www.cnblogs.com/shengulong/p/6769012.html" target="_blank" rel="noopener">如何限制jenkins的任务在某个节点上执行</a></p>
<blockquote>
<p>最近在Jenkins上部署了两个定时任务，一个定时任务是正常的，可是另一个定时任务却出了问题(之前都是正常的)。尝试了控制变量的方式，发现这个有问题的job运行在了其它工作空间</p>
</blockquote>
<a id="more"></a>

<p>虽然成功执行了，可是结果却不是想要的 </p>
<p><img src="https://img-blog.csdnimg.cn/20200526211621488.png#pic_center" alt="208"></p>
<p>控制台日志：</p>
<p><img src="https://img-blog.csdnimg.cn/20200526211603241.png#pic_center" alt="207"></p>
<p>排查了好久，发现原来这个job工作在了 <code>AndroidCompile</code> 这个工作区间，据说这台服务器是无法访问外网的，所以导致了 <code>&lt;h2&gt;moved&lt;/h2&gt;</code> 这个错误。</p>
<p>通过在 job 中配置该参数，强制要求它在 <strong>master节点的服务器</strong> 上运行</p>
<p><img src="https://img-blog.csdnimg.cn/20200526211637412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="209"></p>
<p>最终结果就正常了</p>
<p><img src="https://img-blog.csdnimg.cn/20200526211656614.png#pic_center" alt="210"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix之学习</title>
    <url>/2020/05/26/Zabbix%E4%B9%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.zabbix.com/cn" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200529091157179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="204"></p>
<ul>
<li><strong>Zabbix Agent</strong>：Zabbix客户端,负责数据收集上传</li>
<li><strong>Zabbix Server</strong>：负责数据收集汇总，处理，告警策略，告警发送等</li>
<li><strong>Database</strong>：负责数据存储和配置</li>
<li><strong>Java Gateway</strong>：负责通过 <code>JMX</code> 监控收集Java应用性能数据</li>
<li><strong>Zabbix Agent</strong>：主要收集设备的监控数据并发送到相应的 <code>Zabbix Server</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200529091240690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="205"></p>
<h1><span id="资源要求">资源要求</span></h1><p><img src="https://img-blog.csdnimg.cn/20200529091305135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="206"></p>
<ul>
<li>设备小于500台，只需要2核2G内存</li>
<li>设备大于10000台，才需要8核16G内存</li>
</ul>
<h1><span id="安装">安装</span></h1><p><a href="https://www.zabbix.com/documentation/4.0/zh/manual/installation/containers" target="_blank" rel="noopener">官方安装教程</a></p>
<h1><span id="监控">监控</span></h1><p><img src="https://img-blog.csdnimg.cn/20200529091328716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="222"></p>
]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringJPA之使用Page,Pageable,Sort实现分页排序</title>
    <url>/2020/05/25/SpringJPA%E4%B9%8B%E4%BD%BF%E7%94%A8Page,Pageable,Sort%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_40715775/article/details/83153808" target="_blank" rel="noopener">使用Spring JPA中Page、Pageable接口和Sort类完成分页排序</a></p>
<a id="more"></a>

<p>Pageable 接口用于构造分页查询，PageRequest 是其实现类。</p>
<p>Pageable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pageable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pageable <span class="title">unpaged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Unpaged.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isPaged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isUnpaged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.isPaged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPageNumber</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPageSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getOffset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sort <span class="title">getSort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Sort <span class="title">getSortOr</span><span class="params">(Sort sort)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(sort, <span class="string">"Fallback Sort must not be null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSort().isSorted() ? <span class="keyword">this</span>.getSort() : sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Pageable <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Pageable <span class="title">previousOrFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Pageable <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Optional&lt;Pageable&gt; <span class="title">toOptional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isUnpaged() ? Optional.empty() : Optional.of(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PageRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageRequest</span> <span class="keyword">extends</span> <span class="title">AbstractPageRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4541509938956089562L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sort sort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PageRequest</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size, Sort sort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(page, size);</span><br><span class="line">        Assert.notNull(sort, <span class="string">"Sort must not be null!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sort = sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageRequest <span class="title">of</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> of(page, size, Sort.unsorted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageRequest <span class="title">of</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size, Sort sort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageRequest(page, size, sort);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageRequest <span class="title">of</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size, Direction direction, String... properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> of(page, size, Sort.by(direction, properties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sort <span class="title">getSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pageable <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageRequest(<span class="keyword">this</span>.getPageNumber() + <span class="number">1</span>, <span class="keyword">this</span>.getPageSize(), <span class="keyword">this</span>.getSort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageRequest <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getPageNumber() == <span class="number">0</span> ? <span class="keyword">this</span> : <span class="keyword">new</span> PageRequest(<span class="keyword">this</span>.getPageNumber() - <span class="number">1</span>, <span class="keyword">this</span>.getPageSize(), <span class="keyword">this</span>.getSort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pageable <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="keyword">this</span>.getPageSize(), <span class="keyword">this</span>.getSort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(@Nullable Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> PageRequest)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PageRequest that = (PageRequest)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.equals(that) &amp;&amp; <span class="keyword">this</span>.sort.equals(that.sort);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * <span class="keyword">super</span>.hashCode() + <span class="keyword">this</span>.sort.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Page request [number: %d, size %d, sort: %s]"</span>, <span class="keyword">this</span>.getPageNumber(), <span class="keyword">this</span>.getPageSize(), <span class="keyword">this</span>.sort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Page 接口可以获得当前页面的<strong>记录</strong>，<strong>总页数</strong>，<strong>总记录数</strong>，<strong>是否有上一页或下一页</strong>, Spring Data分页查询总是返回 Page 对象，Page 对象还提供了以下常用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTotalPages</span><span class="params">()</span> 总的页数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTotalElements</span><span class="params">()</span> 返回总数</span></span><br><span class="line"><span class="function">List <span class="title">getContent</span><span class="params">()</span> 返回此次查询的结果集</span></span><br></pre></td></tr></table></figure>

<p>PageImpl 是 <code>Page接口</code> 的实现类</p>
<h1><span id="实现">实现</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;xxxRespDTO&gt; <span class="title">listByPage</span><span class="params">(String xxx, Integer pageNumber, Integer pageSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造where条件</span></span><br><span class="line">    Specification&lt;xxxEntity&gt; specification = xxxSpecification.buildFromParam(xxx);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    Sort sort = Sort.by(Sort.Direction.DESC, <span class="string">"dateCreated"</span>);</span><br><span class="line">    PageRequest pageable = PageRequest.of(pageNumber, pageSize, sort);</span><br><span class="line">    Page&lt;xxxEntity&gt; xxxPage = repository.findAll(specification, pageable);</span><br><span class="line">    List&lt;xxxEntity&gt; xxxEntityList = xxxEntityPage.getContent();</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(xxxEntityList))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageImpl(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;xxxRespDTO&gt; result = xxxEntityList.stream().map(item -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        xxxRespDTO dto = <span class="keyword">new</span> xxxRespDTO();</span><br><span class="line">        CglibBeanUtils.copy(dto, item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageImpl(result, xxxEntityPage.getPageable(), xxxEntityPage.getTotalElements());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>repository.findAll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> specification</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function">Page&lt;xxxEntity&gt; <span class="title">findAll</span><span class="params">(Specification&lt;xxxEntity&gt; specification, Pageable page)</span></span>;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"004-分页"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(value = Routes.xxx)</span><br><span class="line"><span class="keyword">public</span> ApiResult&lt;Page&lt;xxx&gt;&gt; detail(</span><br><span class="line">    <span class="meta">@RequestParam</span>(required = <span class="keyword">false</span>) <span class="meta">@ApiParam</span>(value = <span class="string">"xxx"</span>) String xxx,</span><br><span class="line">    <span class="meta">@RequestParam</span>(required = <span class="keyword">false</span>) <span class="meta">@Min</span>(value = <span class="number">0</span>, message = <span class="string">"pageNumber需要&gt;=0"</span>) Integer pageNumber,</span><br><span class="line">    <span class="meta">@RequestParam</span>(required = <span class="keyword">false</span>) <span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"pageSize需要&gt;=1"</span>) Integer pageSize</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;DanceConfigListByPageRespDTO&gt; result = service.listByPage(xxx,pageNumber,pageSize);</span><br><span class="line">    <span class="keyword">return</span> ApiResult.success(result.getContent(), Integer.valueOf(result.getTotalElements() + <span class="string">""</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApiResult</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiResult</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ApiResultDefine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiResult</span><span class="params">(Integer code, String message, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiResult</span><span class="params">(Integer code, String message, T data, Integer count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(ApiResultEnum.SUCCESS.getCode(), ApiResultEnum.SUCCESS.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">(Object data, Integer count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(ApiResultEnum.SUCCESS.getCode(), ApiResultEnum.SUCCESS.getMessage(), data, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx之知识点巩固</title>
    <url>/2020/05/25/Nginx%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<p><a href="https://www.nginx.com/" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>

<h1><span id="正向代理">正向代理</span></h1><p>在客户端(浏览器) 配置代理服务器，通过代理服务器进行互联网访问。</p>
<h1><span id="反向代理">反向代理</span></h1><p>只需要将请求发送到反向代理服务器，<strong>由反向代理服务器去选择目标服务器获取数据</strong>后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器的地址，隐藏了真实服务器IP地址。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven插件maven-dependency-plugin的使用</title>
    <url>/2020/05/25/Maven%E6%8F%92%E4%BB%B6maven-dependency-plugin%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>在日常开发中有可能碰到包冲突的问题！</p>
</blockquote>
<a id="more"></a>

<p><code>mvn dependency:list</code>: 列出项目最终解析到的依赖列表</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">[x<span class="meta">@localhost</span> excel-demo]$ mvn dependency:list</span><br><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[INFO]                                                                         </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Building excel-demo <span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-dependency-plugin:<span class="number">3.1</span><span class="number">.1</span>:list (<span class="keyword">default</span>-cli) @ excel-demo ---</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] The following files have been resolved:</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-data-jdbc:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-jdbc:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    com.zaxxer:HikariCP:jar:<span class="number">3.4</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    org.springframework:spring-jdbc:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.data:spring-data-jdbc:jar:<span class="number">1.1</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.data:spring-data-relational:jar:<span class="number">1.1</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-web:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-autoconfigure:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-logging:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.apache.logging.log4j:log4j-to-slf4j:jar:<span class="number">2.12</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO]    org.apache.logging.log4j:log4j-api:jar:<span class="number">2.12</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO]    org.slf4j:jul-to-slf4j:jar:<span class="number">1.7</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO]    jakarta.annotation:jakarta.annotation-api:jar:<span class="number">1.3</span><span class="number">.5</span>:compile</span><br><span class="line">[INFO]    org.yaml:snakeyaml:jar:<span class="number">1.25</span>:runtime</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-json:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    com.fasterxml.jackson.core:jackson-databind:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    com.fasterxml.jackson.core:jackson-annotations:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    com.fasterxml.jackson.core:jackson-core:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    com.fasterxml.jackson.module:jackson-module-parameter-names:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-tomcat:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.apache.tomcat.embed:tomcat-embed-core:jar:<span class="number">9.0</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO]    org.apache.tomcat.embed:tomcat-embed-el:jar:<span class="number">9.0</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO]    org.apache.tomcat.embed:tomcat-embed-websocket:jar:<span class="number">9.0</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-validation:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    jakarta.validation:jakarta.validation-api:jar:<span class="number">2.0</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    org.hibernate.validator:hibernate-validator:jar:<span class="number">6.0</span><span class="number">.18</span>.Final:compile</span><br><span class="line">[INFO]    org.springframework:spring-web:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-webmvc:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-expression:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    mysql:mysql-connector-java:jar:<span class="number">8.0</span><span class="number">.19</span>:runtime</span><br><span class="line">[INFO]    org.projectlombok:lombok:jar:<span class="number">1.18</span><span class="number">.8</span>:provided</span><br><span class="line">[INFO]    org.apache.poi:poi:jar:<span class="number">3.17</span>:compile</span><br><span class="line">[INFO]    commons-codec:commons-codec:jar:<span class="number">1.13</span>:compile</span><br><span class="line">[INFO]    org.apache.commons:commons-collections4:jar:<span class="number">4.1</span>:compile</span><br><span class="line">[INFO]    org.apache.poi:poi-ooxml:jar:<span class="number">3.17</span>:compile</span><br><span class="line">[INFO]    com.github.virtuald:curvesapi:jar:<span class="number">1.04</span>:compile</span><br><span class="line">[INFO]    org.apache.poi:poi-ooxml-schemas:jar:<span class="number">3.17</span>:compile</span><br><span class="line">[INFO]    org.apache.xmlbeans:xmlbeans:jar:<span class="number">2.6</span><span class="number">.0</span>:compile</span><br><span class="line">[INFO]    stax:stax-api:jar:<span class="number">1.0</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO]    cglib:cglib:jar:<span class="number">3.1</span>:compile</span><br><span class="line">[INFO]    org.ow2.asm:asm:jar:<span class="number">4.2</span>:compile</span><br><span class="line">[INFO]    org.slf4j:slf4j-api:jar:<span class="number">1.7</span><span class="number">.26</span>:compile</span><br><span class="line">[INFO]    org.ehcache:ehcache:jar:<span class="number">3.4</span><span class="number">.0</span>:compile</span><br><span class="line">[INFO]    ch.qos.logback:logback-classic:jar:<span class="number">1.2</span><span class="number">.3</span>:test</span><br><span class="line">[INFO]    ch.qos.logback:logback-core:jar:<span class="number">1.2</span><span class="number">.3</span>:test</span><br><span class="line">[INFO]    com.alibaba:fastjson:jar:<span class="number">1.2</span><span class="number">.67</span>:test</span><br><span class="line">[INFO]    junit:junit:jar:<span class="number">4.12</span>:test</span><br><span class="line">[INFO]    org.hamcrest:hamcrest-core:jar:<span class="number">2.1</span>:test</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-data-jpa:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-aop:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.aspectj:aspectjweaver:jar:<span class="number">1.9</span><span class="number">.5</span>:compile</span><br><span class="line">[INFO]    jakarta.activation:jakarta.activation-api:jar:<span class="number">1.2</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO]    jakarta.persistence:jakarta.persistence-api:jar:<span class="number">2.2</span><span class="number">.3</span>:compile</span><br><span class="line">[INFO]    jakarta.transaction:jakarta.transaction-api:jar:<span class="number">1.3</span><span class="number">.3</span>:compile</span><br><span class="line">[INFO]    org.hibernate:hibernate-core:jar:<span class="number">5.4</span><span class="number">.10</span>.Final:compile</span><br><span class="line">[INFO]    org.jboss.logging:jboss-logging:jar:<span class="number">3.4</span><span class="number">.1</span>.Final:compile</span><br><span class="line">[INFO]    org.javassist:javassist:jar:<span class="number">3.24</span><span class="number">.0</span>-GA:compile</span><br><span class="line">[INFO]    net.bytebuddy:byte-buddy:jar:<span class="number">1.10</span><span class="number">.6</span>:compile</span><br><span class="line">[INFO]    antlr:antlr:jar:<span class="number">2.7</span><span class="number">.7</span>:compile</span><br><span class="line">[INFO]    org.jboss:jandex:jar:<span class="number">2.1</span><span class="number">.1</span>.Final:compile</span><br><span class="line">[INFO]    com.fasterxml:classmate:jar:<span class="number">1.5</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO]    org.dom4j:dom4j:jar:<span class="number">2.1</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO]    org.hibernate.common:hibernate-commons-annotations:jar:<span class="number">5.1</span><span class="number">.0</span>.Final:compile</span><br><span class="line">[INFO]    org.glassfish.jaxb:jaxb-runtime:jar:<span class="number">2.3</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    org.glassfish.jaxb:txw2:jar:<span class="number">2.3</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    com.sun.istack:istack-commons-runtime:jar:<span class="number">3.0</span><span class="number">.8</span>:compile</span><br><span class="line">[INFO]    org.jvnet.staxex:stax-ex:jar:<span class="number">1.8</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO]    com.sun.xml.fastinfoset:FastInfoset:jar:<span class="number">1.2</span><span class="number">.16</span>:compile</span><br><span class="line">[INFO]    org.springframework:spring-aspects:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.data:spring-data-jpa:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework.data:spring-data-commons:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-orm:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-context:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-aop:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-tx:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-beans:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-core:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.springframework:spring-jcl:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO]    org.aspectj:aspectjrt:jar:<span class="number">1.9</span><span class="number">.5</span>:compile</span><br><span class="line">[INFO]    com.alibaba:easyexcel:jar:<span class="number">2.1</span><span class="number">.6</span>:compile</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-starter-test:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:test</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-test:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:test</span><br><span class="line">[INFO]    org.springframework.boot:spring-boot-test-autoconfigure:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:test</span><br><span class="line">[INFO]    com.jayway.jsonpath:json-path:jar:<span class="number">2.4</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    net.minidev:json-smart:jar:<span class="number">2.3</span>:test</span><br><span class="line">[INFO]    net.minidev:accessors-smart:jar:<span class="number">1.2</span>:test</span><br><span class="line">[INFO]    jakarta.xml.bind:jakarta.xml.bind-api:jar:<span class="number">2.3</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    org.junit.jupiter:junit-jupiter:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    org.junit.jupiter:junit-jupiter-api:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    org.apiguardian:apiguardian-api:jar:<span class="number">1.1</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    org.opentest4j:opentest4j:jar:<span class="number">1.2</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    org.junit.platform:junit-platform-commons:jar:<span class="number">1.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    org.junit.jupiter:junit-jupiter-params:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    org.junit.jupiter:junit-jupiter-engine:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    org.junit.platform:junit-platform-engine:jar:<span class="number">1.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    org.mockito:mockito-junit-jupiter:jar:<span class="number">3.1</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    org.assertj:assertj-core:jar:<span class="number">3.13</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    org.hamcrest:hamcrest:jar:<span class="number">2.1</span>:test</span><br><span class="line">[INFO]    org.mockito:mockito-core:jar:<span class="number">3.1</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    net.bytebuddy:byte-buddy-agent:jar:<span class="number">1.10</span><span class="number">.6</span>:test</span><br><span class="line">[INFO]    org.objenesis:objenesis:jar:<span class="number">2.6</span>:test</span><br><span class="line">[INFO]    org.skyscreamer:jsonassert:jar:<span class="number">1.5</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    com.vaadin.<span class="keyword">external</span>.google:android-json:jar:<span class="number">0.0</span><span class="number">.20131108</span>.vaadin1:test</span><br><span class="line">[INFO]    org.springframework:spring-test:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:test</span><br><span class="line">[INFO]    org.xmlunit:xmlunit-core:jar:<span class="number">2.6</span><span class="number">.3</span>:test</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: <span class="number">0.835</span> s</span><br><span class="line">[INFO] Finished at: <span class="number">2020</span><span class="number">-05</span><span class="number">-25</span>T20:<span class="number">45</span>:<span class="number">07</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] Final Memory: <span class="number">31</span>M/<span class="number">602</span>M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><code>mvn dependency:tree</code> : 打印出依赖树</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">[xxx<span class="meta">@localhost</span> excel-demo]$ mvn dependency:tree</span><br><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[INFO]                                                                         </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Building excel-demo <span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-dependency-plugin:<span class="number">3.1</span><span class="number">.1</span>:tree (<span class="keyword">default</span>-cli) @ excel-demo ---</span><br><span class="line">[INFO] com.developer:excel-demo:jar:<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT</span><br><span class="line">[INFO] +- org.springframework.boot:spring-boot-starter-data-jdbc:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-jdbc:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  +- com.zaxxer:HikariCP:jar:<span class="number">3.4</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |  \- org.springframework:spring-jdbc:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  \- org.springframework.data:spring-data-jdbc:jar:<span class="number">1.1</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |     \- org.springframework.data:spring-data-relational:jar:<span class="number">1.1</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  +- org.springframework.boot:spring-boot:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  +- org.springframework.boot:spring-boot-autoconfigure:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:<span class="number">2.12</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO] |  |  |  |  \- org.apache.logging.log4j:log4j-api:jar:<span class="number">2.12</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO] |  |  |  \- org.slf4j:jul-to-slf4j:jar:<span class="number">1.7</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO] |  |  +- jakarta.annotation:jakarta.annotation-api:jar:<span class="number">1.3</span><span class="number">.5</span>:compile</span><br><span class="line">[INFO] |  |  \- org.yaml:snakeyaml:jar:<span class="number">1.25</span>:runtime</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-json:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  +- com.fasterxml.jackson.core:jackson-databind:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |  |  +- com.fasterxml.jackson.core:jackson-annotations:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |  |  \- com.fasterxml.jackson.core:jackson-core:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:<span class="number">2.10</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-tomcat:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:<span class="number">9.0</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-el:jar:<span class="number">9.0</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO] |  |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:<span class="number">9.0</span><span class="number">.30</span>:compile</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-validation:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  +- jakarta.validation:jakarta.validation-api:jar:<span class="number">2.0</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |  \- org.hibernate.validator:hibernate-validator:jar:<span class="number">6.0</span><span class="number">.18</span>.Final:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-web:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  \- org.springframework:spring-webmvc:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |     \- org.springframework:spring-expression:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] +- mysql:mysql-connector-java:jar:<span class="number">8.0</span><span class="number">.19</span>:runtime</span><br><span class="line">[INFO] +- org.projectlombok:lombok:jar:<span class="number">1.18</span><span class="number">.8</span>:provided</span><br><span class="line">[INFO] +- org.apache.poi:poi:jar:<span class="number">3.17</span>:compile</span><br><span class="line">[INFO] |  +- commons-codec:commons-codec:jar:<span class="number">1.13</span>:compile</span><br><span class="line">[INFO] |  \- org.apache.commons:commons-collections4:jar:<span class="number">4.1</span>:compile</span><br><span class="line">[INFO] +- org.apache.poi:poi-ooxml:jar:<span class="number">3.17</span>:compile</span><br><span class="line">[INFO] |  \- com.github.virtuald:curvesapi:jar:<span class="number">1.04</span>:compile</span><br><span class="line">[INFO] +- org.apache.poi:poi-ooxml-schemas:jar:<span class="number">3.17</span>:compile</span><br><span class="line">[INFO] |  \- org.apache.xmlbeans:xmlbeans:jar:<span class="number">2.6</span><span class="number">.0</span>:compile</span><br><span class="line">[INFO] |     \- stax:stax-api:jar:<span class="number">1.0</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO] +- cglib:cglib:jar:<span class="number">3.1</span>:compile</span><br><span class="line">[INFO] |  \- org.ow2.asm:asm:jar:<span class="number">4.2</span>:compile</span><br><span class="line">[INFO] +- org.slf4j:slf4j-api:jar:<span class="number">1.7</span><span class="number">.26</span>:compile</span><br><span class="line">[INFO] +- org.ehcache:ehcache:jar:<span class="number">3.4</span><span class="number">.0</span>:compile</span><br><span class="line">[INFO] +- ch.qos.logback:logback-classic:jar:<span class="number">1.2</span><span class="number">.3</span>:test</span><br><span class="line">[INFO] |  \- ch.qos.logback:logback-core:jar:<span class="number">1.2</span><span class="number">.3</span>:test</span><br><span class="line">[INFO] +- com.alibaba:fastjson:jar:<span class="number">1.2</span><span class="number">.67</span>:test</span><br><span class="line">[INFO] +- junit:junit:jar:<span class="number">4.12</span>:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:<span class="number">2.1</span>:test</span><br><span class="line">[INFO] +- org.springframework.boot:spring-boot-starter-data-jpa:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-aop:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  \- org.aspectj:aspectjweaver:jar:<span class="number">1.9</span><span class="number">.5</span>:compile</span><br><span class="line">[INFO] |  +- jakarta.activation:jakarta.activation-api:jar:<span class="number">1.2</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO] |  +- jakarta.persistence:jakarta.persistence-api:jar:<span class="number">2.2</span><span class="number">.3</span>:compile</span><br><span class="line">[INFO] |  +- jakarta.transaction:jakarta.transaction-api:jar:<span class="number">1.3</span><span class="number">.3</span>:compile</span><br><span class="line">[INFO] |  +- org.hibernate:hibernate-core:jar:<span class="number">5.4</span><span class="number">.10</span>.Final:compile</span><br><span class="line">[INFO] |  |  +- org.jboss.logging:jboss-logging:jar:<span class="number">3.4</span><span class="number">.1</span>.Final:compile</span><br><span class="line">[INFO] |  |  +- org.javassist:javassist:jar:<span class="number">3.24</span><span class="number">.0</span>-GA:compile</span><br><span class="line">[INFO] |  |  +- net.bytebuddy:byte-buddy:jar:<span class="number">1.10</span><span class="number">.6</span>:compile</span><br><span class="line">[INFO] |  |  +- antlr:antlr:jar:<span class="number">2.7</span><span class="number">.7</span>:compile</span><br><span class="line">[INFO] |  |  +- org.jboss:jandex:jar:<span class="number">2.1</span><span class="number">.1</span>.Final:compile</span><br><span class="line">[INFO] |  |  +- com.fasterxml:classmate:jar:<span class="number">1.5</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO] |  |  +- org.dom4j:dom4j:jar:<span class="number">2.1</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO] |  |  +- org.hibernate.common:hibernate-commons-annotations:jar:<span class="number">5.1</span><span class="number">.0</span>.Final:compile</span><br><span class="line">[INFO] |  |  \- org.glassfish.jaxb:jaxb-runtime:jar:<span class="number">2.3</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |     +- org.glassfish.jaxb:txw2:jar:<span class="number">2.3</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO] |  |     +- com.sun.istack:istack-commons-runtime:jar:<span class="number">3.0</span><span class="number">.8</span>:compile</span><br><span class="line">[INFO] |  |     +- org.jvnet.staxex:stax-ex:jar:<span class="number">1.8</span><span class="number">.1</span>:compile</span><br><span class="line">[INFO] |  |     \- com.sun.xml.fastinfoset:FastInfoset:jar:<span class="number">1.2</span><span class="number">.16</span>:compile</span><br><span class="line">[INFO] |  \- org.springframework:spring-aspects:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework.data:spring-data-jpa:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework.data:spring-data-commons:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-orm:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-context:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-aop:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-tx:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-beans:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-core:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  |  \- org.springframework:spring-jcl:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:compile</span><br><span class="line">[INFO] |  \- org.aspectj:aspectjrt:jar:<span class="number">1.9</span><span class="number">.5</span>:compile</span><br><span class="line">[INFO] +- com.alibaba:easyexcel:jar:<span class="number">2.1</span><span class="number">.6</span>:compile</span><br><span class="line">[INFO] \- org.springframework.boot:spring-boot-starter-test:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:test</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-test:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:test</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-test-autoconfigure:jar:<span class="number">2.2</span><span class="number">.4</span>.RELEASE:test</span><br><span class="line">[INFO]    +- com.jayway.jsonpath:json-path:jar:<span class="number">2.4</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    |  \- net.minidev:json-smart:jar:<span class="number">2.3</span>:test</span><br><span class="line">[INFO]    |     \- net.minidev:accessors-smart:jar:<span class="number">1.2</span>:test</span><br><span class="line">[INFO]    +- jakarta.xml.bind:jakarta.xml.bind-api:jar:<span class="number">2.3</span><span class="number">.2</span>:compile</span><br><span class="line">[INFO]    +- org.junit.jupiter:junit-jupiter:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    |  +- org.junit.jupiter:junit-jupiter-api:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    |  |  +- org.apiguardian:apiguardian-api:jar:<span class="number">1.1</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    |  |  +- org.opentest4j:opentest4j:jar:<span class="number">1.2</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    |  |  \- org.junit.platform:junit-platform-commons:jar:<span class="number">1.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    |  +- org.junit.jupiter:junit-jupiter-params:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    |  \- org.junit.jupiter:junit-jupiter-engine:jar:<span class="number">5.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    |     \- org.junit.platform:junit-platform-engine:jar:<span class="number">1.5</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    +- org.mockito:mockito-junit-jupiter:jar:<span class="number">3.1</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    +- org.assertj:assertj-core:jar:<span class="number">3.13</span><span class="number">.2</span>:test</span><br><span class="line">[INFO]    +- org.hamcrest:hamcrest:jar:<span class="number">2.1</span>:test</span><br><span class="line">[INFO]    +- org.mockito:mockito-core:jar:<span class="number">3.1</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    |  +- net.bytebuddy:byte-buddy-agent:jar:<span class="number">1.10</span><span class="number">.6</span>:test</span><br><span class="line">[INFO]    |  \- org.objenesis:objenesis:jar:<span class="number">2.6</span>:test</span><br><span class="line">[INFO]    +- org.skyscreamer:jsonassert:jar:<span class="number">1.5</span><span class="number">.0</span>:test</span><br><span class="line">[INFO]    |  \- com.vaadin.<span class="keyword">external</span>.google:android-json:jar:<span class="number">0.0</span><span class="number">.20131108</span>.vaadin1:test</span><br><span class="line">[INFO]    +- org.springframework:spring-test:jar:<span class="number">5.2</span><span class="number">.3</span>.RELEASE:test</span><br><span class="line">[INFO]    \- org.xmlunit:xmlunit-core:jar:<span class="number">2.6</span><span class="number">.3</span>:test</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: <span class="number">0.747</span> s</span><br><span class="line">[INFO] Finished at: <span class="number">2020</span><span class="number">-05</span><span class="number">-25</span>T20:<span class="number">46</span>:<span class="number">17</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] Final Memory: <span class="number">31</span>M/<span class="number">602</span>M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><code>+-</code> 符号表示该包后面还有其它依赖包</p>
<p><code>\-</code> : 表示该包后面不再依赖其它 jar 包</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Alibaba之EasyExcel使用</title>
    <url>/2020/05/22/Alibaba%E4%B9%8BEasyExcel%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5dae4fdd51882554c07585d1" target="_blank" rel="noopener">EasyExcel 轻松灵活读取Excel内容</a></p>
<p><a href="https://wsk1103.github.io/2018/11/05/%E4%BD%BF%E7%94%A8easyexcel%E8%AF%BB%E5%86%99Excel/" target="_blank" rel="noopener">JAVA解析Excel工具easyexcel</a></p>
<p><a href="https://www.yuque.com/easyexcel/doc/read" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>项目中必不可少会有excel 导入的需求。之前项目中excel的导入都是由组里的大佬通过组装poi包来实现的。</p>
<p>可是效率有点惨不忍睹，虽然还挺好用。。。，偶然使用了 easyexcel 才发现差距原来有点大。</p>
</blockquote>
<a id="more"></a>

<h1><span id="依赖">依赖</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- easyexcel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml-schemas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="对比">对比</span></h1><p>大佬封装的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">parseExcelToObject</span><span class="params">(MultipartFile multipartFile, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> RestApiException </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Field[] fields = getFields(clazz);</span><br><span class="line">    List&lt;List&lt;Cell&gt;&gt; parseList = parseExcel(multipartFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseList || parseList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Cell&gt; cellList : parseList) &#123;</span><br><span class="line">            T object = clazz.newInstance();</span><br><span class="line">            cellList.stream().forEach(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = e.getColumnIndex();</span><br><span class="line">                    setFieldValue(object, fields[index], e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            resultList.add(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">"解析文件出错   e=&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ErrorConstant.PARSE_IMPORT_FILE_ERROR, ErrorConstant.PARSE_IMPORT_FILE_ERROR_MSG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上都是使用了原生的poi包的东西，没有进行二次封装。</p>
<p>使用了 <code>easyexcel</code> 的模板代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">excelImport</span>(<span class="title">MultipartFile</span> <span class="title">file</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(file.getInputStream());</span><br><span class="line">        EasyExcel.read(bufferedInputStream, xxx<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">xxx</span>&gt;() </span>&#123;</span><br><span class="line"></span><br><span class="line">            List&lt;xxx&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(xxx data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">"解析到一条数据:&#123;&#125;"</span>, JSON.toJSONString(data));</span><br><span class="line">                <span class="comment">//可以在此实现业务代码</span></span><br><span class="line">                list.add(data);</span><br><span class="line">                <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">                    saveData();</span><br><span class="line">                    <span class="comment">// 存储完成清理 list</span></span><br><span class="line">                    list.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">                saveData();</span><br><span class="line">                log.info(<span class="string">"所有数据解析完成！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 加上存储数据库</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"&#123;&#125;条数据，开始存储数据库！"</span>, list.size());</span><br><span class="line">                saveAll(list);</span><br><span class="line">                log.info(<span class="string">"存储数据库成功！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).sheet().doRead();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="测试">测试</span></h1><p>数据量：390条数据</p>
<p>耗时：2215</p>
<p><img src="https://img-blog.csdnimg.cn/2020052215045712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="203"></p>
<p>耗时：242</p>
<p><img src="https://img-blog.csdnimg.cn/20200522150434184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="202"></p>
<p>差距在10倍左右。如果数据量增大的话，感觉差距可能会更大。。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Alibaba</category>
      </categories>
      <tags>
        <tag>EasyExcel</tag>
        <tag>excel导入</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven之程序包或符号找不到错误解决</title>
    <url>/2020/05/21/Maven%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%88%96%E7%AC%A6%E5%8F%B7%E6%89%BE%E4%B8%8D%E5%88%B0%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<blockquote>
<p>这几天在开发的时候总是被这个错误折磨的不行，严重影响了我的开发效率TAT, 终于今天晚上义务加班开发的时候又碰到了，好奇心驱使我定下来去寻根解答哈哈。(我也觉得奇怪，为什么今天可以这么有耐心。。哈哈)</p>
</blockquote>
<a id="more"></a>

<p>先上图，记住这个坏蛋</p>
<p><img src="https://img-blog.csdnimg.cn/20200521221205364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="198"></p>
<p>本来之前还好好的，想启动程序测试下接口，却报以上错误。回想了下，原来我把 <code>common</code> 包从idea上删除了。<strong>分析下看来我的这个项目之前是依赖 idea 中本地的 module</strong>。</p>
<p>于是有尝试了下万能的 <code>mvn idea:module</code> 或 <code>mvn idea:idea</code> 发现依然不能解决问题。</p>
<p>想起了之前看了一篇文章说，这个问题的原因很有可能是这个项目的没有添加这个依赖，也就是在 <code>xxx.iml</code> 中没有这个依赖的记录，导致 idea 智障的无法识别！！可是问题又来了，为什么在代码中并没有报错，并且可以跳转到源代码(也就是错觉的认为我这个项目应该是有这个依赖才对)。其实呢，可以跳转的原因是你本地的maven仓库是有这个依赖的，可是你这个项目并没有成功添加这个依赖呢！不信？，我们看看图片吧!</p>
<p><img src="https://img-blog.csdnimg.cn/20200521221243479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="200"></p>
<p><img src="https://img-blog.csdnimg.cn/20200521221223265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="199"></p>
<p>发现这个服务还真的没找到缺少的依赖！！！并且在 <code>xxx.iml</code> 下也没有记录！！！原来如此</p>
<p><img src="https://img-blog.csdnimg.cn/20200521221330290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="201"></p>
<p>通过添加相关缺少的依赖很好的解决问题。</p>
<p>个人建议：<strong>idea 存在多个无关module的时候，尽量remove无关的module，避免不必要的错误！</strong></p>
<p>好了，又可以愉快的开发了</p>
<h1><span id="更新">更新</span></h1><p>如果你的版本是 <strong>idea 2020.1版本</strong>的，尝试参考这个 <a href="https://blog.csdn.net/qq_35524157/article/details/105867493" target="_blank" rel="noopener">文章</a> 解决下</p>
<p>发现 <code>mvn idea:module</code> 和 <code>mvn idea:idea</code> 是个有用的命令</p>
]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity之AbstractSecurityInterceptor学习</title>
    <url>/2020/05/20/SpringSecurity%E4%B9%8BAbstractSecurityInterceptor%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/5f03d17212c6" target="_blank" rel="noopener">spring security 核心 – AbstractSecurityInterceptor</a></p>
<p><a href="https://docs.spring.io/spring-security/site/docs/4.2.14.RELEASE/apidocs/org/springframework/security/access/intercept/AbstractSecurityInterceptor.html" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>SpringSecurity在微服务中还是必不可少的，所以一定要学好!</p>
</blockquote>
<a id="more"></a>

<p>Spring Security 核心流程的实现有 <code>AbstractSecurityInterceptor</code> 实现，也就是说 <code>AbstractSecurityInterceptor</code> 只是定义了一些行为，然后这些行为的实现由具体的子类实现。</p>
<p><code>AbstractSecurityInterceptor</code> 虽然也叫 Interceptor，但是并没有继承和实现任何和过滤器类相关的类。具体和过滤器有关的部分是由子类所定义。每一种受保护对象都拥有继承自AbstrachSecurityInterceptor的拦截器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,</span></span><br><span class="line"><span class="class">		<span class="title">ApplicationEventPublisherAware</span>, <span class="title">MessageSourceAware</span></span></span><br></pre></td></tr></table></figure>

<p>spring security 提供了两个具体实现类:</p>
<ul>
<li>MethodSecurityInterceptor 将用于受保护的方法</li>
<li>FilterSecurityInterceptor 用于受保护的web 请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">Filter</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
        <tag>AbstractSecurityInterceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity之异常类</title>
    <url>/2020/05/20/SpringSecurity%E4%B9%8B%E5%BC%82%E5%B8%B8%E7%B1%BB/</url>
    <content><![CDATA[<p>转载自：<a href="https://juejin.im/post/5dc3528c5188255f6b6756c3" target="_blank" rel="noopener">Spring Security 实战干货：自定义异常处理</a></p>
<a id="more"></a>

<p>Spring Security 中的异常主要分为两大类：</p>
<ul>
<li>认证异常</li>
<li>授权相关异常</li>
</ul>
<h1><span id="1spring-security-中的异常">1.Spring Security 中的异常</span></h1><h2><span id="11-authenticationexception">1.1 AuthenticationException</span></h2><p><code>AuthenticationException</code> 是在用户认证的时候出现错误时抛出的异常</p>
<p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C196.png" alt="196"></p>
<h2><span id="12-accessdeniedexception">1.2 AccessDeniedException</span></h2><p><code>AccessDeniedException</code> 主要在用户在访问受保护资源时候被拒绝而抛出的异常</p>
<p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C197.png" alt="197"></p>
<p><code>AccessDeniedException</code> 的子类比较少，主要是 <code>CSRF</code> 相关的异常和授权服务异常</p>
<h1><span id="2http-状态对认证授权的规定">2.Http 状态对认证授权的规定</span></h1><p><strong>Http</strong> 协议对认证授权的响应结果也有规定。</p>
<h2><span id="21-401-未授权状态">2.1 401 未授权状态</span></h2><p><strong>HTTP 401 错误 - 未授权(Unauthorized)</strong> 一般来说该错误消息表明您首先需要登录（输入有效的用户名和密码）。 如果你刚刚输入这些信息，立刻就看到一个 <code>401</code> 错误，就意味着，无论出于何种原因您的用户名和密码其中之一或两者都无效（输入有误，用户名暂时停用，账户被锁定，凭证失效等） 。总之就是认证失败了。其实正好对应我们上面的 <code>AuthenticationException</code> 。</p>
<h2><span id="22-403-被拒绝状态">2.2 403 被拒绝状态</span></h2><p><strong>HTTP 403 错误 - 被禁止(Forbidden)</strong>  出现该错误表明您在访问受限资源时没有得到许可。服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。并且服务器想让客户端知道为什么没有权限访问特定的资源，服务器应该在返回的信息中描述拒绝的理由。一般实践中我们会比较模糊的表明原因。 该错误对应了我们上面的 <code>AccessDeniedException</code> 。</p>
<h1><span id="3spring-security-中的异常处理">3.Spring Security 中的异常处理</span></h1><p>在自定义配置类入口 <code>WebSecurityConfigurerAdapter</code> 中 <code>HttpSecurity</code> 提供的 <code>exceptionHandling()</code> 方法用来提供异常处理。该方法构造出 <code>ExceptionHandlingConfigurer</code> 异常处理配置类。该配置类提供了两个实用接口：</p>
<ul>
<li><strong>AuthenticationEntryPoint</strong> 该类用来统一处理 <code>AuthenticationException</code> 异常</li>
<li><strong>AccessDeniedHandler</strong> 该类用来统一处理 <code>AccessDeniedException</code> 异常</li>
</ul>
<p>ExceptionHandlingConfigurer 源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlingConfigurer</span>&lt;<span class="title">H</span> <span class="keyword">extends</span> <span class="title">HttpSecurityBuilder</span>&lt;<span class="title">H</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractHttpConfigurer</span>&lt;<span class="title">ExceptionHandlingConfigurer</span>&lt;<span class="title">H</span>&gt;, <span class="title">H</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;RequestMatcher, AuthenticationEntryPoint&gt; defaultEntryPointMappings = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;RequestMatcher, AccessDeniedHandler&gt; defaultDeniedHandlerMappings = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要实现并配置这两个异常处理类即可实现对 <strong>Spring Security</strong> 认证授权相关的异常进行统一的自定义处理。</p>
<h2><span id="31-实现-authenticationentrypoint">3.1 实现 AuthenticationEntryPoint</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//AuthenticationException</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo your business</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"uri"</span>, request.getRequestURI());</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"认证失败"</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String resBody = objectMapper.writeValueAsString(map);</span><br><span class="line">        PrintWriter printWriter = response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="32-实现-accessdeniedhandler">3.2 实现 AccessDeniedHandler</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.AccessDeniedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.AccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//AccessDeniedException</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//todo your business</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"uri"</span>, request.getRequestURI());</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"认证失败"</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String resBody = objectMapper.writeValueAsString(map);</span><br><span class="line">        PrintWriter printWriter = response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="33-配置">3.3 配置</span></h2><p>实现了上述两个接口后，我们只需要在 <code>WebSecurityConfigurerAdapter</code> 的 <code>configure(HttpSecurity http)</code> 方法中配置即可。相关的配置片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.exceptionHandling().accessDeniedHandler(<span class="keyword">new</span> SimpleAccessDeniedHandler()).authenticationEntryPoint(<span class="keyword">new</span> SimpleAuthenticationEntryPoint())</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7下Spark之搭建</title>
    <url>/2020/05/20/Centos7%E4%B8%8BSpark%E4%B9%8B%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><a href="https://github.com/01Lv/BigData-Notes/blob/master/notes/installation/Spark%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md" target="_blank" rel="noopener">Spark开发环境搭建</a></p>
<p><a href="http://spark.apache.org/" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>AI + BigData + 云计算</p>
</blockquote>
<a id="more"></a>

<p>其实 Spark 的搭建过程还是挺顺手的，基本没什么坑。</p>
<p>结果：</p>
<p>统计 <code>wc.txt</code> 文本中词频</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop,spark,hadoop</span><br><span class="line">spark,flink,flink,spark</span><br><span class="line">hadoop,hadoop</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200520153437781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="195"></p>
<p>图片中可以看出： <strong>flink 出现2次; spark 出现3次；hadoop 出现4次</strong></p>
<p>Spark 是基于 Scala 语言进行开发的，分别提供了基于 Scala、Java、Python 语言的 API，如果你想使用 Scala 语言进行开发，则需要搭建 Scala 语言的开发环境。这边文章(<a href="https://github.com/01Lv/BigData-Notes/blob/master/notes/installation/Spark%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md" target="_blank" rel="noopener">Spark开发环境搭建</a>)也详细的介绍了 <code>Scala</code> 环境的搭建。</p>
<p>端口：4040</p>
<p><img src="https://img-blog.csdnimg.cn/20200520153418406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="194"></p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7下Hadoop之单机搭建</title>
    <url>/2020/05/20/Centos7%E4%B8%8BHadoop%E4%B9%8B%E5%8D%95%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><a href="https://github.com/01Lv/BigData-Notes/blob/master/notes/installation/Hadoop%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md" target="_blank" rel="noopener">Hadoop单机版环境搭建</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1121838" target="_blank" rel="noopener">centos7 hadoop 单机模式安装配置</a></p>
<p><a href="https://hadoop.apache.org/" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>AI+BigData+云计算</p>
</blockquote>
<a id="more"></a>

<p>其实大部分安装过程这边文章(<a href="https://github.com/01Lv/BigData-Notes/blob/master/notes/installation/Hadoop%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md" target="_blank" rel="noopener">Hadoop单机版环境搭建</a>)已经说的很清楚了,只是简单的说几个需要注意的点：</p>
<ul>
<li>安装包注意不要下成 <code>source</code> 或者 <code>binary</code> ,直接到 <code>Release Note</code> 去下载</li>
<li>安装过程按照文章一步一步来就能成功了</li>
</ul>
<p>结果</p>
<p>端口：50070</p>
<p><img src="https://img-blog.csdnimg.cn/202005201235163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="192"></p>
<p>端口：8088</p>
<p><img src="https://img-blog.csdnimg.cn/20200520123544221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="193"></p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之过滤器OncePerRequestFilter</title>
    <url>/2020/05/16/SpringBoot%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8OncePerRequestFilter/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u013089490/article/details/84878319" target="_blank" rel="noopener">SpringBoot基础篇(五)过滤器OncePerRequestFilter</a></p>
<a id="more"></a>

<p>OncePerRequestFilter，顾名思义，它能够确保在一次请求中只通过一次filter，而需要重复的执行。大家常识上都认为，一次请求本来就只filter一次，为什么还要由此特别限定呢，往往我们的常识和实际的实现并不真的一样，经过一番资料的查阅，此方法是为了兼容不同的web container，也就是说并不是所有的container都入我们期望的只过滤一次，servlet版本不同，执行过程也不同，因此，为了兼容各种不同运行环境和版本，默认filter继承OncePerRequestFilter是一个比较稳妥的选择。</p>
<p>未完待续</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>OncePerRequestFilter</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之日志学习</title>
    <url>/2020/05/16/Linux%E4%B9%8B%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.linuxidc.com/Linux/2018-11/155193.htm" target="_blank" rel="noopener">Linux日志分析详解</a></p>
<blockquote>
<p>Linux日志系统分析</p>
</blockquote>
<a id="more"></a>

<p><strong>会看Linux日志是非常重要的，不仅在日常操作中可以迅速排错，也可以快速的定位。</strong></p>
<p>在 linux 系统当中，有三个主要的日志子系统：</p>
<ol>
<li><strong>连接时间日志：</strong>由多个程序执行，把记录写入到/var/log/wtmp和/var/run/utmp，<br>login等程序会更新wtmp和utmp文件，使系统管理员能够跟踪谁在何时登录到系统。</li>
<li><strong>进程统计：</strong>由系统内核执行，当一个进程终止时，为每个进程往进程统计文件中写一个记录。进程统计的目的是为系统中的基本服务提供命令使用统计</li>
<li><strong>错误日志</strong>：由rsyslogd守护程序执行，各种系统守护进程、用户程序和内核通过rsyslogd守护程序向文件/var/log/messages报告值得注意的时间。另外有许多linux程序创建日志，像HTTP和FTP这样提供的服务器也保持详细的日志。</li>
<li>其它日志…</li>
</ol>
<h1><span id="日志的保存位置">日志的保存位置</span></h1><p>默认日志位于 <code>/var/log</code> 目录下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200516174813313.jpg#pic_center" alt="191"></p>
<p>主要日志文件介绍：</p>
<p>内核及公共消息日志:/var/log/messages<br>计划任务日志：/var/log/cron<br>系统引导日志：/var/log/dmesg<br>邮件系统日志:/var/log/maillog<br>用户登录日志：/var/log/lastlog<br>/var/log/boot.log（记录系统在引导过程中发生的时间）<br>/var/log/secure (用户验证相关的安全性事件)<br>/var/log/wtmp(当前登录用户详细信息)<br>/var/log/btmp（记录失败的的记录）<br>/var/run/utmp（用户登录、注销及系统开、关等事件）</p>
<p><strong><em>命令</em></strong></p>
<p>查看最近谁登录过系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ybs@localhost ~]$ last</span><br><span class="line">ybs      pts/2        :0               Fri May 15 19:37   still logged in   </span><br><span class="line">ybs      pts/2        :0               Fri May 15 09:19 - 09:19  (00:00)    </span><br><span class="line">ybs      pts/2        :0               Fri May 15 09:14 - 09:16  (00:01)    </span><br><span class="line">ybs      pts/2        :0               Thu May 14 20:56 - 20:56  (00:00)    </span><br><span class="line">ybs      pts/2        :0               Thu May 14 18:59 - 19:00  (00:00)    </span><br><span class="line">ybs      pts/0        :0               Thu May 14 12:15 - 16:06 (2+03:50)   </span><br><span class="line">ybs      pts/0        :0               Thu May 14 12:14 - 12:14  (00:00)    </span><br><span class="line">ybs      :0           :0               Thu May 14 12:08   still logged in   </span><br><span class="line">reboot   system boot  3.10.0-1127.el7. Thu May 14 20:07 - 17:37 (1+21:30)   </span><br><span class="line">ybs      pts/1        :0               Thu May 14 10:02 - 10:03  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Wed May 13 20:12 - 20:12  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Wed May 13 15:36 - 15:36  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Tue May 12 18:05 - 18:05  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Tue May 12 18:04 - 18:04  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Tue May 12 18:04 - 18:04  (00:00)    </span><br><span class="line">ybs      pts/4        :0               Tue May 12 16:00 - 16:00  (00:00)    </span><br><span class="line">ybs      pts/4        :0               Tue May 12 13:00 - 13:01  (00:00)    </span><br><span class="line">ybs      pts/4        :0               Tue May 12 12:42 - 12:43  (00:00)    </span><br><span class="line">ybs      pts/4        :0               Tue May 12 12:41 - 12:42  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Tue May 12 12:41 - 16:01  (03:19)    </span><br><span class="line">ybs      pts/3        :0               Mon May 11 21:21 - 21:21  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Mon May 11 21:17 - 21:17  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Mon May 11 17:39 - 18:36  (00:56)    </span><br><span class="line">ybs      pts/4        :0               Mon May 11 17:39 - 17:39  (00:00)    </span><br><span class="line">ybs      pts/3        :0               Mon May 11 17:38 - 17:39  (00:01)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity之@EnableGlobalMethodSecurity学习</title>
    <url>/2020/05/16/SpringSecurity%E4%B9%8BEnableGlobalMethodSecurity%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/41b7c3fb00e0" target="_blank" rel="noopener">spring security 注解@EnableGlobalMethodSecurity详解</a></p>
<a id="more"></a>

<p>Spring Security 默认是禁用注解的，要想开启注解，需要继承 WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解， 来判断用户对某个控制层的方法是否具有访问权限 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>例如下面代码就表示如果用户具有admin角色，就能访问listAllUsers方法，但是如果方法前不加@preAuthorize注解，意味着所有用户都能访问listAllUsers</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole(‘admin‘)"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user/"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function">publicList <span class="title">listAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问</p>
<p><em>@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常</em></p>
<p><em>@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果</em></p>
<p><em>@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值</em></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>EnableGlobalMethodSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson之ObjectMapper的使用</title>
    <url>/2020/05/16/Jackson%E4%B9%8BObjectMapper%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/67b6da565f81" target="_blank" rel="noopener">jackson中objectMapper的使用</a></p>
<blockquote>
<p>最近在使用restemplate调用接口的时候，发现同事使用 ObjectMapper 将请求体参数转换为 json格式字符串。</p>
</blockquote>
<a id="more"></a>

<p>Jackson 可以轻松的将Java对象转换成json对象和 xml文档，同样也可以将json，xml转换成为Java对象.</p>
<p>ObjectMapper类是Jackson库的主要类。它称为ObjectMapper的原因是因为它将JSON映射到Java对象（反序列化），或将Java对象映射到JSON（序列化）。它使用JsonParser和JsonGenerator的实例实现JSON实际的读/写。</p>
<h1><span id="依赖">依赖</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="jackson-objectmapper如何将json字段与java字段匹配">Jackson ObjectMapper如何将JSON字段与Java字段匹配</span></h1><p>三种方式<br> 1.Jackson通过将JSON字段的名称与Java对象中的getter和setter方法相匹配，将JSON对象的字段映射到Java对象中的字段。Jackson删除了getter和setter方法名称的“get”和“set”部分，并将剩余名称的第一个字符转换为小写。<br> 2.Jackson还可以通过java反射进行匹配<br> 3.通过注解或者其它方式进行自定义的序列化和反序列化程序。</p>
<h4><span id="转java对象">转Java对象</span></h4><p>Read Object From JSON String</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="built_in">String</span> carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line">Car car = objectMapper.readValue(carJson, Car<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure>

<p>Read Object From JSON Reader</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="built_in">String</span> carJson =  <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 4 &#125;"</span>;</span><br><span class="line">Reader reader = <span class="keyword">new</span> StringReader(carJson);</span><br><span class="line">Car car = objectMapper.readValue(reader, Car<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure>

<p>Read Object From JSON File</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"data/car.json"</span>);</span><br><span class="line">Car car = objectMapper.readValue(file, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Read Object From JSON via URL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"file:data/car.json"</span>);</span><br><span class="line">Car car = objectMapper.readValue(url, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>本例使用的是文件URL，也可使用一个HTTP URL（如：<code>http://jenkov.com/some-data.json</code> ).</p>
<p>Read Object From JSON InputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"data/car.json"</span>);</span><br><span class="line">Car car = objectMapper.readValue(input, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Read Object From JSON Byte Array</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String carJson =  <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = carJson.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">Car car = objectMapper.readValue(bytes, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Read Object Array From JSON Array String</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> jsonArray = <span class="string">"[&#123;\"brand\":\"ford\"&#125;, &#123;\"brand\":\"Fiat\"&#125;]"</span>;</span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Car[] cars2 = objectMapper.readValue(jsonArray, Car[]<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure>

<p>Read Object List From JSON Array String</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> jsonArray = <span class="string">"[&#123;\"brand\":\"ford\"&#125;, &#123;\"brand\":\"Fiat\"&#125;]"</span>;</span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="built_in">List</span>&lt;Car&gt; cars1 = objectMapper.readValue(jsonArray, <span class="keyword">new</span> TypeReference&lt;<span class="built_in">List</span>&lt;Car&gt;&gt;()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>Read Map from JSON String</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> jsonObject = <span class="string">"&#123;\"brand\":\"ford\", \"doors\":5&#125;"</span>;</span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; jsonMap = objectMapper.readValue(jsonObject,</span><br><span class="line">    <span class="keyword">new</span> TypeReference&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;&gt;()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4><span id="转json">转Json</span></h4><p>ObjectMapper write有三个方法</p>
<blockquote>
<ul>
<li>writeValue()</li>
<li>writeValueAsString()</li>
<li>writeValueAsBytes()</li>
</ul>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.brand = <span class="string">"BMW"</span>;</span><br><span class="line">car.doors = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//写到文件中</span></span><br><span class="line">objectMapper.writeValue( <span class="keyword">new</span> FileOutputStream(<span class="string">"data/output-2.json"</span>), car);</span><br><span class="line"><span class="comment">//写到字符串中</span></span><br><span class="line"><span class="built_in">String</span> json = objectMapper.writeValueAsString(car);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>ObjectMapper</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx之日志学习</title>
    <url>/2020/05/15/Nginx%E4%B9%8B%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/ty_hf/article/details/55518070" target="_blank" rel="noopener">日志-nginx的access_log与error_log</a></p>
<a id="more"></a>

<p>查找日志存放地址,进入该文件进行编辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name nginx.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200515215952162.png#pic_center" alt="190"></p>
<p>查看 error_log 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/nginx/error.log.warn</span><br></pre></td></tr></table></figure>

<p>访问日志分析</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">100.109.195.91</span> - - <span class="string">[17/Feb/2017:00:08:11 +0800]</span> <span class="string">"<span class="keyword">GET</span> /data/upload/shop/common/loading.gif HTTP/1.0"</span> <span class="number">200</span> <span class="number">134</span> <span class="string">"http://www.mall121.com/"</span> <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Trident/4.0; Windows NT 6.1; SLCC2 2.5.5231; .NET CLR 2.0.50727; .NET CLR 4.1.23457; .NET CLR 4.0.23457; Media Center PC 6.0; MS-WK 8)"</span> <span class="string">"140.205.201.12"</span></span><br><span class="line"><span class="number">100.109.195.78</span> - - <span class="string">[17/Feb/2017:00:08:11 +0800]</span> <span class="string">"<span class="keyword">GET</span> /shop/templates/default/images/u-safe.png HTTP/1.0"</span> <span class="number">200</span> <span class="number">3675</span> <span class="string">"http://www.mall121.com/"</span> <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Trident/4.0; Windows NT 6.1; SLCC2 2.5.5231; .NET CLR 2.0.50727; .NET CLR 4.1.23457; .NET CLR 4.0.23457; Media Center PC 6.0; MS-WK 8)"</span> <span class="string">"140.205.201.12"</span></span><br><span class="line"><span class="number">100.109.195.26</span> - - <span class="string">[17/Feb/2017:00:08:11 +0800]</span> <span class="string">"<span class="keyword">GET</span> /data/upload/shop/adv/05240495346955824.jpg HTTP/1.0"</span> <span class="number">404</span> <span class="number">564</span> <span class="string">"http://www.mall121.com/"</span> <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Trident/4.0; Windows NT 6.1; SLCC2 2.5.5231; .NET CLR 2.0.50727; .NET CLR 4.1.23457; .NET CLR 4.0.23457; Media Center PC 6.0; MS-WK 8)"</span> <span class="string">"140.205.201.12"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.100.109.195.91 :</span><br><span class="line"><span class="meta">$</span><span class="bash">remote_addr : 客户端（用户）IP地址 </span></span><br><span class="line">2.[17/Feb/2017:00:08:11 +0800]:</span><br><span class="line"><span class="meta">$</span><span class="bash">time_local  :访问时间</span></span><br><span class="line">3."GET /data/upload/shop/common/loading.gif HTTP/1.0"  :</span><br><span class="line">"$request"get请求的url地址（目标url地址）的host</span><br><span class="line">4.200:</span><br><span class="line">'$status请求状态（状态码，200表示成功，404表示页面不存在，301表示永久重定向等，具体状态码可以在网上找相关文章，不再赘述）</span><br><span class="line">5. 134 :</span><br><span class="line"><span class="meta">$</span><span class="bash">body_bytes_sent ：请求页面大小，默认为B（byte</span></span><br><span class="line">6."http://www.mall121.com/" :</span><br><span class="line">"$http_referer" : 来源页面，即从哪个页面转到本页，专业名称叫做“referer”</span><br><span class="line">7."Mozilla/4.0 (compatible; MSIE 8.0; Trident/4.0; Windows NT 6.1; SLCC2 2.5.5231; .NET CLR 2.0.50727; .NET CLR 4.1.23457; .NET CLR 4.0.23457; Media Center PC 6.0; MS-WK 8)":</span><br><span class="line"><span class="meta">$</span><span class="bash">http_user_agent:用户浏览器其他信息，浏览器版本、浏览器类型</span></span><br><span class="line">8. "140.205.201.12" :</span><br><span class="line"><span class="meta">$</span><span class="bash">http_x_forwarded_for<span class="string">"</span></span></span><br></pre></td></tr></table></figure>

<p>或者通过nginx配置文件里的配置，换一种格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">log_format main '$remote_addr - $remote_user [$time_local] '</span><br><span class="line">                     'fwf[$http_x_forwarded_for] tip[$http_true_client_ip] '</span><br><span class="line">                     '$upstream_addr $upstream_response_time $request_time '</span><br><span class="line">                     '$geoip_country_code '</span><br><span class="line">                     '$http_host $request '</span><br><span class="line">                     '"$status" $body_bytes_sent "$http_referer" '</span><br><span class="line">                     '"$http_accept_language" "$http_user_agent" ';</span><br></pre></td></tr></table></figure>

<p>1.客户端（用户）IP地址。<br>2.访问时间。<br>3.访问端口。<br>4.响应时间。<br>5.请求时间。<br>6.用户地理位置代码（国家代码）。<br>7.请求的url地址（目标url地址）的host。<br>8.请求方式（GET或者POST等）。<br>9.请求url地址（去除host部分）。<br>10.请求状态（状态码，200表示成功)。<br>11.请求页面大小，默认为B（byte）。<br>12.来源页面，即从哪个页面转到本页，专业名称叫做“referer”。<br>13.用户浏览器语言。如：上例中的 “es-ES,es;q=0.8”<br>14.用户浏览器其他信息，浏览器版本、浏览器类型等。</p>
]]></content>
      <tags>
        <tag>日志</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之单元测试学习</title>
    <url>/2020/05/15/SpringBoot%E4%B9%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/bobo_12138/article/details/77609109" target="_blank" rel="noopener">spring boot写单元测试(测试service层)</a></p>
<p><a href="https://juejin.im/post/5bf970d66fb9a049dd7ff285" target="_blank" rel="noopener">Spring Boot实战系列(5)单元测试</a></p>
<blockquote>
<p>项目上有需求要用到单元测试，并且在未来可能会有代码测试覆盖率的指标，所以提前学习下。其实是只写了业务层的代码实现，可是没有接口，所以想到了通过单元测试来模拟接口调用哈哈</p>
</blockquote>
<a id="more"></a>

<h1><span id="关键点">关键点</span></h1><ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在测试类上加上注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>注入自己需要的bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> NetworkProxy networkProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNetworkProxy</span><span class="params">(NetworkProxy networkProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.networkProxy = networkProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实像正常的开发Service那样使用单元测试类就好了</p>
<h1><span id="结果">结果</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RestaurantServiceImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NetworkProxy networkProxy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNetworkProxy</span><span class="params">(NetworkProxy networkProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.networkProxy = networkProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取accessToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpHeaders requestHeader = <span class="keyword">new</span> RequestHeaderUtils.RequestHeaderBuilder()</span><br><span class="line">            .setContentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">            .build().getRequestHeader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//body</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; requestTokenBody = <span class="keyword">new</span> RequestBodyUtils.RequestBodyBuilder()</span><br><span class="line">            .setGrantType(<span class="string">"xxx"</span>)</span><br><span class="line">            .setUsername(<span class="string">"xxx"</span>)</span><br><span class="line">            .setPassword(<span class="string">"xxx;"</span>)</span><br><span class="line">            .build().getRequestBody();</span><br><span class="line"></span><br><span class="line">        HttpEntity httpEntity = <span class="keyword">new</span> HttpEntity(requestTokenBody,requestHeader);</span><br><span class="line">        RestaurantRespDTO&lt;TokenRespDTO&gt; result = networkProxy.request(NetworkProxy.Target.RESTAURANT_LOGIN,HttpMethod.POST,httpEntity,</span><br><span class="line">                                                                      <span class="keyword">new</span> ParameterizedTypeReference&lt;RestaurantRespDTO&lt;TokenRespDTO&gt;&gt;()&#123;&#125;, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        log.info(<span class="string">"调用登录接口返回 全部消息: "</span> + result);</span><br><span class="line">        log.info(<span class="string">"调用登录接口返回 Code 码: "</span> + result.getStatusCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(result.isSuccess())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.getData().getAccess_token();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其他，获取token失败</span></span><br><span class="line">            log.error(<span class="string">"获取token失败: "</span> + result.getStatusMsg());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(Integer.parseInt(result.getStatusCode()),result.getStatusMsg());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getxxxIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Restemplate多级泛型反序列化问题解决</title>
    <url>/2020/05/15/Restemplate%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<blockquote>
<p>在项目开发过程中碰到restemplate.exchange()方法反序列化失败，因为接收接口返回的数据是一个复杂的dto，该dto中存在泛型的属性。期待是转成 xxxDto,可是得到的确实LinkedMap，并且抛出了转换类型错误。</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_33457058/article/details/65442566" target="_blank" rel="noopener">RestTemplate的多级泛型和消息转换器</a></p>
<p><a href="https://www.jianshu.com/p/1cf198ade077" target="_blank" rel="noopener">RestTemplate 反序列化带泛型的返回值</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/ParameterizedTypeReference.html" target="_blank" rel="noopener">ParameterizedTypeReference官网</a></p>
<a id="more"></a>

<h1><span id="解决">解决</span></h1><p>首先看看 exchange源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">exchange</span><span class="params">(String url, HttpMethod method, @Nullable HttpEntity&lt;?&gt; requestEntity, ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        Type type = responseType.getType();</span><br><span class="line">        RequestCallback requestCallback = <span class="keyword">this</span>.httpEntityCallback(requestEntity, type);</span><br><span class="line">        ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = <span class="keyword">this</span>.responseEntityExtractor(type);</span><br><span class="line">        <span class="keyword">return</span> (ResponseEntity)nonNull(<span class="keyword">this</span>.execute(url, method, requestCallback, responseExtractor, uriVariables));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>exchange()</code>源码可以看出需序列化的返回类型也是<strong>参数化类型</strong>(<strong>ParameterizedTypeReference</strong>)，看来<code>exchange()</code> 是<strong>支持多级泛型的dto，但只能带一个参数(List&lt;T&gt;)</strong></p>
<h1><span id="解决工具">解决工具</span></h1><p>ParameterizedTypeReference&lt;T&gt; 源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedTypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ParameterizedTypeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; parameterizedTypeReferenceSubclass = findParameterizedTypeReferenceSubclass(<span class="keyword">this</span>.getClass());</span><br><span class="line">        Type type = parameterizedTypeReferenceSubclass.getGenericSuperclass();</span><br><span class="line">        <span class="comment">//isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message)  如果 obj 不能被正确造型为 clazz 指定的类将抛出异常；</span></span><br><span class="line">        Assert.isInstanceOf(ParameterizedType.class, type, "Type must be a parameterized type");</span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType)type;</span><br><span class="line">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">//复杂dto(含有泛型) 只允许有一个参数，例：List&lt;T&gt;</span></span><br><span class="line">        Assert.isTrue(actualTypeArguments.length == <span class="number">1</span>, <span class="string">"Number of type arguments must be 1"</span>);</span><br><span class="line">        <span class="keyword">this</span>.type = actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ParameterizedTypeReference</span><span class="params">(Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(@Nullable Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == other || other <span class="keyword">instanceof</span> ParameterizedTypeReference &amp;&amp; <span class="keyword">this</span>.type.equals(((ParameterizedTypeReference)other).type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ParameterizedTypeReference&lt;"</span> + <span class="keyword">this</span>.type + <span class="string">"&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ParameterizedTypeReference&lt;T&gt; <span class="title">forType</span><span class="params">(Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeReference&lt;T&gt;(type) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找 ParameterizedTypeReference 类的子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; findParameterizedTypeReferenceSubclass(Class&lt;?&gt; child) &#123;</span><br><span class="line">        Class&lt;?&gt; parent = child.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span> </span>== parent) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Expected ParameterizedTypeReference superclass"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ParameterizedTypeReference<span class="class">.<span class="keyword">class</span> </span>== parent ? child : findParameterizedTypeReferenceSubclass(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ParameterizedType(参数化类型)是什么请参考：<a href="https://blog.csdn.net/JustBeauty/article/details/81116144" target="_blank" rel="noopener">ParameterizedType详解</a></p>
<h1><span id="实现">实现</span></h1><p>xxxDto</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxDto</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String statusCode;</span><br><span class="line">    <span class="keyword">private</span> String  statusMsg;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"000000"</span>.equals(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>restemplate 调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xxxDto&lt;xxxDto&gt; dto = networkProxy.request(NetworkProxy.Target.XXX, HttpMethod.POST, httpEntity,</span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;xxxDto&lt;xxxDto&gt;&gt;() &#123;</span><br><span class="line">                &#125;, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">request</span><span class="params">(Target target, HttpMethod httpMethod, HttpEntity httpEntity, ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> </span>&#123;</span><br><span class="line">        log.info(proxyAddress + target.getUrl());</span><br><span class="line">        <span class="keyword">return</span> restTemplate.exchange(proxyAddress + target.getUrl(), httpMethod, httpEntity, responseType, uriVariables).getBody();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Restemplate</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之泛型的学习</title>
    <url>/2020/05/15/Java%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">泛型详解</a></p>
<p><a href="https://segmentfault.com/a/1190000019606768" target="_blank" rel="noopener">Java泛型</a></p>
<blockquote>
<p>最近在项目中使用泛型去接收接口返回的数据，可是发现并没有反序列化成功，说明泛型失效了。</p>
</blockquote>
<a id="more"></a>

<h1><span id="概述">概述</span></h1><blockquote>
<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<h1><span id="栗子">栗子</span></h1><p>一个被举了无数次的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毫无疑问，程序的运行结果会以崩溃结束：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassCastException</span>: <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Integer</span> <span class="selector-tag">cannot</span> <span class="selector-tag">be</span> <span class="selector-tag">cast</span> <span class="selector-tag">to</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.String</span></span><br></pre></td></tr></table></figure>

<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错</span></span><br></pre></td></tr></table></figure>

<h1><span id="特性">特性</span></h1><p>泛型只在编译阶段有效。看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：D/泛型测试: 类型相同。</p>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。<br>总结：<strong>泛型类型在逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h1><span id="使用">使用</span></h1><p>泛型有三种使用方式，分别为：泛型类，泛型接口，泛型方法</p>
<h2><span id="泛型类">泛型类</span></h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul之学习</title>
    <url>/2020/05/14/Zuul%E4%B9%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="http://www.ityouknow.com/springcloud/2018/01/20/spring-cloud-zuul.html" target="_blank" rel="noopener">springcloud(十一)：服务网关Zuul高级篇</a></p>
<a id="more"></a>

<blockquote>
<p>在项目中用到了 Zuul 作为网关，有个全局的系统错误相关的处理类继承自 FallbackProvider。当某个服务无法调用时，错误异常就会被该类处理。</p>
</blockquote>
<h1><span id="zuul-的核心">Zuul 的核心</span></h1><p><strong>Filter 是 Zuul 的核心</strong>，用来实现对外服务的控制。Filter的生命周期有4个，分别是 “PRE”, “ROUTING”,”POST”,”ERROR” ，整个生命周期可以用下图表示:</p>
<p><img src="https://img-blog.csdnimg.cn/20200514131110750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="189"></p>
<p>Zuul 大部分功能都是通过过滤器来实现的，这些过滤器类型对应于请求的典型生命周期。</p>
<ul>
<li><strong>PRE：</strong> 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li>
<li><strong>ROUTING：</strong>这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。</li>
<li><strong>POST：</strong>这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li>
<li><strong>ERROR：</strong>在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。例如，我们可以定制一种STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务。</li>
</ul>
<h1><span id="zuul-中默认实现的-filter">Zuul 中默认实现的 Filter</span></h1><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">顺序</th>
<th align="left">过滤器</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pre</td>
<td align="left">-3</td>
<td align="left">ServletDetectionFilter</td>
<td align="left">标记处理Servlet的类型</td>
</tr>
<tr>
<td align="left">pre</td>
<td align="left">-2</td>
<td align="left">Servlet30WrapperFilter</td>
<td align="left">包装HttpServletRequest请求</td>
</tr>
<tr>
<td align="left">pre</td>
<td align="left">-1</td>
<td align="left">FormBodyWrapperFilter</td>
<td align="left">包装请求体</td>
</tr>
<tr>
<td align="left">route</td>
<td align="left">1</td>
<td align="left">DebugFilter</td>
<td align="left">标记调试标志</td>
</tr>
<tr>
<td align="left">route</td>
<td align="left">5</td>
<td align="left">PreDecorationFilter</td>
<td align="left">处理请求上下文供后续使用</td>
</tr>
<tr>
<td align="left">route</td>
<td align="left">10</td>
<td align="left">RibbonRoutingFilter</td>
<td align="left">serviceId请求转发</td>
</tr>
<tr>
<td align="left">route</td>
<td align="left">100</td>
<td align="left">SimpleHostRoutingFilter</td>
<td align="left">url请求转发</td>
</tr>
<tr>
<td align="left">route</td>
<td align="left">500</td>
<td align="left">SendForwardFilter</td>
<td align="left">forward请求转发</td>
</tr>
<tr>
<td align="left">post</td>
<td align="left">0</td>
<td align="left">SendErrorFilter</td>
<td align="left">处理有错误的请求响应</td>
</tr>
<tr>
<td align="left">post</td>
<td align="left">1000</td>
<td align="left">SendResponseFilter</td>
<td align="left">处理正常的请求响应</td>
</tr>
</tbody></table>
<h1><span id="路由熔断">路由熔断</span></h1><p>当我们的后端服务出现异常的时候，我们不希望将异常抛出给最外层，期望服务可以自动进行一降级。Zuul给我们提供了这样的支持。当某个服务出现异常时，直接返回我们预设的信息。</p>
<p>我们通过自定义的fallback方法，并且将其指定给某个route来实现该route访问出问题的熔断处理。主要继承ZuulFallbackProvider接口来实现，ZuulFallbackProvider默认有两个方法，一个用来指明熔断拦截哪个服务，一个定制返回内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZuulFallbackProvider</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The route this fallback will be used for.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The route the fallback will be used for.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Provides a fallback response.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The fallback response.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类通过实现getRoute方法，告诉Zuul它是负责哪个route定义的熔断。而fallbackResponse方法则是告诉 Zuul 断路出现时，它会提供一个什么返回值来处理请求。</p>
<p>后来Spring又扩展了此类，丰富了返回方式，在返回的内容中添加了异常信息，因此最新版本建议直接继承类<code>FallbackProvider</code> 。</p>
<p>我们以上面的spring-cloud-producer服务为例，定制它的熔断返回内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerFallback</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FallbackProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定要处理的 service。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"spring-cloud-producer"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"The service is unavailable."</span>.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span> &amp;&amp; cause.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String reason = cause.getCause().getMessage();</span><br><span class="line">            logger.info(<span class="string">"Excption &#123;&#125;"</span>,reason);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fallbackResponse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当服务出现异常时，打印相关异常信息，并返回”The service is unavailable.”。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hello neo，this is first messge</span><br><span class="line">The<span class="built_in"> service </span>is unavailable.</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure>

<p>根据返回结果可以看出：spring-cloud-producer-2项目已经启用了熔断，返回:<code>The service is unavailable.</code></p>
<blockquote>
<p>Zuul 目前只支持服务级别的熔断，不支持具体到某个URL进行熔断。</p>
</blockquote>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Zuul</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据之Flume学习</title>
    <url>/2020/05/10/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8BFlume%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="http://flume.apache.org/" target="_blank" rel="noopener">Flume官网</a></p>
<blockquote>
<p>AI + BigData + 云计算</p>
</blockquote>
<a id="more"></a>

<h1><span id="定义">定义</span></h1><p>Flume 是 Cloudera 提供的一个高可用，高可靠，分布式的海量日志采集，聚合和传输的系统。Flume 基于流式架构，灵活简单。</p>
<p><img src="https://img-blog.csdnimg.cn/2020051021333661.png#pic_center" alt="186"></p>
<h1><span id="组件">组件</span></h1><h2><span id="1agent">1.Agent</span></h2><p>Agent 是一个 JVM 进程，它以<u><strong>事件</strong></u>的形式将数据从源头送至目的</p>
<p>Agent 主要有 3 个部分组成：<strong>Source</strong>，<strong>Channel</strong>，<strong>Sink</strong></p>
<h2><span id="2source">2.Source</span></h2><p>Source 是负责接收数据到 Flume Agent 的组件。Source 组件可以处理各种类型，各种格式的日志数据，包括：avro，thrift，exec，jms，spooling directory，netcat，sequence generator，syslog，http，legacy</p>
<h2><span id="3sink">3.Sink</span></h2><p>Sink 不断轮询 Channel 中的事件且批量移除它们，并将这些事件写入到存储或索引系统，或者发送到另一个 Flume Agent</p>
<p>Sink 组件目的地包括 hdfs，logger，avro，thrift，ipc，file，HBase，solr</p>
<h2><span id="4channel">4.Channel</span></h2><p>Channel 是位于 Source 和 Sink 之间的缓冲区。因此，Channel 允许 Source 和 Sink 运作在不同的速率上。Channel 是线程安全的，可以同时处理几个 Source 的写入操作和几个 Sink 的读取操作。</p>
<p>Flume 自带两种 Channel ：Memory Channel 和 File Channel 以及 Kafka Channel</p>
<p>Memory Channel 是内存中的队列。Memory Channel 在不需要关心数据丢失的情景下适用。如果需要关注数据丢失，那么 Memory Channel 就不应该使用，因为程序死亡，机器宕机都会导致数据丢失。</p>
<p>File Channel 将所有事件写到磁盘，因此程序关闭或者宕机情况下都不会丢失数据。</p>
<h2><span id="5event">5.Event</span></h2><p>传输单元 Flume 数据传输的基本单元，以 Event 的形式将数据从源头送至目的地。Event 由 Header 和 body 两部分组成，Header 用来存放该 Event的一些属性，以 K-V 结构，Body 用来存放该条数据，形式以字节数组。</p>
<h1><span id="案例">案例</span></h1><h2><span id="1">1.</span></h2><p><a href="https://github.com/01Lv/BigData-Notes/blob/master/notes/Flume%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.md#61-%E6%A1%88%E4%BE%8B%E4%B8%80" target="_blank" rel="noopener">案例一</a></p>
<p>需求： 监听文件内容变动，将新增加的内容输出到控制台。</p>
<p>实现： 主要使用 <code>Exec Source</code> 配合 <code>tail</code> 命令实现。</p>
<ul>
<li>配置</li>
</ul>
<p>新建配置文件 <code>exec-memory-logger.properties</code>,其内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定agent的sources,sinks,channels</span></span><br><span class="line"><span class="meta">a1.sources</span> = <span class="string">s1  </span></span><br><span class="line"><span class="meta">a1.sinks</span> = <span class="string">k1  </span></span><br><span class="line"><span class="meta">a1.channels</span> = <span class="string">c1  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#配置sources属性</span></span><br><span class="line"><span class="meta">a1.sources.s1.type</span> = <span class="string">exec</span></span><br><span class="line"><span class="meta">a1.sources.s1.command</span> = <span class="string">tail -F /tmp/log.txt</span></span><br><span class="line"><span class="meta">a1.sources.s1.shell</span> = <span class="string">/bin/bash -c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将sources与channels进行绑定</span></span><br><span class="line"><span class="meta">a1.sources.s1.channels</span> = <span class="string">c1</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#配置sink </span></span><br><span class="line"><span class="meta">a1.sinks.k1.type</span> = <span class="string">logger</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将sinks与channels进行绑定  </span></span><br><span class="line"><span class="meta">a1.sinks.k1.channel</span> = <span class="string">c1  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#配置channel类型</span></span><br><span class="line"><span class="meta">a1.channels.c1.type</span> = <span class="string">memory</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动</li>
</ul>
<p>没太理解原文章的 <code>--conf conf</code> 是啥意思，所以启动的时候会<strong>报错如下</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">log4j:</span>WARN No appenders could be found <span class="keyword">for</span> logger (org.apache.flume.lifecycle.LifecycleSupervisor).</span><br><span class="line"><span class="string">log4j:</span>WARN Please initialize the log4j system properly.</span><br><span class="line"><span class="string">log4j:</span>WARN See <span class="string">http:</span><span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span><br></pre></td></tr></table></figure>

<p>后来知道原来 <code>conf</code> 应该是 flume 的解压后<strong>主目录</strong>下的 <code>conf</code> (<a href="https://blog.csdn.net/u012373815/article/details/54024940" target="_blank" rel="noopener">解决</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent -c /home/flume/apache-flume-1.9.0-bin/conf -f /home/flume/examples/exec-memory-logger.properties --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>

<p>成功启动如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200510213353198.png#pic_center" alt="187"></p>
<p><img src="https://img-blog.csdnimg.cn/20200510213410273.png#pic_center" alt="188"></p>
<h2><span id="2">2.</span></h2>]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017" target="_blank" rel="noopener">代理模式</a></p>
<blockquote>
<p>为其它对象提供一种代理以控制对这个对象的访问,一个类代表另一个类的功能。这种类型的设计模式属于结构性模式</p>
</blockquote>
<a id="more"></a>

<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口</p>
<p>代理模式，即Proxy，它和Adapter模式很类似，先回顾Adapter模式，它用于把A接口转换为B接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BAdapter implements B &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BAdapter</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 Proxy 模式不是把A接口转换成B接口，他还是转换成A接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AProxy implements A &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AProxy</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="主要解决">主要解决</span></h1><p>直接访问会给使用者或者系统结构带来很多麻烦，可以在访问此对象时加上一个对此对象的访问层</p>
<h1><span id="应用">应用</span></h1><h2><span id="远程代理">远程代理</span></h2><p>远程代理即 Remote Proxy，本地的调用者持有的接口实际是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>
<h2><span id="虚代理">虚代理</span></h2><p>虚代理即 Virtual Proxy, 它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的 JDBC 连接(Connection 对象) 就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行 JDBC 查询或更新操作时，才真正创建实际的 JDBC 连接。</p>
<h2><span id="保护代理">保护代理</span></h2><p>保护代理即 Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>
<h2><span id="智能引用">智能引用</span></h2><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>
<p>我们来看一下如何应用代理模式编写一个JDBC连接池（<code>DataSource</code>）。我们首先来编写一个虚代理，即如果调用者获取到<code>Connection</code>后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource lazyDataSource = <span class="keyword">new</span> LazyDataSource(jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line">System.out.println(<span class="string">"get lazy connection..."</span>);</span><br><span class="line"><span class="keyword">try</span> (Connection conn1 = lazyDataSource.getConnection()) &#123;</span><br><span class="line">    <span class="comment">// 并没有实际打开真正的Connection</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"get lazy connection..."</span>);</span><br><span class="line"><span class="keyword">try</span> (Connection conn2 = lazyDataSource.getConnection()) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn2.prepareStatement(<span class="string">"SELECT * FROM students"</span>)) &#123; <span class="comment">// 打开了真正的Connection</span></span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来思考如何实现这个<code>LazyConnectionProxy</code>。为了简化代码，我们首先针对<code>Connection</code>接口做一个抽象的代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConnectionProxy</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法获取实际的Connection:</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getRealConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现Connection接口的每一个方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRealConnection().createStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRealConnection().prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...其他代理方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>AbstractConnectionProxy</code>代理类的作用是把<code>Connection</code>接口定义的方法全部实现一遍，因为<code>Connection</code>接口定义的方法太多了，后面我们要编写的<code>LazyConnectionProxy</code>只需要继承<code>AbstractConnectionProxy</code>，就不必再把<code>Connection</code>接口方法挨个实现一遍。</p>
<p><code>LazyConnectionProxy</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyConnectionProxy</span> <span class="keyword">extends</span> <span class="title">AbstractConnectionProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;Connection&gt; supplier;</span><br><span class="line">    <span class="keyword">private</span> Connection target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyConnectionProxy</span><span class="params">(Supplier&lt;Connection&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写close方法：只有target不为null时才需要关闭:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Close connection: "</span> + target);</span><br><span class="line">            <span class="keyword">super</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Connection <span class="title">getRealConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用者没有执行任何SQL语句，那么<code>target</code>字段始终为<code>null</code>。只有第一次执行SQL语句时（即调用任何类似<code>prepareStatement()</code>方法时，触发<code>getRealConnection()</code>调用），才会真正打开实际的JDBC Connection。</p>
<p>最后，我们还需要编写一个<code>LazyDataSource</code>来支持这个<code>LazyConnecitonProxy</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyDataSource</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyConnectionProxy(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">                System.out.println(<span class="string">"Open connection: "</span> + conn);</span><br><span class="line">                <span class="keyword">return</span> conn;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource pooledDataSource = <span class="keyword">new</span> PooledDataSource(jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line"><span class="keyword">try</span> (Connection conn = pooledDataSource.getConnection()) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (Connection conn = pooledDataSource.getConnection()) &#123;</span><br><span class="line">    <span class="comment">// 获取到的是同一个Connection</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (Connection conn = pooledDataSource.getConnection()) &#123;</span><br><span class="line">    <span class="comment">// 获取到的是同一个Connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方并不关心是否复用了<code>Connection</code>，但从<code>PooledDataSource</code>获取的<code>Connection</code>确实自带这个优化功能。如何实现可复用<code>Connection</code>的连接池？答案仍然是使用代理模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledConnectionProxy</span> <span class="keyword">extends</span> <span class="title">AbstractConnectionProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际的Connection:</span></span><br><span class="line">    Connection target;</span><br><span class="line">    <span class="comment">// 空闲队列:</span></span><br><span class="line">    Queue&lt;PooledConnectionProxy&gt; idleQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledConnectionProxy</span><span class="params">(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.idleQueue = idleQueue;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fake close and released to idle queue for future reuse: "</span> + target);</span><br><span class="line">        <span class="comment">// 并没有调用实际Connection的close()方法,</span></span><br><span class="line">        <span class="comment">// 而是把自己放入空闲队列:</span></span><br><span class="line">        idleQueue.offer(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Connection <span class="title">getRealConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复用连接的关键在于覆写<code>close()</code>方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。</p>
<p>空闲队列由<code>PooledDataSource</code>负责维护：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个空闲队列:</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PooledConnectionProxy&gt; idleQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 首先试图获取一个空闲连接:</span></span><br><span class="line">        PooledConnectionProxy conn = idleQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有空闲连接时，打开一个新连接:</span></span><br><span class="line">            conn = openNewConnection();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Return pooled connection: "</span> + conn.target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PooledConnectionProxy <span class="title">openNewConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.println(<span class="string">"Open new connection: "</span> + conn);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PooledConnectionProxy(idleQueue, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行调用方代码，输出如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Open new connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close <span class="keyword">and</span> released <span class="keyword">to</span> idle<span class="built_in"> queue </span><span class="keyword">for</span> future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close <span class="keyword">and</span> released <span class="keyword">to</span> idle<span class="built_in"> queue </span><span class="keyword">for</span> future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br><span class="line">Fake close <span class="keyword">and</span> released <span class="keyword">to</span> idle<span class="built_in"> queue </span><span class="keyword">for</span> future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa</span><br></pre></td></tr></table></figure>

<p>除了第一次打开了一个真正的JDBC Connection，后续获取的<code>Connection</code>实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。</p>
<p>未完待续。。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper之学习</title>
    <url>/2020/05/04/Zookeeper%E4%B9%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://juejin.im/post/5b037d5c518825426e024473" target="_blank" rel="noopener">漫画：什么是ZooKeeper？</a></p>
<p><a href="https://juejin.im/post/5b970f1c5188255c865e00e7" target="_blank" rel="noopener">可能是把 ZooKeeper 概念讲的最清楚的一篇文章</a></p>
<blockquote>
<p><strong>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p>
</blockquote>
<a id="more"></a>

<h1><span id="重要概念">重要概念</span></h1><ul>
<li>zookeeper 本身就是一个分布式程序(只要半数以上节点存活，zookeeper 就能正常服务)</li>
<li>为了保证高可用，最好是以集群形态来部署 zookeeper，<strong>这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</strong></li>
<li>zookeeper 将数据保存在内存中，这也就保证了高吞吐量和低延迟(但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因)</li>
<li><strong>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。</strong>（“读”多于“写”是协调服务的典型场景。）</li>
<li>ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</li>
<li>ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。</li>
</ul>
<h1><span id="示例">示例</span></h1><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户端程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式配置中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperProSync</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//zookeeper 配置数据存放路径</span></span><br><span class="line">        String path = <span class="string">"/username"</span>;</span><br><span class="line">        <span class="comment">//连接zookeeper并且注册一个默认的监听器</span></span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.133.100:2181"</span>, <span class="number">5000</span>, <span class="keyword">new</span> ZooKeeperProSync());</span><br><span class="line">        <span class="comment">//等待zk连接成功的通知</span></span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">        <span class="comment">//获取path目录节点的配置数据，并注册默认的监听器</span></span><br><span class="line">        System.out.println(<span class="string">"获取path目录节点的配置数据:\n"</span> + <span class="keyword">new</span> String(zk.getData(path,<span class="keyword">true</span>,stat)));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Event.KeeperState.SyncConnected == event.getState())&#123;</span><br><span class="line">            <span class="comment">//zk连接成功通知事件</span></span><br><span class="line">            <span class="keyword">if</span>(Event.EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath())&#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType() == Event.EventType.NodeDataChanged)&#123;</span><br><span class="line">                <span class="comment">//zk目录节点数据变化通知事件</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"配置以修改，新值为："</span> + <span class="keyword">new</span> String(zk.getData(event.getPath(),<span class="keyword">true</span>,stat)));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序启动后都正确的读取到了zookeeper的/username目录节点下的数据</p>
<p><img src="https://img-blog.csdnimg.cn/20200504225511129.png#pic_center" alt="184"></p>
<p>在zookeeper里修改下目录节点/username下的数据</p>
<p><img src="https://img-blog.csdnimg.cn/20200504225526300.png#pic_center" alt="185"></p>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配器模式</title>
    <url>/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319245971489" target="_blank" rel="noopener">廖雪峰—适配器模式</a></p>
<p><a href="https://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">菜鸟教程-适配器模式</a></p>
<blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>
</blockquote>
<a id="more"></a>

<h1><span id="示例">示例</span></h1><p>在程序设计中，适配器也是类似的。我们已经有一个<code>Task</code>类，实现了<code>Callable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> n = <span class="number">1</span>; n &lt;= <span class="keyword">this</span>.num; n++) &#123;</span><br><span class="line">            r = r + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Result: "</span> + r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们想通过一个线程去执行它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Long&gt; callable = <span class="keyword">new</span> Task(<span class="number">123450000L</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(callable); <span class="comment">// compile error!</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>发现编译不过！因为<code>Thread</code>接收<code>Runnable</code>接口，但不接收<code>Callable</code>接口，肿么办？</p>
<p>一个办法是改写<code>Task</code>类，把实现的<code>Callable</code>改为<code>Runnable</code>，但这样做不好，因为<code>Task</code>很可能在其他地方作为<code>Callable</code>被引用，改写<code>Task</code>的接口，会导致其他正常工作的代码无法编译。</p>
<p>另一个办法不用改写<code>Task</code>类，而是用一个Adapter，把这个<code>Callable</code>接口“变成”<code>Runnable</code>接口，这样，就可以正常编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Long&gt; callable = <span class="keyword">new</span> Task(<span class="number">123450000L</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableAdapter(callable));</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>这个<code>RunnableAdapter</code>类就是Adapter，它接收一个<code>Callable</code>，输出一个<code>Runnable</code>。怎么实现这个<code>RunnableAdapter</code>呢？我们先看完整的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用待转换接口:</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;?&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableAdapter</span><span class="params">(Callable&lt;?&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现指定接口:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将指定接口调用委托给转换接口调用:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callable.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个Adapter的步骤如下：</p>
<ol>
<li>实现目标接口，这里是<code>Runnable</code>；</li>
<li>内部持有一个待转换接口的引用，这里是通过字段持有<code>Callable</code>接口；</li>
<li>在目标接口的实现方法内部，调用待转换接口的方法。</li>
</ol>
<p>这样一来，Thread就可以接收这个<code>RunnableAdapter</code>，因为它实现了<code>Runnable</code>接口。<code>Thread</code>作为调用方，它会调用<code>RunnableAdapter</code>的<code>run()</code>方法，在这个<code>run()</code>方法内部，又调用了<code>Callable</code>的<code>call()</code>方法，相当于<code>Thread</code>通过一层转换，间接调用了<code>Callable</code>的<code>call()</code>方法。</p>
<p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是<code>String[]</code>，但是需要<code>List</code>接口时，可以用一个Adapter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] exist = <span class="keyword">new</span> String[] &#123;<span class="string">"Good"</span>, <span class="string">"morning"</span>, <span class="string">"Bob"</span>, <span class="string">"and"</span>, <span class="string">"Alice"</span>&#125;;</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(exist));</span><br></pre></td></tr></table></figure>

<p>注意到<code>List Arrays.asList(T[])</code>就相当于一个转换器，它可以把数组转换为<code>List</code>。</p>
<p>我们再看一个例子：假设我们持有一个<code>InputStream</code>，希望调用<code>readText(Reader)</code>方法，但它的参数类型是<code>Reader</code>而不是<code>InputStream</code>，怎么办？</p>
<p>当然是使用适配器，把<code>InputStream</code>“变成”<code>Reader</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Files.newInputStream(Paths.get(<span class="string">"/path/to/file"</span>));</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">"UTF-8"</span>);</span><br><span class="line">readText(reader);</span><br></pre></td></tr></table></figure>

<p><code>InputStreamReader</code>就是Java标准库提供的<code>Adapter</code>，它负责把一个<code>InputStream</code>适配为<code>Reader</code>。类似的还有<code>OutputStreamWriter</code>。</p>
<p>如果我们把<code>readText(Reader)</code>方法参数从<code>Reader</code>改为<code>FileReader</code>，会有什么问题？这个时候，因为我们需要一个<code>FileReader</code>类型，就必须把<code>InputStream</code>适配为<code>FileReader</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">"UTF-8"</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>直接使用<code>InputStreamReader</code>这个Adapter是不行的，因为它只能转换出<code>Reader</code>接口。事实上，要把<code>InputStream</code>转换为<code>FileReader</code>也不是不可能，但需要花费十倍以上的功夫。这时，面向抽象编程这一原则就体现出了威力：持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类类型，要想做一些改动就非常困难。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之统一异常的处理</title>
    <url>/2020/05/02/SpringBoot%E4%B9%8B%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><a href="http://www.zhaojun.im/springboot-exception/" target="_blank" rel="noopener">Spring MVC/Boot 统一异常处理最佳实践</a></p>
<p><a href="https://blog.csdn.net/qq_36892341/article/details/89953748" target="_blank" rel="noopener">java统一异常处理</a></p>
<blockquote>
<p>之前在项目开发的时候，因为在编码过程中遇到了需要处理的大量重复的错误，于是我便请教下大佬，大佬跟我说将它们统一抛给全局异常处理类来处理，当时并没有意识到这是一个很重要的学习点，后面看了微信公众号的文章才发现原理异常可以这样统一处理!</p>
</blockquote>
<a id="more"></a>

<p>如果后台在运行中出现了异常，直接把异常从业务代码中抛出的话，相当于直接给前端抛出了一个500的错误，<strong>这种错误被用户看到非常的不好</strong>。例如</p>
<p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C183.png" alt="183"></p>
<p>在 web 开发中，经常需要处理各种异常，这是一件棘手的事情， 对于很多人来说, 可能对异常处理有以下几个问题:</p>
<ul>
<li>什么时候需要捕获(<code>try-catch</code>)异常, 什么时候需要抛出(<code>throws</code>)异常到上层.</li>
<li>在 <code>dao</code> 层捕获还是在 <code>service</code> 捕获, 还是在 <code>controller</code> 层捕获.</li>
<li>抛出异常后要怎么处理. 怎么返回给页面错误信息.</li>
</ul>
<h1><span id="异常处理的反例">异常处理的反例</span></h1><p>既然谈到异常, 我们先来说一下异常处理的反例, 也是很多人容易犯的错误, 这里我们同时讲到前端处理和后端处理 :</p>
<p><strong>捕获异常后只输出到控制台</strong></p>
<p>前端代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">"GET"</span>,</span><br><span class="line">    url: <span class="string">"/user/add"</span>,</span><br><span class="line">    dataType: <span class="string">"json"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"添加成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>后端代码</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是见过最多的异常处理方式了, 如果这是一个添加商品的方法, 前台通过 ajax 发送请求到后端, 期望返回 json 信息表示添加结果. 但如果这段代码出现了异常:</p>
<p>那么用户看到的场景就是点击了添加按钮, 但没有任何反应(其实是返回了 500 错误页面, 但这里前端没有监听 error 事件, 只监听了 success 事件. 但即使加上了error: function(data) {alert(“添加失败”);}) 又如何呢? 到底因为啥失败了呢, 用户也不得而知.<br>后台 e.printStackTrace() 打印在控制台的日志也会在漫漫的日志中被埋没, 很可能会看不到输出的异常. 但这并不是最糟的情况, 更糟糕的事情是连 e.printStackTrace() 都没有, catch 块中是空的, 这样后端的控制台中更是什么都看不到了, 这段代码会像一个隐形的炸弹一样一直埋伏在系统中.</p>
</blockquote>
<h3><span id="混乱的返回方式">混乱的返回方式</span></h3><p>前端代码</p>
<p>复制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">"GET"</span>,</span><br><span class="line">    url: <span class="string">"/goods/add"</span>,</span><br><span class="line">    dataType: <span class="string">"json"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.flag) &#123;</span><br><span class="line">            alert(<span class="string">"添加成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(data.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"添加失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>后端代码</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/goods/add"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">add</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        map.put(flag, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        map.put(<span class="string">"flag"</span>, <span class="keyword">false</span>);</span><br><span class="line">        map.put(<span class="string">"message"</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    reutrn map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这种方式捕获异常后, 返回了错误信息, 且前台做了一定的处理, 看起来很完善? 但用 <code>HashMap</code> 中的 <code>flag</code> 和 <code>message</code> 这种字符串来当键很容易处理, 例如你这里叫 <code>message</code>, 别人起名叫 <code>msg</code>, 甚至有时手抖打错了, 怎么办? 前台再改成 <code>msg</code> 或其他的字符?, 前端后端这样一直来回改?<br>更有甚者在情况 A 的情况下, 返回 json, 在情况 B 的情况下, 重定向到某个页面, 这就更乱了. 对于这种不统一的结构处理起来非常麻烦.</p>
</blockquote>
<h1><span id="异常处理规范">异常处理规范</span></h1><p>既然要进行<strong>统一</strong>异常处理, 那么肯定要有一个规范, 不能乱来. 这个规范包含前端和后端.</p>
<p><strong>不要捕获任何异常</strong></p>
<p>不要在业务代码中进行捕获异常，即 dao，service，controller 层的所有异常都全部抛出到上层. 这样不会导致业务代码中的一堆 <code>try-catch</code> 会混乱业务代码.</p>
<p><strong>统一返回结果集</strong></p>
<p>不要使用 Map 来返回结果, Map 不易控制且容易犯错, 应该定义一个 Java 实体类. 来表示统一结果来返回, 如定义实体类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiResult</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ApiResultDefine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiResult</span><span class="params">(Integer code, String message, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiResult</span><span class="params">(Integer code, String message, T data, Integer count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(ApiResultEnum.SUCCESS.getCode(), ApiResultEnum.SUCCESS.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">(Object data, Integer count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(ApiResultEnum.SUCCESS.getCode(), ApiResultEnum.SUCCESS.getMessage(), data, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">(String message, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(ApiResultEnum.SUCCESS.getCode(), message, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">success</span><span class="params">(String message, Object data, Integer count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(ApiResultEnum.SUCCESS.getCode(), message, data, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">error</span><span class="params">(ApiResultDefine define)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(define.getCode(), define.getMessage(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">error</span><span class="params">(Integer code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(code, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">error</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(ApiResultEnum.UNKNOWN_ERROR.getCode(), message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.code.equals(ApiResultEnum.SUCCESS.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般只有<strong>查询</strong>方法需要调用 <code>ApiResult.success(Object data)</code> 来返回 N 条数据其它诸如 <strong>删除</strong>，<strong>修改</strong> 等方法都应该调用 ``ApiResult.success()` ，即在业务代码中只处理正确的功能，不对异常做任何判断。也不需要对 update 或 delete 的更新条数做判断(个人建议, 实际需要根据业务). 只要没有抛出异常, 我们就认为用户操作成功了. 且操作成功的提示信息在前端处理, 不要后台返回 “操作成功” 等字段.</p>
<p>前台接受到的信息为:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"商品1"</span>,</span><br><span class="line">            <span class="attr">"price"</span>: <span class="number">50.00</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"商品2"</span>,</span><br><span class="line">            <span class="attr">"price"</span>: <span class="number">99.99</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抛出异常</strong>: 抛出异常后, 我们应该调用 <code>ResultBean.error(int code, String message)</code>, 来将状态码和错误信息返回, 我们约定 <code>code</code> 为 0 表示操作成功, <code>1</code> 或 <code>2</code> 等正数表示用户输入错误, <code>-1</code>, <code>-2</code> 等负数表示系统错误.</p>
<p>前台接受到的信息为:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"XXX 参数有问题, 请重新填写"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端统一处理：</p>
<p>返回的结果集规范后，前端就很好处理了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>result： 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    alert(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理 ajax 请求结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>result： ajax 返回的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn： 成功的处理函数 ( 传入data: fn(result.data) )</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerResult</span>(<span class="params">result, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 成功执行操作，失败提示原因</span></span><br><span class="line">    <span class="keyword">if</span> (result.code == <span class="number">0</span>) &#123;</span><br><span class="line">        fn(result.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户操作异常, 这里可以对 1 或 2 等错误码进行单独处理, 也可以 result.code &gt; 0 来粗粒度的处理, 根据业务而定.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result.code == <span class="number">1</span>) &#123;</span><br><span class="line">        showError(result.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 系统异常, 这里可以对 -1 或 -2 等错误码进行单独处理, 也可以 result.code &gt; 0 来粗粒度的处理, 根据业务而定.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result.code == <span class="number">-1</span>) &#123;</span><br><span class="line">        showError(result.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果进行细粒度的状态码判断, 那么就应该重点注意这里没出现过的状态码. 这个判断仅建议在开发阶段保留用来发现未定义的状态码.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        showError(<span class="string">"出现未定义的状态码:"</span> + result.code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 id 删除商品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteGoods</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"GET"</span>,</span><br><span class="line">        url: <span class="string">"/goods/delete"</span>,</span><br><span class="line">        dataType: <span class="string">"json"</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">            handlerResult(result, deleteDone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDone</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>showError</code> 和 <code>handlerResult</code> 是公共方法, 分别用来显示错误和统一处理结果集.</p>
<p>然后将主要精力放在发送请求和处理正确结果的方法上即可, 如这里的 deleteDone 函数, 用来处理操作成功给用户的提示信息, 正所谓各司其职, 前端负责操作成功的消息提示更合理, 而错误信息只有后台知道, 所以需要后台来返回.</p>
<p><strong>后端统一处理异常</strong></p>
<p>既然所有业务层都没有捕获异常，那么所有的异常都会抛出到 Controller 层，只需要用 AOP 对 Controller 层的所有方法处理即可。</p>
<p>好在 Spring 为我们提供了一个注解，用来统一处理异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理未捕捉的业务异常、运行时异常、其他未知异常</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理业务异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BusinessException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span> <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">BusinessException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(<span class="string">"BusinessException:"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.error(e.getErrorCode(), e.getErrorMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理数据格式异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(HttpMessageNotReadableException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span> <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">HttpMessageNotReadableException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(<span class="string">"数据格式错误HttpMessageNotReadableException:"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.error(ApiResultEnum.REQUEST_DATA_ERROR.getCode(), ApiResultEnum.REQUEST_DATA_ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理参数缺失异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MissingServletRequestParameterException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span> <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">MissingServletRequestParameterException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(<span class="string">"参数缺失异常 MissingServletRequestParameterException:"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.error(ApiResultEnum.REQUEST_PARAM_NULL_ERROR.getCode(), ApiResultEnum.REQUEST_PARAM_NULL_ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数校验异常-对象field校验</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span> <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">MethodArgumentNotValidException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(<span class="string">"MethodArgumentNotValidException:"</span>, e);</span><br><span class="line">        List&lt;String&gt; errorsOutput = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;FieldError&gt; errors = e.getBindingResult().getFieldErrors();</span><br><span class="line">        <span class="keyword">for</span> (FieldError error : errors) &#123;</span><br><span class="line">            errorsOutput.add(error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ApiResult.error(ApiResultEnum.VALIDATE_FAIL.getCode(), StringUtils.collectionToDelimitedString(errorsOutput, <span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数校验异常-直接基本类型校验</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ConstraintViolationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span> <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ConstraintViolationException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(<span class="string">"ConstraintViolationException:"</span>, e);</span><br><span class="line">        List&lt;String&gt; errorsOutput = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = e.getConstraintViolations();</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;?&gt; constraintViolation : constraintViolations) &#123;</span><br><span class="line">            errorsOutput.add(constraintViolation.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ApiResult.error(ApiResultEnum.VALIDATE_FAIL.getCode(), StringUtils.collectionToDelimitedString(errorsOutput, <span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未知异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResult</span> <span class="title">handleException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(<span class="string">"Exception:"</span>, e);</span><br><span class="line">        <span class="comment">//邮件通知技术人员</span></span><br><span class="line">        <span class="keyword">return</span> ApiResult.error(ApiResultEnum.UNKNOWN_ERROR.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里统一配置需要处理的异常, 同样, 对于未知的异常, 一定要及时发现, 并进行处理. 推荐出现未知异常后发送邮件, 提示技术人员.</p>
<p>todo: @ControllerAdvice源码研究</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Curl请求和Sed查找获取指定文本</title>
    <url>/2020/04/29/Curl%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">curl 的用法指南</a></p>
<p><a href="https://blog.csdn.net/kakabuqinuo/article/details/99845797" target="_blank" rel="noopener">Shell使用grep和sed命令提取json数据中指定字段的值</a></p>
<blockquote>
<p>今天需要做两个定时任务，通过jenkins 定时去调用某个服务的几个接口。在获取token的接口中，返回的结果并不是所需要的那种格式，需要通过文本处理将token解析出来再带上此token 去访问另外一个接口。</p>
</blockquote>
<a id="more"></a>

<h1><span id="curl-请求get">Curl 请求(GET)</span></h1><p>以 GET 方式请求数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -G -d 'url=xxx' http://xxx/xxx</span><br></pre></td></tr></table></figure>

<p><code>-d</code> : 参数用于发送 POST 请求的数据体,使用该参数后，HTTP请求会自动加上标头 <code>Content-Type:application/x-www-form-urlencoded</code>. 并且会自动将请求转为 POST 方法。</p>
<p>通过 GET 的方式获取到返回的token</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"message"</span>:<span class="string">"OK"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"token"</span>:<span class="string">"xxx.xxx.xxx"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提取指定文本最终的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat result.json | sed 's/,/\n/g' | grep "token" | sed 's/:/\n/g' | sed '1d' | sed 's/&#125;//g' | sed '1d'| sed 's/"//g'</span><br></pre></td></tr></table></figure>

<h1><span id="sed-grep-解析文本获取token">Sed + grep 解析文本获取token</span></h1><h2><span id="第一个sed是将-换成-n">第一个sed是将 <code>,</code> 换成 <code>\n</code></span></h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>:<span class="number">0</span></span><br><span class="line">    <span class="string">"message"</span>:<span class="string">"OK"</span></span><br><span class="line">    <span class="string">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"token"</span>:<span class="string">"xxx.xxx.xxx"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="第二个grep-是将-token-关键字找出来并单独列出来">第二个grep 是将 <code>token</code> 关键字找出来，并单独列出来</span></h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"data"</span>:&#123;<span class="string">"token"</span>:<span class="string">"xxx.xxx.xxx"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="第三个-sed是将-换成-n">第三个 sed是将 <code>:</code> 换成 <code>\n</code></span></h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="string">"data"</span></span><br><span class="line">&#123;<span class="attr">"token"</span></span><br><span class="line">"xxx.xxx.xxx"&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="第四个sed-是删除第一行">第四个sed 是删除第一行</span></h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"token"</span></span><br><span class="line"><span class="string">"xxx.xxx.xxx"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="第五个sed是将-替换为空字符">第五个sed是将 <code>}</code> 替换为空字符</span></h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"token"</span></span><br><span class="line"><span class="string">"xxx.xxx.xxx"</span></span><br></pre></td></tr></table></figure>

<h2><span id="第六个sed是删除第一行">第六个sed是删除第一行</span></h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">"<span class="selector-tag">xxx</span><span class="selector-class">.xxx</span><span class="selector-class">.xxx</span>"</span><br></pre></td></tr></table></figure>

<h2><span id="第五个sed是将-quot-用空字符替换掉最后的g的参数表示替换所有符合的引号">第五个sed是将 <code>&quot;</code> 用空字符替换掉,最后的g的参数表示替换所有符合的引号</span></h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">xxx</span><span class="selector-class">.xxx</span><span class="selector-class">.xxx</span></span><br></pre></td></tr></table></figure>

<p>将token保存下来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">token=(cat result.json | sed 's/,/\n/g' | grep "token" | sed 's/:/\n/g' | sed '1d' | sed 's/&#125;//g' | sed '1d'| sed 's/"//g')</span><br></pre></td></tr></table></figure>

<h1><span id="curl-请求post">Curl 请求(POST)</span></h1><p>带上刚解析出来的token去访问另外一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RestApiResult <span class="title">saveXxx</span><span class="params">(@RequestParam String accessToken,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               @RequestParam String storeId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               @RequestParam String type)</span></span></span><br></pre></td></tr></table></figure>

<p>再通过curl的 <strong>post请求</strong> 就可以访问该接口了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d 'storeId=xxx&amp;accessToken='$token'&amp;type=xxx' http://xxx/xxx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Curl</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos数据持久化</title>
    <url>/2020/04/27/Nacos%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>最近小组大佬给我分配任务，要我搭建正式环境。并且特别声明了 Nacos 的配置数据要持久化，所以趁此机会又可以学习到新东西哈哈。</p>
</blockquote>
<p><a href="https://www.cnblogs.com/larscheng/p/11422909.html" target="_blank" rel="noopener">Nacos（八）：Nacos持久化</a></p>
<p><a href="http://blog.didispace.com/spring-cloud-alibaba-4/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos的数据持久化</a></p>
<a id="more"></a>

<p>我搭建的环境是 Centos 系统。</p>
<p>目前来说，Nacos 只支持 MySQL 的作为持久化的数据库。</p>
<ol>
<li><p>下载一个 MySQL5.x 的数据库</p>
</li>
<li><p>下载 nacos_xxx.tar.gz，<strong>进入到 conf 目录下</strong>，找到 <code>nacos-mysql.sql</code> 。执行完以后可以得到如下图所示的表结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200427234318924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="182"></p>
</li>
<li><p>修改<code>conf/application.properties</code>文件，增加支持MySQL数据源配置，添加（目前只支持mysql）数据源的url、用户名和密码。配置样例如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://localhost:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转到 <code>bin</code> 目录下，执行 <code>sh startup.sh -m standalone</code> 。我是以单机模式启动。这里可能会报 <code>jdk路径相关的错误</code> ，简单粗暴的解决办法就是通过 <code>root(#)</code> 用户去执行该命令。。</p>
</li>
<li><p>最后你在 nacos 的配置中加入所需的配置文件就会发现数据库中有数据了！</p>
</li>
</ol>
<p>其实挺简单的哈哈。。。</p>
]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
        <tag>Nacos配置数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos之学习</title>
    <url>/2020/04/27/Nacos%E4%B9%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>最近在项目中有用到nacos作为配置中心，感觉还挺好用的。于是潜下心来学习下！</p>
</blockquote>
<p><a href="https://www.larscheng.com/nacos-namespace/" target="_blank" rel="noopener">Nacos（六）：多环境下如何“管理”及“隔离”配置和服务</a></p>
<a id="more"></a>

<p>背景：</p>
<blockquote>
<p>现如今，在微服务体系中，一个系统往往被拆分为多个服务，每个服务都有自己的配置文件，然后每个系统往往还会准备开发环境、测试环境、正式环境</p>
<p>我们来说算一算，假设某系统有10个微服务，那么至少有10个配置文件吧，三个环境（dev\test\prod），那就有30个配置文件需要进行管理。</p>
<p>这么多的配置文件，要修改一个或者多个的时候，稍有不慎可能就会出现改错了、不生效…等等问题。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">xxx_dev</span></span><br></pre></td></tr></table></figure>

<p><code>namespace</code> 主要用于多环境下的管理以及隔离配置和服务</p>
<p>Namespace也是官方推荐的多环境支持方案。</p>
]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel之学习</title>
    <url>/2020/04/25/Sentinel%E4%B9%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">Sentinel: 分布式系统的流量防卫兵</a></p>
<a id="more"></a>]]></content>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>Git错误集合</title>
    <url>/2020/04/23/Git%E9%94%99%E8%AF%AF%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>好记忆不如烂笔头。。，哈哈，最近开发中也遇到不少 Git 的错误，趁此机会汇总下。</p>
</blockquote>
<a id="more"></a>

<h1><span id="you-have-not-concluded-your-merge-merge_head-exists">You have not concluded your merge. (MERGE_HEAD exists)</span></h1><p>转载自：<a href="https://blog.csdn.net/daotiao0199/article/details/82757056" target="_blank" rel="noopener">https://blog.csdn.net/daotiao0199/article/details/82757056</a></p>
<p><strong>这个错误是因为以前 pull 下的代码没有自动合并导致的</strong></p>
<p>解决：</p>
<p>右键项目，找到 <strong>Git</strong></p>
<ol>
<li>执行git fetch –all</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200423114312822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="175"></p>
<ol start="2">
<li>git reset –hard origin/master</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200423114332850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="176"></p>
<p><img src="https://img-blog.csdnimg.cn/202004231144165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="177"></p>
<ol start="3">
<li>pull分支下的代码</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200423114432848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="178"></p>
<ol start="4">
<li>解决冲突</li>
<li>将自己的代码更新到本地仓库</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200423114450222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="179"></p>
<p><img src="https://img-blog.csdnimg.cn/20200423114505873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="180"></p>
<p>下面就可以继续开发了！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git错误</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令集合</title>
    <url>/2020/04/21/Git%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<a id="more"></a>

<h1><span id="删除远程分支">删除远程分支</span></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin --delete [branch_name]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之视图</title>
    <url>/2020/04/21/MySQL%E4%B9%8B%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/b11430bc4fba" target="_blank" rel="noopener">MySQL视图之我见</a></p>
<p><a href="https://www.cnblogs.com/geaozhang/p/6792369.html" target="_blank" rel="noopener">深入解析MySQL视图VIEW</a></p>
<p><a href="https://blog.csdn.net/qianqin_2014/article/details/52151722" target="_blank" rel="noopener">MySQL快速入门12—-删除数据 &amp; 备份还原 &amp; 视图 &amp; 事务 &amp; 触发器</a></p>
<blockquote>
<p>业务需求：最近项目上有用到视图，正好借此机会学习总结下视图。</p>
</blockquote>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200421122555622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="173"></p>
<h1><span id="什么是视图视图是干什么用的">什么是视图？视图是干什么用的？</span></h1><p>视图(view) 是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个 select 语句保存在数据字典中。</p>
<p>通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用视图动态生成。</p>
<p><strong>基表</strong>：用来创建视图的表叫做基表 base table</p>
<h1><span id="为什么要用视图">为什么要用视图</span></h1><ol>
<li><p>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</p>
</li>
<li><p>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</p>
</li>
<li><p>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</p>
</li>
</ol>
<p>总而言之，使用视图的大部分情况是为了保障数据安全性，提高查询效率。</p>
<h1><span id="创建视图">创建视图</span></h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> testView <span class="keyword">as</span> <span class="keyword">select</span> xxx <span class="keyword">from</span> t</span><br></pre></td></tr></table></figure>

<p>只要相应关联的表的字段都存在的话且有数据存在，则视图在建立之后马上就会有数据。</p>
<h1><span id="排查">排查</span></h1><p>如果发现新建里的视图没有数据，视图的排查是很方便的一个操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc 视图名称</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200425204741291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="181"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>视图</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos权限控制设计方案</title>
    <url>/2020/04/20/Nacos%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><a href="https://nacos.io/en-us/blog/access%20control%20design.html" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>业务需求：最近我的直属领导要求我有空去学习下 Nacos 的权限控制，因为有业务需求要对每个接口进行权限控制，由于前段时间正好学习了下 Spring-Security 和 Shrio，可以结合来学习下，融会贯通嘻嘻。。</p>
</blockquote>
<a id="more"></a>

<h1><span id="什么是权限控制">什么是权限控制？</span></h1><p>在分布式服务调用时，需要对未知的或者不受信任的请求来源的请求进行识别和拒绝。权限控制一般分为两个阶段：身份识别(Authentication) 和权限识别(Authorization)。身份认证主要确定访问者的身份，权限识别则判断这个访问者是否有对应资源的权限。</p>
<p>在 Nacos 的场景中，配置管理的权限控制指的是设置某个配置能否被某个用户读写，这个比较好理解，没有权限的用户依旧无法读取或者写入对应的配置。服务发现的权限控制指的是用户是否有权限进行某个服务的注册或者订阅，这里需要注意的是服务发现的权限控制只能够控制用户是否可以从 Nacos 获取到服务的地址或者在 Nacos 上修改服务的地址。但是如果已经获取到了服务的地址，Nacos 无法在服务真正调用时进行权限控制，这个时候的权限控制需要由服务框架来完成。</p>
<p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C174.png" alt="174"></p>
<h1><span id="常见实现方式">常见实现方式</span></h1><h2><span id="认证authentication">认证(Authentication)</span></h2><ul>
<li>用户名 + 密码</li>
<li>Cookie</li>
<li>Session</li>
<li>Token(JWT,Oauth,LDAP,SAML,OpenID)</li>
<li>AK/SK</li>
</ul>
<h2><span id="鉴权authorization">鉴权(Authorization)</span></h2><ul>
<li>ACL：规定<strong>资源</strong>可以被哪些主体进行哪些操作</li>
<li>DAC：规定<strong>资源</strong>可以被哪些<strong>主体</strong>进行哪些操作 同时，<strong>主体</strong>可以将<strong>资源</strong>的权限，授予其他<strong>主体</strong>；</li>
<li>MAC：a. 规定<strong>资源</strong>可以被哪些类别的<strong>主体</strong>进行哪些<strong>操作</strong> b. 规定<strong>主体</strong>可以对哪些等级的<strong>资源</strong>进行哪些<strong>操作</strong> 当一个<strong>操作</strong>，同时满足a与b时，允许<strong>操作</strong>；</li>
<li>RBAC：a. 规定<strong>角色</strong>可以对哪些<strong>资源</strong>进行哪些<strong>操作</strong> b. 规定<strong>主体</strong>拥有哪些<strong>角色</strong>当一个操作，同时满足a与b时，允许<strong>操作</strong>；</li>
<li>ABAC： 规定哪些<strong>属性</strong>的<strong>主体</strong>可以对哪些<strong>属性</strong>的<strong>资源</strong>在哪些<strong>属性</strong>的情况下进行哪些<strong>操作</strong>。</li>
</ul>
<h1><span id="常见注册中心和配置中心的实现方式">常见注册中心和配置中心的实现方式</span></h1><p><strong>Zookeeper</strong></p>
<p>Zookeeper 主要使用的是 ACL 的方式，直接将资源授权给对应的实体。一条授权记录主要由以下部分组成：</p>
<ul>
<li>设置权限的路径</li>
<li>&lt;acl_type&gt;：ACL鉴权类型，分为 word，ip，auth，digest</li>
<li>&lt;acl_content&gt;：ACL 鉴权内容，与鉴权类型关联</li>
<li>: CREATE，DELETE，READ，WRITE，ADMIN</li>
</ul>
<p>操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> setAcl &lt;path&gt; &lt;acl_type&gt;:&lt;acl_content&gt;:&lt;action&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setAcl /xxx/yyy world:anyone:cdrwa</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setAcl /xxx/yyy ip:1.1.1.1:cdrwa</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> addauth digest root:pa55wdsetAcl /xxx/yyy auth:root:cdrwa</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
        <tag>权限控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel导入导出的实现</title>
    <url>/2020/04/19/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/895ecf3d871c" target="_blank" rel="noopener">Java 使用POI实现Excel表格的导入导出</a></p>
<p><a href="https://www.cnblogs.com/jerehedu/p/4343509.html" target="_blank" rel="noopener">Java中导入、导出Excel</a></p>
<p><a href="https://blog.csdn.net/vbirdbest/article/details/72870714" target="_blank" rel="noopener">Apache POI使用详解</a></p>
<p><a href="http://poi.apache.org/apidocs/index.html" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://www.cnblogs.com/Damon-Luo/p/5919656.html" target="_blank" rel="noopener">Java中使用poi导入、导出Excel</a></p>
<p><a href="https://www.cnblogs.com/LiZhiW/p/4313789.html" target="_blank" rel="noopener">Apache POI使用详解</a></p>
<blockquote>
<p>业务需求：最近前端要求我这个后端的渣渣给她们提供一个接口方便从 excel 中导入业务数据。当时听到这个需求的时候我是两眼一蒙蔽，因为之前在外包公司的时候都是使用提供好的框架。。。实现原理没多少了解。于是我痛下决心好好学习下这项技术。</p>
</blockquote>
<a id="more"></a>

<h1><span id="介绍">介绍</span></h1><p>开发中经常回设计到excel的处理，如导出 Excel，导入 Excel到数据库中，操作Excel目前有两个框架，一个是 <strong>apache 的 poi</strong>，另一个是 <strong>Java Excel</strong>。</p>
<ul>
<li>Apache POI 是用 Java 编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程式对Microsoft Office（Excel、WORD、PowerPoint、Visio等）格式档案读和写的功能。</li>
<li>Java Excel 是一开发源码项目，通过它Java开发人员可以读取Excel文件的内容、创建新的Excel文件、更新已经存在的Excel文件。jxl 由于其小巧 易用的特点, 逐渐已经取代了 POI-excel的地位, 成为了越来越多的java开发人员生成excel文件的首选。</li>
</ul>
<h1><span id="apache-poi-常用的类">Apache POI 常用的类</span></h1><ul>
<li><strong>HSSF</strong> － 提供读写Microsoft Excel XLS格式档案的功能。</li>
<li><strong>XSSF</strong> － 提供读写Microsoft Excel OOXML XLSX格式档案的功能。</li>
<li><strong>HWPF</strong> － 提供读写Microsoft Word DOC97格式档案的功能。</li>
<li><strong>XWPF</strong> － 提供读写Microsoft Word DOC2003格式档案的功能。</li>
<li><strong>HSLF</strong> － 提供读写Microsoft PowerPoint格式档案的功能。</li>
<li><strong>HDGF</strong> － 提供读Microsoft Visio格式档案的功能。</li>
<li><strong>HPBF</strong> － 提供读Microsoft Publisher格式档案的功能。</li>
<li><strong>HSMF</strong> － 提供读Microsoft Outlook格式档案的功能。</li>
</ul>
<p>在开发中中我们经常使用 HSSF 来操作 Excel 处理表格数据，对于其它的不经常使用。</p>
<p>HSSF 是 Horrible SpreadSheet Format 的缩写，通过 HSSF，你可以用 Java 代码来读取，写入，修改 Excel 文件。</p>
<p>HSSF 为读取操作提供了两类 API：<strong>usermodel</strong> 和 <strong>eventusermodel</strong>，即 “用户模型” 和 “事件-用户模型”。</p>
<h2><span id="常用的类和方法">常用的类和方法</span></h2><ul>
<li><p>HSSFWorkbook：工作簿，代表一个 excel 的整个文档</p>
<ul>
<li>HSSFWorkbook()：创建一个新的工作簿</li>
<li>HSSFWorkbook(InputStream inputStream)：创建一个关联输入流的工作簿，可以将一个excel文件封装成工作簿</li>
<li>HSSFSheet createSheet(String sheetname)：创建一个新的 sheet</li>
<li>HSSFSheet getSheet(String sheetName): 通过名称获取Sheet</li>
<li>HSSFSheet getSheetAt(int index); // 通过索引获取Sheet，索引从0开始</li>
<li>HSSFCellStyle createCellStyle()； 创建单元格样式</li>
<li>int getNumberOfSheets(); 获取sheet的个数</li>
<li>setActiveSheet(int index); 设置默认选中的工作表</li>
<li>write();</li>
<li>write(File newFile);</li>
<li>write(OutputStream stream);</li>
</ul>
</li>
<li><p>HSSFSheet：工作表</p>
<ul>
<li>HSSFRow createRow(int rownum); 创建新行，需要指定行号，行号从0开始</li>
<li>HSSFRow getRow(int index); 根据索引获取指定的行</li>
<li>int addMergedRegion(CellRangeAddress region); 合并单元格</li>
<li>CellRangeAddress(int firstRow, int lastRow, int firstCol, int lastCol); 单元格范围, 用于合并单元格，需要指定要合并的首行、最后一行、首列、最后一列。</li>
<li>autoSizeColumn(int column); 自动调整列的宽度来适应内容</li>
<li>getLastRowNum(); 获取最后的行的索引，没有行或者只有一行的时候返</li>
<li>setColumnWidth(int columnIndex, int width); 设置某一列的宽度，width=字符个数 * 256，例如20个字符的宽度就是20 * 256</li>
</ul>
</li>
<li><p>HSSFRow ：行</p>
<ul>
<li>HSSFCell createCell(int column); 创建新的单元格</li>
<li>HSSFCell setCell(shot index);</li>
<li>HSSFCell getCell(shot index);</li>
<li>setRowStyle(HSSFCellStyle style); 设置行样式</li>
<li>short getLastCellNum(); 获取最后的单元格号，如果单元格有第一个开始算，lastCellNum就是列的个数</li>
<li>setHeightInPoints(float height); 设置行的高度</li>
</ul>
</li>
<li><p>HSSFCell：单元格</p>
<ul>
<li>setCellValue(String value); 设置单元格的值</li>
<li>setCellType(); 设置单元格类型，如 字符串、数字、布尔等</li>
<li>setCellStyle(); 设置单元格样式</li>
<li>String getStringCellValue(); 获取单元格中的字符串值</li>
<li>setCellStyle(HSSFCellStyle style); 设置单元格样式，例如字体、加粗、格式化</li>
<li>setCellFormula(String formula); 设置计算公式，计算的结果作为单元格的值，也提供了异常常用的函数，如求和”sum(A1,C1)”、日期函数、字符串相关函数、CountIf和SumIf函数、随机数函数等</li>
</ul>
</li>
<li><p>HSSFCellStyle ：单元格样式</p>
<ul>
<li>setFont(Font font); 为单元格设置字体样式</li>
<li>setAlignment(HorizontalAlignment align); // 设置水平对齐方式</li>
<li>setVerticalAlignment(VerticalAlignment align); // 设置垂直对齐方式</li>
<li>setFillPattern(FillPatternType fp);</li>
<li>setFillForegroundColor(short bg); 设置前景色</li>
<li>setFillBackgroundColor(short bg); 设置背景颜色</li>
</ul>
</li>
<li><p>HSSFFont：字体，</p>
<ul>
<li>setColor(short color); // 设置字体颜色</li>
<li>setBold(boolean bold); // 设置是否粗体</li>
<li>setItalic(boolean italic); 设置倾斜</li>
<li>setUnderline(byte underline); 设置下划线</li>
</ul>
</li>
<li><p>HSSFName：名称</p>
</li>
<li><p>HSSFDataFormat ：日期格式化</p>
</li>
<li><p>HSSFHeader ： Sheet的头部</p>
</li>
<li><p>HSSFFooter ：Sheet的尾部</p>
</li>
<li><p>HSSFDateUtil ：日期工具</p>
</li>
<li><p>HSSFPrintSetup ：打印设置</p>
</li>
<li><p>HSSFErrorConstants：错误信息表</p>
</li>
</ul>
<p>Excel 中的工作簿，工作表，行，单元格中的关系</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">一个 Excel 文件对应于一个 workbook(HSSFWorkbook)</span><br><span class="line">一个 workbook 可以有多个 <span class="built_in">sheet</span>(HSSFSheet) 组成</span><br><span class="line">一个 <span class="built_in">sheet</span> 是由多个 <span class="built_in">row</span>(HSSFRow) 组成</span><br><span class="line">一个 <span class="built_in">row</span> 是由多个 <span class="built_in">cell</span>(HSSFCell) 组成</span><br></pre></td></tr></table></figure>

<h2><span id="基本操作步骤">基本操作步骤</span></h2><ol>
<li>用 HSSFWorkbook 打开或者创建 “Excel文件对象”</li>
<li>用 HSSFWorkbook 对象返回或者创建 Sheet 对象</li>
<li>用 Sheet 对象返回行对象，用行对象得到 Cell 对象</li>
<li>对 Cell 对象读写</li>
</ol>
<h1><span id="实现">实现</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelFileImportUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将excel转换为对象(Object)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">parseExcelToObject</span><span class="params">(MultipartFile multipartFile, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> RestApiException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Field[] fields = getFields(clazz);</span><br><span class="line">        List&lt;List&lt;Cell&gt;&gt; parseList = parseExcel(multipartFile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == parseList || parseList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Cell&gt; cellList : parseList) &#123;</span><br><span class="line">                T object = clazz.newInstance();</span><br><span class="line">                cellList.stream().forEach(e -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                        <span class="keyword">int</span> index = e.getColumnIndex();</span><br><span class="line">                        setFieldValue(object, fields[index], e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                resultList.add(object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"解析文件出错   e=&#123;&#125;"</span>, e.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ErrorConstant.PARSE_IMPORT_FILE_ERROR, ErrorConstant.PARSE_IMPORT_FILE_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将excel转换为list</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; parseExcelToList(MultipartFile multipartFile) <span class="keyword">throws</span> RestApiException &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Cell&gt;&gt; parseList = parseExcel(multipartFile);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == parseList || parseList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseList.stream().forEach(a -&gt; &#123;</span><br><span class="line">                List&lt;String&gt; cellList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                a.stream().forEach(b -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        cellList.add(<span class="string">""</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        b.setCellType(Cell.CELL_TYPE_STRING);</span><br><span class="line">                        cellList.add(b.getStringCellValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                resultList.add(cellList);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"解析文件出错   e=&#123;&#125;"</span>+ e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ErrorConstant.PARSE_IMPORT_FILE_ERROR, ErrorConstant.PARSE_IMPORT_FILE_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将excel转换为题目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseExcelTitle</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> RestApiException </span>&#123;</span><br><span class="line">        Workbook workbook = generateWorkbook(multipartFile);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; titleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Sheet sheet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 行</span></span><br><span class="line">        Row row = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//单元格</span></span><br><span class="line">        Cell cell = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只取第一个表格</span></span><br><span class="line">        sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sheet == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第二行开始,第一行是标题</span></span><br><span class="line">        row = sheet.getRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历单元格</span></span><br><span class="line">        <span class="keyword">if</span> (row != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row.getFirstCellNum(); i &lt; row.getLastCellNum(); i++) &#123;</span><br><span class="line">                cell = row.getCell(i);</span><br><span class="line">                cell.setCellType(Cell.CELL_TYPE_STRING);</span><br><span class="line">                titleList.add(cell.getStringCellValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> titleList;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//解析excel</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Cell&gt;&gt; parseExcel(MultipartFile multipartFile) <span class="keyword">throws</span> RestApiException &#123;</span><br><span class="line">        Workbook workbook = generateWorkbook(multipartFile);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Cell&gt;&gt; parseList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Sheet sheet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 行</span></span><br><span class="line">        Row row = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//单元格</span></span><br><span class="line">        Cell cell = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只取第一个表格</span></span><br><span class="line">        sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sheet == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第二行开始,第一行是标题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sheet.getFirstRowNum(); j &lt;= sheet.getLastRowNum(); j++) &#123;</span><br><span class="line">            row = sheet.getRow(j);</span><br><span class="line">            <span class="keyword">if</span> (row == <span class="keyword">null</span> || (row.getFirstCellNum() == j &amp;&amp; j == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//                if(j == 1) &#123;</span></span><br><span class="line">            <span class="comment">//                    continue;</span></span><br><span class="line">            <span class="comment">//                &#125;</span></span><br><span class="line">            List&lt;Cell&gt; cellList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历单元格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = row.getFirstCellNum(); k &lt; row.getLastCellNum(); k++) &#123;</span><br><span class="line">                cell = row.getCell(k);</span><br><span class="line">                cellList.add(cell);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            parseList.add(cellList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parseList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将excel转换为workbook</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Workbook <span class="title">generateWorkbook</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> RestApiException </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!multipartFile.getOriginalFilename().endsWith(<span class="string">".xlsx"</span>) &amp;&amp; !multipartFile.getOriginalFilename().endsWith(<span class="string">".xls"</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">"校验文件格式错误  fileName&#123;&#125;"</span>, multipartFile.getOriginalFilename());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ErrorConstant.IMPORT_FILE_FORMAT_ERROR, ErrorConstant.IMPORT_FILE_FORMAT_ERROR_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long fileSize = multipartFile.getSize();</span><br><span class="line">        <span class="keyword">if</span> (fileSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"parseFile  导入的文件为空  fileName =&#123;&#125;"</span>, multipartFile.getOriginalFilename());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ErrorConstant.IMPORT_FILE_IS_EMPTY_ERROR, ErrorConstant.IMPORT_FILE_IS_EMPTY_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Workbook workbook = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = multipartFile.getInputStream();</span><br><span class="line">            workbook = WorkbookFactory.create(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"解析文件出错  fileName=&#123;&#125;"</span>, multipartFile.getOriginalFilename());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ErrorConstant.PARSE_IMPORT_FILE_ERROR, ErrorConstant.PARSE_IMPORT_FILE_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == workbook) &#123;</span><br><span class="line">            log.warn(<span class="string">"parseFile  导入的文件为空  fileName =&#123;&#125;"</span>, multipartFile.getOriginalFilename());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ErrorConstant.IMPORT_FILE_IS_EMPTY_ERROR, ErrorConstant.IMPORT_FILE_IS_EMPTY_ERROR_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workbook;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字段数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Field[] getFields(Class clazz) &#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.getDeclaredFields();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给字段赋值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(Object object, Field field, Cell cell)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cell == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class clazz = field.getType();</span><br><span class="line">        <span class="comment">//将字段设置为可以访问的</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                cell.setCellType(Cell.CELL_TYPE_STRING);</span><br><span class="line">                field.set(object, cell.getStringCellValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clazz == Date<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                field.set(object, cell.getDateCellValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clazz == Boolean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                field.set(object, cell.getBooleanCellValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clazz == Double<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                field.set(object, cell.getNumericCellValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.warn(<span class="string">"赋值错误  e&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之Specification复杂查询和Criteria查询</title>
    <url>/2020/04/17/Spring%E4%B9%8BSpecification/</url>
    <content><![CDATA[<p><a href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/domain/Specification.html" target="_blank" rel="noopener">Specification官网</a></p>
<p><a href="https://www.jianshu.com/p/659e9715d01d" target="_blank" rel="noopener">【一目了然】Spring Data JPA使用Specification动态构建多表查询、复杂查询及排序示例</a></p>
<p><a href="https://blog.wuwii.com/jpa-specification.html" target="_blank" rel="noopener">JPA 使用 Specification 复杂查询和 Criteria 查询</a></p>
<p><a href="https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/CriteriaBuilder.html" target="_blank" rel="noopener">CriteriaBuilder官网</a></p>
<p><a href="https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/package-summary.html" target="_blank" rel="noopener">Criteria官网</a></p>
<p><a href="https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/Root.html" target="_blank" rel="noopener">Criteria-Root官网</a></p>
<p><a href="https://my.oschina.net/zhaoqian/blog/133500" target="_blank" rel="noopener">JPA criteria 查询:类型安全与面向对象</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-typesafejpa/index.html" target="_blank" rel="noopener">JPA 2.0 中的动态类型安全查询</a></p>
<p><a href="https://blog.csdn.net/ID_Kong/article/details/70225032" target="_blank" rel="noopener">java-jpa-criteriaBuilder使用入门</a></p>
<p><a href="https://juejin.im/post/5d64f70fe51d4561fa2ec09c" target="_blank" rel="noopener">Spring data jpa 的使用与详解（二）：复杂动态查询及分页，排序</a></p>
<blockquote>
<p>业务需求：JPA 确实挺好用，给我们提供了 CRUD 的功能，并且用起来也是特别的方便，基本都是一行代码就能完成各种数据库操作，跟 mybatisplus 很像。。。但是在遇到复杂的多条件以及多表查询的时候，总是会首先考虑到手写原生的 SQL。</p>
</blockquote>
<a id="more"></a>

<p>Specification 算是 JPA 中比较灵活的查询方式，也少不了 Criteria 类型安全和面向对象的优点</p>
<h1><span id="环境配置">环境配置</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jpa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="代码实现">代码实现</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxSpecification</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">xxxSpecification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;xxxEntity&gt; <span class="title">buildFromParam</span><span class="params">(Set&lt;String&gt; xxxList)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> (root,query,builder) -&gt; &#123;</span><br><span class="line">            <span class="comment">//Predicate: 过滤条件,相当于构造 where 中的条件</span></span><br><span class="line">            ArrayList&lt;Predicate&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(!CollectionUtils.isEmpty(xxxList))&#123;</span><br><span class="line">				<span class="comment">//root：从元模型中获取相应的字段</span></span><br><span class="line">                CriteriaBuilder.In&lt;String&gt; in = builder.in(root.get(<span class="string">"id"</span>));</span><br><span class="line">                <span class="keyword">for</span>(String itemId:xxxList)&#123;</span><br><span class="line">                    in.value(itemId);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(in);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.add(builder.equal(root.get(<span class="string">"status"</span>), TableStatusEnum.NORMAL_STATUS.getCode()));</span><br><span class="line">            Predicate[] predicates = <span class="keyword">new</span> Predicate[list.size()];</span><br><span class="line">            predicates = list.toArray(predicates);</span><br><span class="line">            <span class="keyword">return</span> builder.and(predicates);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的代码对应于</p>
<p><img src="https://img-blog.csdnimg.cn/20200418162037917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="169"></p>
<h1><span id="原理">原理</span></h1><p>JPA 提供动态接口(<strong><em>JpaSpecificationExecutor</em></strong>)，利用类型检查方式，进行复杂的条件查询，这个比自己写 SQL 更加安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.jpa.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.domain.Specification;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Optional&lt;T&gt; <span class="title">findOne</span><span class="params">(@Nullable Specification&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(@Nullable Specification&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(@Nullable Specification&lt;T&gt; var1, Pageable var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(@Nullable Specification&lt;T&gt; var1, Sort var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(@Nullable Specification&lt;T&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Specification</code> 是我们传入进去的查询参数，实际上它是一个接口，并且只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Specification</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="元模型">元模型</span></h2><p>在JPA中,标准查询是以元模型的概念为基础的，元模型是为具体持久化单元的受管实体定义的.这些实体可以是实体类,嵌入类或者映射的父类.提供受管实体元信息的类就是元模型类.<br>简单的说就是<strong>元模型是实体类对应的一个“受管实体</strong></p>
<h3><span id="例子">例子：</span></h3><p><strong>实体类</strong> Employee(com.demo.entities包中定义)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;   </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Address&gt; addresses;</span><br><span class="line">    <span class="comment">// Other code…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Employee类的标准<strong>元模型类</strong>的名字是 Employee_</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Generated;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.SingularAttribute;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.ListAttribute;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.StaticMetamodel;</span><br><span class="line"><span class="meta">@StaticMetamodel</span>(Employee<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Employee_</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Employee, Integer&gt; id;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Employee, Integer&gt; age;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Employee, String&gt; name;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ListAttribute&lt;Employee, Address&gt; addresses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Employee的每一个属性都会使用在JPA2规范中描述的以下规则在相应的元模型类中映射：</p>
<blockquote>
<ul>
<li>元模型类的属性全部是static和public的。</li>
<li>元模型类的属性全部是static和public的。Employee的每一个属性都会使用在JPA2规范中描述的以下规则在相应的元模型类中映射：</li>
<li>对于Addess这样的集合类型，会定义静态属性ListAttribute&lt; A, B&gt; b，这里List对象b是定义在类A中类型B的对象。其它集合类型可以是SetAttribute, MapAttribute 或 CollectionAttribute 类型。</li>
</ul>
</blockquote>
<p>为什么要使用<strong>元模型</strong>，答：查询类型更加安全</p>
<h2><span id="criteria-查询">Criteria 查询</span></h2><p>为了更好的理解criteria 查询，考虑拥有Employee实例集合的Dept实体，Employee和Dept的元模型类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//All Necessary Imports</span></span><br><span class="line"><span class="meta">@StaticMetamodel</span>(Dept<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Dept_</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Dept, Integer&gt; id;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ListAttribute&lt;Dept, Employee&gt; employeeCollection;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Dept, String&gt; name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//All Necessary Imports</span></span><br><span class="line"><span class="meta">@StaticMetamodel</span>(Employee<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Employee_</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Employee, Integer&gt; id;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Employee, Integer&gt; age;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Employee, String&gt; name;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Employee, Dept&gt; deptId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码片段展示了一个criteria 查询，它用于获取所有年龄大于24岁的员工：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();</span><br><span class="line">CriteriaQuery&lt;Employee&gt; criteriaQuery = criteriaBuilder.createQuery(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Root&lt;Employee&gt; employee = criteriaQuery.from(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Predicate condition = criteriaBuilder.gt(employee.get(Employee_.age), <span class="number">24</span>);</span><br><span class="line">criteriaQuery.where(condition);</span><br><span class="line">TypedQuery&lt;Employee&gt; typedQuery = em.createQuery(criteriaQuery);</span><br><span class="line">List&lt;Employee&gt; result = typedQuery.getResultList();</span><br></pre></td></tr></table></figure>

<p>对应的<strong>SQL: SELECT * FROM employee WHERE age &gt; 24</strong></p>
<h2><span id="criteriabuilder-安全查询创建工厂">CriteriaBuilder 安全查询创建工厂</span></h2><p>CriteriaBuilder 安全查询创建工厂，创建 <strong>CriteriaQuery</strong>，创建查询具体条件 <strong>Predicate</strong> 等。</p>
<p>CriteriaBuilder是一个工厂对象,安全查询的开始.用于构建JPA安全查询.可以从EntityManager 或 EntityManagerFactory类中获得CriteriaBuilder。<br>比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();</span><br></pre></td></tr></table></figure>

<h2><span id="criteriaquery-安全查询主语句">CriteriaQuery 安全查询主语句</span></h2><ul>
<li>它通过调用 CriteriaBuilder, createQuery 或CriteriaBuilder.createTupleQuery 获得。</li>
<li>CriteriaBuilder就像CriteriaQuery 的工厂一样。</li>
<li>CriteriaQuery对象必须在实体类型或嵌入式类型上的Criteria 查询上起作用。</li>
<li>Employee实体的 CriteriaQuery 对象以下面的方式创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();</span><br><span class="line">CriteriaQuery&lt;Employee&gt; criteriaQuery = criteriaBuilder.createQuery(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="root-定义查询的-from-子句中能出现的类型">Root 定义查询的 From 子句中能出现的类型</span></h2><p><img src="https://img-blog.csdnimg.cn/20200418162055711.png#pic_center" alt="170"></p>
<p>查询表达式被赋予泛型。一些典型的表达式是：</p>
<ul>
<li><p>Root&lt;T&gt;, 相当于一个 From 子句,定义查询的 From 子句中能出现的类型</p>
</li>
<li><p>Criteria查询的查询根定义了实体类型，能为将来导航获得想要的结果，它与SQL查询中的FROM子句类似。</p>
</li>
<li><p>Root实例也是类型化的，且定义了查询的FROM子句中能够出现的类型。</p>
</li>
<li><p>查询根实例能通过传入一个实体类型给 AbstractQuery.from方法获得</p>
</li>
<li><p>Criteria查询，可以有多个查询根。</p>
</li>
<li><p>Employee 实体的查询根对象可以用以下语法获得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Root&lt;Employee&gt; employee = criteriaQuery.from(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3><span id="源码">源码</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.persistence.criteria;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.EntityType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Root</span>&lt;<span class="title">X</span>&gt; <span class="keyword">extends</span> <span class="title">From</span>&lt;<span class="title">X</span>, <span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">EntityType&lt;X&gt; <span class="title">getModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 Root 继承自 <strong>From</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">From</span>&lt;<span class="title">Z</span>, <span class="title">X</span>&gt; <span class="keyword">extends</span> <span class="title">Path</span>&lt;<span class="title">X</span>&gt;, <span class="title">FetchParent</span>&lt;<span class="title">Z</span>, <span class="title">X</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而 From 又继承自 <strong>Path</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.persistence.criteria;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.Bindable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.MapAttribute;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.PluralAttribute;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.SingularAttribute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span>&lt;<span class="title">X</span>&gt; <span class="keyword">extends</span> <span class="title">Expression</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Bindable&lt;X&gt; <span class="title">getModel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Path&lt;?&gt; getParentPath();</span><br><span class="line"></span><br><span class="line">    &lt;Y&gt; <span class="function">Path&lt;Y&gt; <span class="title">get</span><span class="params">(SingularAttribute&lt;? <span class="keyword">super</span> X, Y&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;E, C extends Collection&lt;E&gt;&gt; <span class="function">Expression&lt;C&gt; <span class="title">get</span><span class="params">(PluralAttribute&lt;X, C, E&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;K, V, M extends Map&lt;K, V&gt;&gt; <span class="function">Expression&lt;M&gt; <span class="title">get</span><span class="params">(MapAttribute&lt;X, K, V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    Expression&lt;Class&lt;? extends X&gt;&gt; type();</span><br><span class="line"></span><br><span class="line">    &lt;Y&gt; <span class="function">Path&lt;Y&gt; <span class="title">get</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="predicate-过滤条件">Predicate 过滤条件</span></h2><ul>
<li>过滤条件应用到SQL语句的FROM子句中。</li>
<li>在criteria 查询中，查询条件通过Predicate 或Expression 实例应用到CriteriaQuery 对象上。</li>
<li>这些条件使用 CriteriaQuery .where 方法应用到CriteriaQuery 对象上。</li>
<li>Predicate 实例也可以用Expression 实例的 isNull， isNotNull 和 in方法获得，复合的Predicate 语句可以使用CriteriaBuilder的and, or andnot 方法构建。</li>
<li>CriteriaBuilder 也是作为Predicate 实例的工厂，Predicate 对象通过调用CriteriaBuilder 的条件方法（ equal，notEqual， gt， ge，lt， le，between，like等）创建。</li>
<li>这些条件使用 CriteriaQuery .where 方法应用到CriteriaQuery 对象上。</li>
</ul>
<p>下面的代码片段展示了Predicate 实例检查年龄大于24岁的员工实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate condition = criteriaBuilder.gt(employee.get(Employee_.age), <span class="number">24</span>);</span><br><span class="line">criteriaQuery.where(condition);</span><br></pre></td></tr></table></figure>

<h1><span id="初步结论">初步结论</span></h1><p>CriteriaBuilder: 构造 sql 语句</p>
<p>predicate：构造 where 中的条件语句，过滤条件</p>
<p>root：获取对应元模型的字段属性</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Specification</tag>
        <tag>Criteria</tag>
      </tags>
  </entry>
  <entry>
    <title>Mqtt之学习</title>
    <url>/2020/04/17/Mqtt%E4%B9%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/5c42cb0ed1e9" target="_blank" rel="noopener">一文读懂MQTT协议</a></p>
<p><a href="http://mqtt.org/documentation" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>

<h1><span id="简述">简述</span></h1><p>MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)，是一种基于发布/订阅模式的”轻量级”通讯协议，该协议构建于 TCP/IP 协议。</p>
<p>MQTT 最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销，低带宽占用的即时通讯协议，使其在物联网，小型设备，移动应用等方面有较广泛的应用。</p>
<p>MQTT 是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT 协议是轻量，简单，开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<p><img src="https://img-blog.csdnimg.cn/20200418221259224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="172"></p>
<h1><span id="设计规范">设计规范</span></h1><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p>
<ul>
<li>（1）精简，不添加可有可无的功能；</li>
<li>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li>
<li>（3）允许用户动态创建主题，零运维成本；</li>
<li>（4）把传输量降到最低以提高传输效率；</li>
<li>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</li>
<li>（6）支持连续的会话控制；</li>
<li>（7）理解客户端计算能力可能很低；</li>
<li>（8）提供服务质量管理；</li>
<li>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li>
</ul>
<h1><span id="主要特性">主要特性</span></h1><p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p>
<ul>
<li><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p>
<p>这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p>
</li>
<li><p>（2）对负载内容屏蔽的消息传输。</p>
</li>
<li><p>（3）使用TCP/IP提供网络连接。</p>
<p>主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p>
</li>
<li><p>（4）有三种消息发布服务质量：</p>
<p>“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p>
<p>“至少一次”，确保消息到达，但消息重复可能会发生。</p>
<p>“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p>
</li>
<li><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p>
<p>这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p>
</li>
<li><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p>
<p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p>
<p>Testament：遗嘱机制，功能类似于Last Will。</p>
</li>
</ul>
<h1><span id="mqtt协议原理">MQTT协议原理</span></h1><h2><span id="mqtt协议实现方式">MQTT协议实现方式</span></h2><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<ul>
<li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li>
<li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li>
</ul>
<h2><span id="网络传输与应用消息">网络传输与应用消息</span></h2><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p>
<p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p>
<h2><span id="mqtt客户端">MQTT客户端</span></h2><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<ul>
<li>（1）发布其他客户端可能会订阅的信息；</li>
<li>（2）订阅其它客户端发布的消息；</li>
<li>（3）退订或删除应用程序的消息；</li>
<li>（4）断开与服务器连接。</li>
</ul>
<h2><span id="mqtt服务器">MQTT服务器</span></h2><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p>
<ul>
<li>（1）接受来自客户的网络连接；</li>
<li>（2）接受客户发布的应用信息；</li>
<li>（3）处理来自客户端的订阅和退订请求；</li>
<li>（4）向订阅的客户转发应用程序消息。</li>
</ul>
<h3><span id="mqtt协议中的订阅-主题-会话">MQTT协议中的订阅、主题、会话</span></h3><h3><span id="一-订阅subscription"><strong>一、订阅（Subscription）</strong></span></h3><p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p>
<h3><span id="二-会话session"><strong>二、会话（Session）</strong></span></h3><p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p>
<h3><span id="三-主题名topic-name"><strong>三、主题名（Topic Name）</strong></span></h3><p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p>
<h3><span id="四-主题筛选器topic-filter"><strong>四、主题筛选器（Topic Filter）</strong></span></h3><p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p>
<h3><span id="五-负载payload"><strong>五、负载（Payload）</strong></span></h3><p>消息订阅者所具体接收的内容。</p>
<h3><span id="mqtt协议中的方法">MQTT协议中的方法</span></h3><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p>
<ul>
<li>（1）Connect。等待与服务器建立连接。</li>
<li>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li>
<li>（3）Subscribe。等待完成订阅。</li>
<li>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li>
<li>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li>
</ul>
<h1><span id="mqtt协议数据包结构">MQTT协议数据包结构</span></h1><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p>
<ul>
<li>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li>
<li>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li>
<li>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</li>
</ul>
<p>todo:未完待续…</p>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Intellij的误操作(update projects)</title>
    <url>/2020/04/17/%E8%AE%B0%E4%B8%80%E6%AC%A1Intellij%E7%9A%84%E8%AF%AF%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/geng31/article/details/78585557" target="_blank" rel="noopener">IDEA中Git的更新、提交、还原方法</a></p>
<p><a href="https://blog.csdn.net/stone_yw/article/details/80795669" target="_blank" rel="noopener">git stash详解</a></p>
<p><a href="https://blog.csdn.net/u011299078/article/details/80707999" target="_blank" rel="noopener">IntelliJ IDEA的shelve的功能</a></p>
<p><a href="https://www.oschina.net/question/948439_2231748" target="_blank" rel="noopener">Intellij idea里面使用git，stash、shelve分别是什么意思？我更新以后本地写的那些代码没了。</a></p>
<p><a href="https://www.jetbrains.com/help/idea/shelving-and-unshelving-changes.html" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>

<p>昨天在辛辛苦苦的敲了一天，可是点击一直非常信任的update projects 按钮之后，一下子就回到解放前了。。</p>
<p>痛下狠心的我决定好好学习下其中的原理！</p>
<p><img src="https://img-blog.csdnimg.cn/2020041816521032.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="171"></p>
<p>clean working tree before update</p>
<ul>
<li><p><strong>stash</strong> 是当你当前开发的代码不想提交的时候又需要切换到其他分支开发的时候，可以将当前代码保存到堆栈中，等到下次切换回该分支的时候可以从堆栈中恢复回来。</p>
</li>
<li><p><strong>shelve</strong> 是 intellij 提供暂时保存代码的一种功能</p>
</li>
</ul>
<p>Update Type</p>
<ul>
<li><strong>Merge</strong>：合并</li>
<li><strong>Rebase</strong>：保留本地代码</li>
<li><strong>Branch Default</strong>：保留仓库代码</li>
</ul>
<h1><span id="解决">解决</span></h1><p>git stash和shelve都是讲更新内容为优先级最高执行的,将本地代码暂存搁置,</p>
<p>问题是文件有冲突被合并覆盖了,出现这个问题时要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br><span class="line">git diff -w +文件名</span><br></pre></td></tr></table></figure>

<p>你本地的代码是肯定会有记录的,能找回的,local history就可以</p>
<h2><span id="通过-local-history-找回">通过 Local History 找回</span></h2><p>项目右键 –&gt; <strong>Local History</strong></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>update projects</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之validated校验</title>
    <url>/2020/04/15/Spring%E4%B9%8Bvalidated%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/annotation/Validated.html" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://www.cnkirito.moe/spring-validation/" target="_blank" rel="noopener">使用 spring validation 完成数据后端校验</a></p>
<a id="more"></a>

<p>数据的校验是交互式网站一个不可或缺的功能，前端的 js 校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用 http 工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落到数据库中，如果数据库中出现一个非法的邮箱格式，也会让运维人员头疼不已。</p>
<h1><span id="引入依赖">引入依赖</span></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们只需要引入 spring-boot-starter-web 依赖即可，如果查看其子依赖，可以发现如下的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>验证了我之前的描述，<strong>web 模块使用了 hibernate-validation</strong>，并且 databind 模块也提供了相应的数据绑定功能。</p>
<h1><span id="构建启动类">构建启动类</span></h1><p>无需添加其他注解，一个典型的启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ValidateApp<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="创建需要被校验的实体类">创建需要被校验的实体类</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"用户id不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"反馈分主题不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mainTitle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"反馈子主题不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String slaveTitle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"问题详情不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String questionDetail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String imgUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"修改者id不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String editUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一些比较常用的校验注解，还是比较浅显易懂的，字段上的注解名称即可推断出校验内容，每一个注解都包含了 message 字段，用于校验失败时作为提示信息，特殊的校验注解，如 Pattern（正则校验），还可以自己添加正则表达式。</p>
<h1><span id="在-controller-中校验数据">在 @Controller 中校验数据</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestApiResult <span class="title">saveXxx</span><span class="params">(@RequestBody @Validated xxxRequest req)</span></span>&#123;</span><br><span class="line">        xxxService.refreshXxx(req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个最基本的校验就完成了，总结下框架已经提供了哪些校验：</p>
<p><strong>JSR 提供的校验注解</strong> :</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Null</span>   被注释的元素必须为 null    </span><br><span class="line"><span class="variable">@NotNull</span>    被注释的元素必须不为 null    </span><br><span class="line"><span class="variable">@AssertTrue</span>     被注释的元素必须为 true    </span><br><span class="line"><span class="variable">@AssertFalse</span>    被注释的元素必须为 false    </span><br><span class="line"><span class="variable">@Min</span>(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值    </span><br><span class="line"><span class="variable">@Max</span>(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值    </span><br><span class="line"><span class="variable">@DecimalMin</span>(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值    </span><br><span class="line"><span class="variable">@DecimalMax</span>(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值    </span><br><span class="line"><span class="variable">@Size</span>(max=, min=)   被注释的元素的大小必须在指定的范围内    </span><br><span class="line"><span class="variable">@Digits</span> (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内    </span><br><span class="line"><span class="variable">@Past</span>   被注释的元素必须是一个过去的日期    </span><br><span class="line"><span class="variable">@Future</span>     被注释的元素必须是一个将来的日期    </span><br><span class="line"><span class="variable">@Pattern</span>(regex=,flag=)  被注释的元素必须符合指定的正则表达式</span><br></pre></td></tr></table></figure>

<p><strong>Hibernate Validator 提供的校验注解</strong> ：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@NotBlank</span>(message =)   验证字符串非 null，且长度必须大于 <span class="number">0</span>    </span><br><span class="line"><span class="variable">@Email</span>  被注释的元素必须是电子邮箱地址    </span><br><span class="line"><span class="variable">@Length</span>(min=,max=)  被注释的字符串的大小必须在指定的范围内    </span><br><span class="line"><span class="variable">@NotEmpty</span>   被注释的字符串的必须非空    </span><br><span class="line"><span class="variable">@Range</span>(min=,max=,message=)  被注释的元素必须在合适的范围内</span><br></pre></td></tr></table></figure>

<h1><span id="结果">结果</span></h1><p><img src="https://img-blog.csdnimg.cn/20200415140548878.png#pic_center" alt="168"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>validated</tag>
      </tags>
  </entry>
  <entry>
    <title>系统的有状态和无状态</title>
    <url>/2020/04/15/%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%89%E7%8A%B6%E6%80%81%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/zhoumingp/article/details/50457203" target="_blank" rel="noopener">003.聊聊系统设计：有状态、无状态</a></p>
<a id="more"></a>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之JPA</title>
    <url>/2020/04/14/Spring%E4%B9%8BJPA/</url>
    <content><![CDATA[<p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://www.cnblogs.com/dreamroute/p/5173896.html" target="_blank" rel="noopener">【原创】纯干货，Spring-data-jpa详解，全方位介绍。</a></p>
<p><a href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank" rel="noopener">Interface JpaRepository&lt;T,ID&gt;</a></p>
<blockquote>
<p>JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体<a href="https://baike.baidu.com/item/对象持久化/7316192" target="_blank" rel="noopener">对象持久化</a>到数据库中。 [1]</p>
</blockquote>
<a id="more"></a>

<p>在使用持久化工具的时候，一般都有一个对象来操作数据库，在原生的Hibernate中叫做Session，在JPA中叫做EntityManager，在MyBatis中叫做SqlSession。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之原型模式</title>
    <url>/2020/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319233388578" target="_blank" rel="noopener">原型</a></p>
<p><a href="https://www.cnblogs.com/fengyumeng/p/10646487.html" target="_blank" rel="noopener">原型模式</a></p>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
</blockquote>
<a id="more"></a>

<h1><span id="使用场景">使用场景</span></h1><ol>
<li>在需要一个类的大量对象的时候，使用原型模式是最佳选择，因为原型模式是在内存中对这个对象进行拷贝，要比直接 new 这个对象性能要好很多，在这种情况下，需要的对象越多，原型模式体现出的优点越明显。</li>
<li>如果一个对象的初始化需要很多其他对象的数据准备或其他资源的繁琐计算，那么可以使用原型模式</li>
<li>当需要一个对象的大量公共信息，少量字段进行个性化设置的时候，也可以使用原型模式拷贝出现现有对象的副本进行加工处理。</li>
</ol>
<h1><span id="实现">实现</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"原型模式测试..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Test <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test = (Test) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        Test t1 = t.clone();</span><br><span class="line">        Test t2 = t.clone();</span><br><span class="line">        Test t3 = t.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">原型模式测试...</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里可以证明对象拷贝的时候构造函数时不会执行的，原因在于拷贝是直接在堆中进行，这其实也可以理解，new的时候，JVM要走一趟类加载流程，这个流程非常麻烦，在类加载流程中会调用构造函数，最后生成的对象会放到堆中，而拷贝就是直接拷贝堆中的现成的二进制对象，然后重新一个分配内存块。</p>
<p>todo：未完待续。。。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之RestTemplate</title>
    <url>/2020/04/12/SpringBoot%E4%B9%8BRestTemplate/</url>
    <content><![CDATA[<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://blog.csdn.net/u012702547/article/details/77917939" target="_blank" rel="noopener">Spring RestTemplate中几种常见的请求方式</a></p>
<blockquote>
<p>需求：通过 <code>RestTemplate</code> 从接口获取数据，然后写入数据库同时保存该数据副本到服务器</p>
</blockquote>
<p>由于之前并没有怎么使用过 RestTemplate请求数据，只是用过 Feign 去跨服务调用。。看来我太菜了哈哈。</p>
<a id="more"></a>

<h1><span id="实现">实现</span></h1><p>我发现设置请求body的时候有许多重复的代码，于是我就用 builder模式 改造了下</p>
<p><strong>登录获取token</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录获取token</span></span><br><span class="line"><span class="comment">//--loginKey转成Base64的格式</span></span><br><span class="line">String dataStr = RestConstant.BIG_SCREEN_TOKEN + DateUtils.dateToStamp();</span><br><span class="line">String loginKey = Base64Utils.encodeToString(dataStr.getBytes());</span><br><span class="line"><span class="comment">//--body</span></span><br><span class="line">MultiValueMap&lt;String, String&gt; requestTokenBody = <span class="keyword">new</span> RequestBody.RequestBodyBuilder()</span><br><span class="line">    .setGrantType(<span class="string">"xxx"</span>)</span><br><span class="line">    .setAuthType(<span class="string">"xxx"</span>)</span><br><span class="line">    .setLoginKey(loginKey)</span><br><span class="line">    .build().getRequestBody();</span><br><span class="line"></span><br><span class="line">HttpEntity requestEntity = <span class="keyword">new</span> HttpEntity(requestTokenBody,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//--获取 accessToken</span></span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(<span class="string">"http://"</span>+url + <span class="string">"/login/bigScreen"</span>, requestEntity, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>builder 模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBody</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MultiValueMap&lt;String, String&gt; requestBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiValueMap&lt;String, String&gt; <span class="title">getRequestBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestBody</span><span class="params">(RequestBodyBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.requestBody = builder.requestBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyBuilder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String grantType;</span><br><span class="line">        <span class="keyword">private</span> String authType;</span><br><span class="line">        <span class="keyword">private</span> MultiValueMap&lt;String, String&gt; requestBody;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RequestBodyBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.requestBody = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RequestBodyBuilder <span class="title">setGrantType</span><span class="params">(String grantType)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.requestBody.add(<span class="string">"xxx"</span>,grantType);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RequestBodyBuilder <span class="title">setAuthType</span><span class="params">(String authType)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.requestBody.add(<span class="string">"xxx"</span>,authType);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RequestBody <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RequestBody(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="get-请求">GET 请求</span></h1><p>在RestTemplate中，发送一个GET请求，我们可以通过如下两种方式：</p>
<h2><span id="第一种getforentity">第一种：getForEntity</span></h2><p>getForEntity方法的返回值是一个ResponseEntity<t>，ResponseEntity<t>是Spring对HTTP请求响应的封装，包括了几个重要的元素，如响应码、contentType、contentLength、响应消息体等。比如下面一个例子：</t></t></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://HELLO-SERVICE/hello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第一个参数为要调用的服务的地址</strong>，这里我调用了服务提供者提供的/hello接口，注意这里是通过服务名调用而不是服务地址，如果写成服务地址就没法实现客户端负载均衡了。</li>
<li>第二个参数String.class表示希望返回的body类型是String</li>
</ul>
<p>有时候我在调用服务提供者提供的接口时，可能需要传递参数，有两种不同的方式，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity("http://HELLO-SERVICE/sayhello?name=&#123;1&#125;", String.class, "张三");</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://HELLO-SERVICE/sayhello?name=&#123;name&#125;"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以用一个数字做占位符，最后是一个可变长度的参数，来一一替换前面的占位符</li>
<li>也可以前面使用name={name}这种形式，最后一个参数是一个map，map的key即为前边占位符的名字，map的value为参数值</li>
</ul>
<h2><span id="第二种getforobject">第二种：getForObject</span></h2><p>getForObject函数实际上是对getForEntity函数的进一步封装，如果你只关注返回的消息体的内容，对其他信息都不关注，此时可以使用getForObject，举一个简单的例子，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/book2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">book2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book = restTemplate.getForObject(<span class="string">"http://HELLO-SERVICE/getbook1"</span>, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="post请求">POST请求</span></h1><p>在 RestTemplate 中，POST 请求可以通过如下三个方法发起：</p>
<h2><span id="第一种postforentity">第一种：postForEntity</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/book3"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">book3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book();</span><br><span class="line">    book.setName(<span class="string">"红楼梦"</span>);</span><br><span class="line">    ResponseEntity&lt;Book&gt; responseEntity = restTemplate.postForEntity(<span class="string">"http://HELLO-SERVICE/getbook2"</span>, book, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> responseEntity.getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数表示要调用服务的地址</li>
<li>第二个参数表示上传的参数</li>
<li>第三个参数表示返回的消息体的数据类型</li>
</ul>
<p>我这里创建了一个Book对象，这个Book对象只有name属性有值，将之传递到服务提供者那里去，服务提供者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/getbook2"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">book2</span><span class="params">(@RequestBody Book book)</span> </span>&#123;</span><br><span class="line">    System.out.println(book.getName());</span><br><span class="line">    book.setPrice(<span class="number">33</span>);</span><br><span class="line">    book.setAuthor(<span class="string">"曹雪芹"</span>);</span><br><span class="line">    book.setPublisher(<span class="string">"人民文学出版社"</span>);</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="第二种postforobject">第二种：postForObject</span></h2><p>如果你只关注，返回的消息体，可以直接使用postForObject。用法和getForObject一致。</p>
<h2><span id="第三种postforlocation">第三种：postForLocation</span></h2><p>postForLocation也是提交新资源，提交成功之后，返回新资源的URI，postForLocation的参数和前面两种的参数基本一致，<strong>只不过该方法的返回值为Uri，这个只需要服务提供者返回一个Uri即可，该Uri表示新资源的位置。</strong></p>
<h1><span id="put-请求">PUT 请求</span></h1><p>在RestTemplate中，PUT请求可以通过put方法调用，put方法的参数和前面介绍的postForEntity方法的参数基本一致，只是put方法没有返回值而已。举一个简单的例子，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/put"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book();</span><br><span class="line">    book.setName(<span class="string">"红楼梦"</span>);</span><br><span class="line">    restTemplate.put(<span class="string">"http://HELLO-SERVICE/getbook3/&#123;1&#125;"</span>, book, <span class="number">99</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>book对象是我要提交的参数，最后的99用来替换前面的占位符{1}</p>
<h1><span id="delete请求">DELETE请求</span></h1><p>delete请求我们可以通过delete方法调用来实现，如下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restTemplate.delete(<span class="string">"http://HELLO-SERVICE/getbook4/&#123;1&#125;"</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="底层原理">底层原理</span></h1><p>todo：未完待续…</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>RestTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>Java保存副本文件到Centos服务器</title>
    <url>/2020/04/12/Java%E4%BF%9D%E5%AD%98%E5%89%AF%E6%9C%AC%E6%96%87%E4%BB%B6%E5%88%B0Centos%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>参考自：</p>
<p><a href="http://commons.apache.org/proper/commons-net/javadocs/api-1.4.1/org/apache/commons/net/ftp/FTPClient.html" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://www.jianshu.com/p/453829127487" target="_blank" rel="noopener">JAVA FTPClient FTP简单操作</a></p>
<p><a href="https://blog.51cto.com/andyxu/2168875" target="_blank" rel="noopener">Centos 7使用vsftpd搭建FTP服务器</a></p>
<p><a href="https://blog.csdn.net/JenMinZhang/article/details/9988001" target="_blank" rel="noopener">JAVA 程序实现文件到linux服务的上传与下载</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52044369" target="_blank" rel="noopener">Centos7.5搭建FTP服务-vsftpd（详细）</a></p>
<p><a href="https://www.jianshu.com/p/05dc6455b513" target="_blank" rel="noopener">CentOS 7 安装 FTP 服务</a></p>
<p><a href="https://blog.csdn.net/zhangzhao199443/article/details/79771431" target="_blank" rel="noopener">Java利用ftp协议上传文件到linux服务器</a></p>
<h1><span id="centos-安装-ftp">CentOS 安装 FTP</span></h1><h2><span id="安装vsftpd">安装vsftpd</span></h2><p>安装前先查看 ftp 是否已经安装，使用 yum 安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span><span class="bash"> vsftpd -v</span></span><br><span class="line"><span class="meta">shell&gt;</span><span class="bash"> yum -y install vsftpd</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2><span id="修改vsftp配置文件禁止匿名登录">修改vsftp配置文件，禁止匿名登录</span></h2><p>根据自己需求，修改 ftp 配置文件 <code>/etc/vsftpd/vsftpd.conf</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200412183810729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="166"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anonymous_enable&#x3D;NO    # 是否允许匿名访问</span><br><span class="line">local_enable&#x3D;YES      # 是否允许使用本地帐户进行 FTP 用户登录验证</span><br><span class="line">local_umask&#x3D;022      # 设置本地用户默认文件掩码022</span><br><span class="line">chroot_local_user&#x3D;YES   # 是否限定用户在其主目录下（NO 表示允许切换到上级目录）</span><br><span class="line">#chroot_list_enable&#x3D;YES # 是否启用限制用户的名单（注释掉为禁用）</span><br><span class="line">chroot_list_file&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;chroot_list # 用户列表文件（一行一个用户）</span><br><span class="line">allow_writeable_chroot&#x3D;YES # 如果启用了限定用户在其主目录下需要添加这个配置，解决报错 500 OOPS: vsftpd: refusing to run with writable root inside chroot()</span><br><span class="line">xferlog_enable&#x3D;YES     # 启用上传和下载的日志功能，默认开启。</span><br><span class="line">use_localtime&#x3D;YES     # 是否使用本地时(自行添加)</span><br><span class="line">userlist_enable&#x3D;YES</span><br></pre></td></tr></table></figure>

<p><strong>如果需要上传到指定目录的话，可以在配置文件中加入以下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_root&#x3D;&#x2F;home&#x2F;xxx&#x2F;</span><br></pre></td></tr></table></figure>

<h2><span id="设置vsftpd服务开机自启">设置vsftpd服务，开机自启</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable vsftpd</span><br></pre></td></tr></table></figure>

<h2><span id="启动vsftpd服务">启动vsftpd服务</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start vsftpd.service</span><br></pre></td></tr></table></figure>

<h2><span id="在防火墙中开启21端口号这里使用的是centos7以后的版本">在防火墙中开启21端口号（这里使用的是CentOs7以后的版本）</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=ftp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2><span id="添加用户">添加用户</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd ftpuser</span><br><span class="line">passwd ftpuser</span><br></pre></td></tr></table></figure>

<h1><span id="通过-ftp协议完成文件上传">通过 ftp协议完成文件上传</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.net.ftp.FTPClient;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> FTPClient <span class="title">getFtpClient</span><span class="params">(String ftpHost,<span class="keyword">int</span> ftpPort,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String ftpUserName,String ftpPassword)</span> <span class="keyword">throws</span> ApiRestException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FTPClient ftp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ftp = <span class="keyword">new</span> FTPClient();</span><br><span class="line">        <span class="comment">//登录ftp</span></span><br><span class="line">        ftp.connect(ftpHost,ftpPort);</span><br><span class="line">        ftp.login(ftpUserName,ftpPassword);</span><br><span class="line">        <span class="comment">//设置超时时间,5000毫秒</span></span><br><span class="line">        ftp.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">//设置中文编码集，防止中文乱码</span></span><br><span class="line">        ftp.setControlEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!FTPReply.isPositiveCompletion(ftp.getReplyCode()))&#123;</span><br><span class="line">            log.info(<span class="string">"Ftp服务器 拒绝连接"</span>);</span><br><span class="line">            ftp.disconnect();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">"ftp连接成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApiRestException(e.toString(),<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApiRestException(e.toString(),<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ftp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">closeFTP</span><span class="params">(FTPClient ftp)</span> <span class="keyword">throws</span> ApiRestException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ftp.logout();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.info(<span class="string">"ftp 关闭失败"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApiRestException(e.toString(),<span class="number">500</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ftp.isConnected())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ftp.disconnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"ftp关闭失败"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ApiRestException(e.toString(),<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveXXXAsFile</span><span class="params">()</span> <span class="keyword">throws</span> ApiRestException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    String baseDir = <span class="string">"/home/xxx"</span> + sdf.format(date);</span><br><span class="line">    String filename = System.currentTimeMillis() + <span class="string">".json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL nlpUrl = <span class="keyword">new</span> URL(<span class="string">"xxx"</span>);</span><br><span class="line">        URLConnection urlConn = nlpUrl.openConnection();</span><br><span class="line"></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(urlConn.getInputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        FTPClient ftpClient = getFtpClient(<span class="string">"192.168.x.x"</span>, <span class="number">21</span>,</span><br><span class="line">                                           <span class="string">"ftpuser"</span>, <span class="string">"ftpuser"</span>);</span><br><span class="line"></span><br><span class="line">        ftpClient.changeWorkingDirectory(baseDir);</span><br><span class="line">        ftpClient.setBufferSize(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);</span><br><span class="line">        ftpClient.storeFile(filename, bis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        bis.close();</span><br><span class="line">        closeFTP(ftpClient);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"uploadFileError:&#123;&#125;"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApiRestException(e.getMessage(),<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果当前目录存在的话，b1会返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = ftpClient.changeWorkingDirectory(baseDir);<span class="comment">//b1 = true</span></span><br></pre></td></tr></table></figure>



<h1><span id="ftp应答码amp响应码">FTP应答码&amp;响应码</span></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110： 重新启动标记应答。 </span><br><span class="line">120： 在n分钟内准备好 </span><br><span class="line">125： 连接打开准备传送 </span><br><span class="line">150： 打开数据连接</span><br><span class="line">200： 命令成功</span><br><span class="line">202： 命令失败</span><br><span class="line">211： 系统状态</span><br><span class="line">212： 目录状态</span><br><span class="line">213： 文件状态</span><br><span class="line">214： 帮助信息</span><br><span class="line">215： 名字系统类型 </span><br><span class="line">220： 新用户服务准备好了 </span><br><span class="line">221： 服务关闭控制连接，可以退出登录 </span><br><span class="line">225： 数据连接打开，无传输正在进行 </span><br><span class="line">226： 关闭数据连接，请求的文件操作成功 </span><br><span class="line">227： 进入被动模式 </span><br><span class="line">230： 用户登录 </span><br><span class="line">250： 请求的文件操作完成 </span><br><span class="line">257： 创建&quot;PATHNAME&quot; </span><br><span class="line">331： 用户名正确，需要口令 </span><br><span class="line">332： 登录时需要帐户信息 </span><br><span class="line">350： 下一步命令 </span><br><span class="line">421： 不能提供服务，关闭控制连接 </span><br><span class="line">425： 不能打开数据连接 </span><br><span class="line">426： 关闭连接，中止传输 </span><br><span class="line">450： 请求的文件操作未执行 </span><br><span class="line">451： 中止请求的操作：有本地错误 </span><br><span class="line">452： 未执行请求的操作：系统存储空间不足 </span><br><span class="line">500： 格式错误，命令不可识别 </span><br><span class="line">501： 参数语法错误 </span><br><span class="line">502： 命令未实现 </span><br><span class="line">503： 命令顺序错误 </span><br><span class="line">504： 此参数下的命令功能未实现 </span><br><span class="line">530： 未登录 </span><br><span class="line">532： 存储文件需要帐户信息 </span><br><span class="line">550： 未执行请求的操作 </span><br><span class="line">551： 请求操作中止：页类型未知 </span><br><span class="line">552： 请求的文件操作中止，存储分配溢出 </span><br><span class="line">553： 未执行请求的操作：文件名不合法</span><br><span class="line"></span><br><span class="line">FTP术语 </span><br><span class="line">150　　　 文件状态良好，打开数据连接 </span><br><span class="line">200　　　 命令成功 </span><br><span class="line">202　　　 命令未实现 </span><br><span class="line">211　　　 系统状态或系统帮助响应 </span><br><span class="line">212　　　 目录状态 </span><br><span class="line">213　　　 文件状态 </span><br><span class="line">214　　　 帮助信息，信息仅对人类用户有用 </span><br><span class="line">215　　　 名字系统类型 </span><br><span class="line">220　　　 对新用户服务准备好 </span><br><span class="line">221　　　 服务关闭控制连接，可以退出登录 </span><br><span class="line">225　　　 数据连接打开，无传输正在进行 </span><br><span class="line">226　　　 关闭数据连接，请求的文件操作成功 </span><br><span class="line">227　　　 进入被动模式 </span><br><span class="line">230　　　 用户登录 </span><br><span class="line">250　　　 请求的文件操作完成 </span><br><span class="line">257　　　 创建&quot;PATHNAME&quot; </span><br><span class="line">331　　　 用户名正确，需要口令 </span><br><span class="line">332　　　 登录时需要帐户信息 </span><br><span class="line">350　　　 请求的文件操作需要进一步命令 </span><br><span class="line">421　　　 连接用户过多 </span><br><span class="line">425　　　 不能打开数据连接 </span><br><span class="line">426　　　 关闭连接，中止传输 </span><br><span class="line">450 　　　请求的文件操作未执行 </span><br><span class="line">451 　　　中止请求的操作：有本地错误 </span><br><span class="line">452 　　　未执行请求的操作：系统存储空间不足 </span><br><span class="line">500 　　　格式错误，命令不可识别 </span><br><span class="line">501 　　　参数语法错误 </span><br><span class="line">502 　　　命令未实现 </span><br><span class="line">503 　　　命令顺序错误 </span><br><span class="line">504　　　 此参数下的命令功能未实现 </span><br><span class="line">530 　　　账号或密码错误 </span><br><span class="line">532 　　　存储文件需要帐户信息 </span><br><span class="line">550 　　　未执行请求的操作</span><br><span class="line">551　　　 请求操作中止：页类型未知 </span><br><span class="line">552　　　 请求的文件操作中止，存储分配溢出 </span><br><span class="line">553　　　 未执行请求的操作：文件名不合法</span><br></pre></td></tr></table></figure>

<h1><span id="结果">结果</span></h1><p><img src="https://img-blog.csdnimg.cn/20200412183851385.png#pic_center" alt="167"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CentOS</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之异步编程</title>
    <url>/2020/04/06/SpringBoot%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>参考自：</p>
<p><a href="https://github.com/Snailclimb/springboot-guide/blob/master/docs/advanced/springboot-async.md" target="_blank" rel="noopener">新手也能看懂的 SpringBoot 异步编程指南</a></p>
<h1><span id="future-模式">Future 模式</span></h1><p>异步编程在处理耗时操作以及多任务处理的场景下非常有用，我们可以更好的让我们的系统利用好机器的 CPU 和 内存，提高它们的利用率。多线程设计模式有很多种，Future模式是多线程开发中非常常见的一种设计模式。</p>
<p>先简单介绍一下 <strong>Future 模式的核心思想</strong> 吧！</p>
<blockquote>
<p>Future 模式的核心思想是 <strong>异步调用</strong> 。当我们执行一个方法时，假如这个方法中有多个耗时的任务需要同时去做，而且又不着急等待这个结果时可以让客户端立即返回，然后后台慢慢去计算任务。当然你也可以选择等这些任务都执行完了，再返回给客户端。这个在 Java 中都有很好的支持，我在后面的示例程序中会详细对比这两种方式的区别。</p>
</blockquote>
<a id="more"></a>

<h1><span id="实战">实战</span></h1><p>如果我们需要在 SpringBoot 实现异步编程的话，通过 Spring 提供的两个注解会让这件事情变的非常简单。</p>
<ul>
<li><code>@EnableAsync</code>：通过在 <strong>配置类</strong> 或者 <strong>Main类</strong> 上加@EnableAsync开启对异步方法的支持。</li>
<li><code>@Async</code>：可以作用在 <strong>类</strong> 上或者 <strong>方法</strong> 上，作用在类上代表这个类的所有方法都是异步方法。</li>
</ul>
<h2><span id="自定义-taskexecutor">自定义 TaskExecutor</span></h2><p>从名字就能看出它是任务的执行者，它领导执行着线程来处理任务，就像司令官一样，而我们的线程就好比一只只军队一样，这些军队可以异步对敌人进行打击。</p>
<p>Spring 提供了<code>TaskExecutor</code>接口作为任务执行者的抽象,它和<code>java.util.concurrent</code>包下的<code>Executor</code>接口很像。稍微不同的 <code>TaskExecutor</code>接口用到了 Java 8 的语法<code>@FunctionalInterface</code>声明这个接口是一个函数式接口。</p>
<p><code>org.springframework.core.task.TaskExecutor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskExecutor</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>todo：未完成，继续。。。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之Interceptor</title>
    <url>/2020/04/06/SpringBoot%E4%B9%8BInterceptor/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://github.com/Snailclimb/springboot-guide/blob/master/docs/basis/springboot-interceptor.md" target="_blank" rel="noopener">Interceptor介绍</a></p>
<p><strong>拦截器(Interceptor)</strong> 同 Filter(过滤器) 一样，它俩都是面向切面编程——AOP 的具体实现（AOP切面编程只是一种编程思想而已）。</p>
<p>你可以使用 Interceptor 来执行某些任务，例如在 <strong>Controller</strong> 处理请求之前编写日志，添加或更新配置……</p>
<p>在 <strong>Spring中</strong>，当请求发送到 <strong>Controller</strong> 时，在被<strong>Controller</strong>处理之前，它必须经过 <strong>Interceptors</strong>（0或更多）。</p>
<p><strong>Spring Interceptor</strong>是一个非常类似于<strong>Servlet Filter</strong> 的概念 。</p>
<a id="more"></a>

<h1><span id="过滤器和拦截器的区别">过滤器和拦截器的区别</span></h1><p>对于过滤器和拦截器的区别：</p>
<ul>
<li><strong>过滤器(Filter)：</strong>当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。</li>
<li><strong>拦截器(Interceptor)：</strong>在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。</li>
</ul>
<h1><span id="自定义-interceptor">自定义 Interceptor</span></h1><p>如果你需要自定义 <strong>Interceptor</strong> 的话必须实现 <strong>org.springframework.web.servlet.HandlerInterceptor</strong>接口或继承 <strong>org.springframework.web.servlet.handler.HandlerInterceptorAdapter</strong>类，并且需要重写下面下面3个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object handler)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                       HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ModelAndView modelAndView)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Exception ex)</span></span></span><br></pre></td></tr></table></figure>

<p>注意： <strong><em>preHandle</em></strong>方法返回 <strong>true</strong>或 <strong>false</strong>。如果返回 <strong>true</strong>，则意味着请求将继续到达 <strong>Controller</strong> 被处理。</p>
<p><img src="https://img-blog.csdnimg.cn/20200406225518922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="162"></p>
<p><strong><code>LogInterceptor</code>用于过滤所有请求</strong></p>
<p><strong><code>OldLoginInterceptor</code></strong> 是一个拦截器，如果用户输入已经被废弃的链接 <code>/admin/oldLogin</code> ，它将重定向到新的 <code>/admin/login</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200406225549735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="163"></p>
<p><img src="https://img-blog.csdnimg.cn/20200406225655909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="164"></p>
<p><strong><code>AdminInterceptor</code></strong>用于拦截请求路径为 <code>/admin/*</code> 下的请求</p>
<p>配置拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LogInterceptor apply to all URLs.</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LogInterceptor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Old Login url, no longer use.</span></span><br><span class="line">        <span class="comment">// Use OldURLInterceptor to redirect to a new URL.</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> OldLoginInterceptor())</span><br><span class="line">            .addPathPatterns(<span class="string">"/admin/oldLogin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This interceptor apply to URL like /admin/*</span></span><br><span class="line">        <span class="comment">// Exclude /admin/oldLogin</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> AdminInterceptor())</span><br><span class="line">            .addPathPatterns(<span class="string">"/admin/*"</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">"/admin/oldLogin"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合<strong>自定义 Controller 验证拦截器</strong>，完成测试，具体请看源码: <a href="https://gitee.com/mikeLv01/security-interceptor-demo.git" target="_blank" rel="noopener">https://gitee.com/mikeLv01/security-interceptor-demo.git</a></p>
<p><strong>注意：该实例需要引入 thymeleaf 的依赖，否则报错</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="结果">结果：</span></h2><p>测试用户访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 的时候， <strong>LogInterceptor</strong>记录相关信息（页面地址，访问时间），并计算 <strong>Web服务器</strong>处理请求的时间。另外，页面会被渲染成 <code>test.html</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200406225717264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="165"></p>
<p>当用户访问 <a href="http://localhost:8080/admin/oldLogin" target="_blank" rel="noopener">http://localhost:8080/admin/oldLogin</a> 也就是旧的登录页面（不再使用）时， <strong>OldLoginInterceptor</strong>将请求重定向 <a href="http://localhost:8080/admin/login" target="_blank" rel="noopener">http://localhost:8080/admin/login</a> 页面会被渲染成正常的登录页面 <code>login.html</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Request URL: http://localhost:8088/admin/oldLogin</span><br><span class="line"><span class="keyword">Start</span> <span class="built_in">Time</span>: <span class="number">1586184588848</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-------- OldLoginInterceptor.preHandle --- </span></span><br><span class="line">Request <span class="keyword">URL</span>: <span class="keyword">http</span>://localhost:<span class="number">8088</span>/<span class="keyword">admin</span>/oldLogin</span><br><span class="line">Sorry! This <span class="keyword">URL</span> <span class="keyword">is</span> <span class="keyword">no</span> longer used, Redirect <span class="keyword">to</span> /<span class="keyword">admin</span>/login</span><br><span class="line"></span><br><span class="line"><span class="comment">-------- LogInterception.afterCompletion --- </span></span><br><span class="line">Request <span class="keyword">URL</span>: <span class="keyword">http</span>://localhost:<span class="number">8088</span>/<span class="keyword">admin</span>/oldLogin</span><br><span class="line"><span class="keyword">End</span> <span class="built_in">Time</span>: <span class="number">1586184588849</span></span><br><span class="line"><span class="built_in">Time</span> Taken: <span class="number">1</span></span><br><span class="line">Request <span class="keyword">URL</span>: <span class="keyword">http</span>://localhost:<span class="number">8088</span>/<span class="keyword">admin</span>/login</span><br><span class="line"><span class="keyword">Start</span> <span class="built_in">Time</span>: <span class="number">1586184588857</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-------- AdminInterceptor.preHandle --- </span></span><br><span class="line"></span><br><span class="line"><span class="comment">-------- MainController.login --- </span></span><br><span class="line"> ** You <span class="keyword">are</span> <span class="keyword">in</span> Controller ** </span><br><span class="line"></span><br><span class="line"><span class="comment">-------- AdminInterceptor.postHandle --- </span></span><br><span class="line"></span><br><span class="line"><span class="comment">-------- LogInterception.postHandle --- </span></span><br><span class="line">Request <span class="keyword">URL</span>: <span class="keyword">http</span>://localhost:<span class="number">8088</span>/<span class="keyword">admin</span>/login</span><br><span class="line"></span><br><span class="line"><span class="comment">-------- AdminInterceptor.afterCompletion --- </span></span><br><span class="line"></span><br><span class="line"><span class="comment">-------- LogInterception.afterCompletion --- </span></span><br><span class="line">Request <span class="keyword">URL</span>: <span class="keyword">http</span>://localhost:<span class="number">8088</span>/<span class="keyword">admin</span>/login</span><br><span class="line"><span class="keyword">End</span> <span class="built_in">Time</span>: <span class="number">1586184588860</span></span><br><span class="line"><span class="built_in">Time</span> Taken: <span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的锁机制</title>
    <url>/2020/04/04/Java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://mp.weixin.qq.com/s/B9zb3tzpNCL7T81TXgQs-w" target="_blank" rel="noopener">一次说清，Java 中的各种锁和 CAS 经典面试题</a></p>
<a id="more"></a>

<h1><span id="乐观锁和悲观锁">乐观锁和悲观锁</span></h1><p>悲观锁和乐观锁并不是某个具体的 “锁” 而是一种并发编程的基本概念。乐观锁和悲观锁最早出现在数据库的设计当中，后来逐渐被 Java 的并发包引入。</p>
<h2><span id="悲观锁">悲观锁</span></h2><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观地认为，不加锁的并发操作一定会出问题。</p>
<h2><span id="乐观锁">乐观锁</span></h2><p>乐观锁正好和悲观锁相反，它获取数据的时候，并不担心数据被修改，每次获取数据的时候也不会加锁，只是在更新数据的时候，通过判断现有的数据是否和原数据一致来判断数据是否被其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新。</p>
<h1><span id="公平锁和非公平锁">公平锁和非公平锁</span></h1><h2><span id="公平锁">公平锁</span></h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁</p>
<h2><span id="非公平锁">非公平锁</span></h2><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。ReetrantLock 提供了公平锁和非公平锁的实现。</p>
<ul>
<li><strong>公平锁</strong>：<code>new ReentrantLock(true)</code></li>
<li><strong>非公平锁：</strong><code>new ReentrantLock(false)</code></li>
</ul>
<p>如果构造函数不传任何参数的时候，默认提供的是非公平锁。</p>
<h1><span id="独占锁和共享锁">独占锁和共享锁</span></h1><p>根据锁能否被多个线程持有，可以把锁分为独占锁和共享锁</p>
<h2><span id="独占锁">独占锁</span></h2><p>独占锁是指任何时候都只有一个线程能执行资源操作</p>
<h2><span id="共享锁">共享锁</span></h2><p>共享锁指定市可以同时被多个线程读取，但只能被一个线程修改。比如 Java 中的 ReentrantReadWriteLock 就是共享锁的实现方式，它允许一个线程进行读写操作，允许多个线程读操作。</p>
<p>ReentrantReadWriteLock 共享锁演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyReadWriteLock rwLock = <span class="keyword">new</span> MyReadWriteLock();</span><br><span class="line">        <span class="comment">// 创建读锁 r1 和 r2</span></span><br><span class="line">        Thread r1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"r1"</span>);</span><br><span class="line">        Thread r2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"r2"</span>);</span><br><span class="line">        r1.start();</span><br><span class="line">        r2.start();</span><br><span class="line">        <span class="comment">// 等待同时读取线程执行完成</span></span><br><span class="line">        r1.join();</span><br><span class="line">        r2.join();</span><br><span class="line">        <span class="comment">// 开启写锁的操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"w1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"w2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadWriteLock</span> </span>&#123;</span><br><span class="line">        ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"读操作，进入 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"读操作，退出 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"写操作，进入 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"写操作，退出 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">读操作，进入 <span class="string">| 线程：r1</span></span><br><span class="line">读操作，进入 <span class="string">| 线程：r2</span></span><br><span class="line">读操作，退出 <span class="string">| 线程：r1</span></span><br><span class="line">读操作，退出 <span class="string">| 线程：r2</span></span><br><span class="line">写操作，进入 <span class="string">| 线程：w1</span></span><br><span class="line">写操作，退出 <span class="string">| 线程：w1</span></span><br><span class="line">写操作，进入 <span class="string">| 线程：w2</span></span><br><span class="line">写操作，退出 <span class="string">| 线程：w2</span></span><br></pre></td></tr></table></figure>

<h1><span id="可重入锁">可重入锁</span></h1><p>可重入锁指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码</p>
<h1><span id="自旋锁">自旋锁</span></h1><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采取循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU</p>
<h1><span id="cas-与-aba">CAS 与 ABA</span></h1><p>CAS（Compare and Swap）比较并交换，是一种乐观锁的实现，是用非阻塞算法来代替锁定，其中 java.util.concurrent 包下的 AtomicInteger 就是借助 CAS 来实现的。</p>
<p>但 CAS 也不是没有任何副作用，比如著名的 ABA 问题就是 CAS 引起的。</p>
<h2><span id="aba-问题描述">ABA 问题描述</span></h2><p>老王去银行取钱，余额有 200 元，老王取 100 元，但因为程序的问题，启动了两个线程，线程一和线程二进行比对扣款，线程一获取原本有 200 元，扣除 100 元，余额等于 100 元，此时阿里给老王转账 100 元，于是启动了线程三抢先在线程二之前执行了转账操作，把 100 元又变成了 200 元，而此时线程二对比自己事先拿到的 200 元和此时经过改动的 200 元值一样，就进行了减法操作，把余额又变成了 100 元。这显然不是我们要的正确结果，我们想要的结果是余额减少了 100 元，又增加了 100 元，余额还是 200 元，而此时余额变成了 100 元，显然有悖常理，这就是著名的 ABA 的问题。</p>
<p>执行流程如下。</p>
<ul>
<li>线程一：取款，获取原值 200 元，与 200 元比对成功，减去 100 元，修改结果为 100 元。</li>
<li>线程二：取款，获取原值 200 元，阻塞等待修改。</li>
<li>线程三：转账，获取原值 100 元，与 100 元比对成功，加上 100 元，修改结果为 200 元。</li>
<li>线程二：取款，恢复执行，原值为 200 元，与 200 元对比成功，减去 100 元，修改结果为 100 元。</li>
</ul>
<p>最终的结果是 100 元。</p>
<h2><span id="aba-问题解决">ABA 问题解决</span></h2><p>常见解决 ABA 问题的方案加版本号，来区分值是否有变动。以老王取钱的例子为例，如果加上版本号，执行流程如下。</p>
<ul>
<li>线程一：取款，获取原值 200_V1，与 200_V1 比对成功，减去 100 元，修改结果为 100_V2。</li>
<li>线程二：取款，获取原值 200_V1 阻塞等待修改。</li>
<li>线程三：转账，获取原值 100_V2，与 100_V2 对比成功，加 100 元，修改结果为 200_V3。</li>
<li>线程二：取款，恢复执行，原值 200_V1 与现值 200_V3 对比不相等，退出修改。</li>
</ul>
<p>最终的结果为 200 元，这显然是我们需要的结果。</p>
<p>在程序中，要怎么解决 ABA 的问题呢？</p>
<p>在 JDK 1.5 的时候，Java 提供了一个 AtomicStampedReference 原子引用变量，通过添加版本号来解决 ABA 的问题，具体使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"老王"</span>;</span><br><span class="line">String newName = <span class="string">"Java"</span>;</span><br><span class="line">AtomicStampedReference&lt;String&gt; as = <span class="keyword">new</span> AtomicStampedReference&lt;String&gt;(name, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"值："</span> + as.getReference() + <span class="string">" | Stamp："</span> + as.getStamp());</span><br><span class="line">as.compareAndSet(name, newName, as.getStamp(), as.getStamp() + <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"值："</span> + as.getReference() + <span class="string">" | Stamp："</span> + as.getStamp());</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">值：老王 <span class="string">| Stamp：1</span></span><br><span class="line">值：Java <span class="string">| Stamp：2</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java映射类之HashMap</title>
    <url>/2020/04/02/Java%E6%98%A0%E5%B0%84%E7%B1%BB%E4%B9%8BHashMap/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=21#wechat_redirect" target="_blank" rel="noopener">漫画：什么是HashMap？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192000&idx=1&sn=118cee6d1c67e7b8e4f762af3e61643e&chksm=8c990d9abbee848c739aeaf25893ae4382eca90642f65fc9b8eb76d58d6e7adebe65da03f80d&scene=21#wechat_redirect" target="_blank" rel="noopener">漫画：高并发下的HashMap</a></p>
<a id="more"></a>

<p>todo: 未完待续。。。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java映射类之ConcurrentHashMap</title>
    <url>/2020/04/02/Java%E6%98%A0%E5%B0%84%E7%B1%BB%E4%B9%8BConcurrentHashMap/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://zhuanlan.zhihu.com/p/31614308" target="_blank" rel="noopener">漫画：什么是ConcurrentHashMap？</a></p>
<p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></p>
<p>先来回顾下 HashMap 的结构</p>
<p><img src="https://img-blog.csdnimg.cn/2020040213274063.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="148"></p>
<a id="more"></a>

<p>简单来说，HashMap 是一个 <strong>Entry对象的数组</strong>。数组中的每一个 Entry 元素，又是一个链表的头节点。</p>
<p>HashMap 不是线程安全的，在高并发环境下做插入操作，有可能出现下面的环形链表：</p>
<p><img src="https://img-blog.csdnimg.cn/20200402132756710.jpg#pic_center" alt="149"></p>
<p>想要避免 HashMap 的线程安全问题有很多办法，比如改用 <strong><em>HashTable</em></strong> 或者 <strong><em>Collections.synchronizedMap</em></strong>. 但是这两者有着共同的问题：性能。无论读操作还是写操作，都会给整个集合加锁，导致同一时间的其他操作称之为阻塞。</p>
<p><img src="https://img-blog.csdnimg.cn/20200402132813137.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="150"></p>
<p><img src="https://img-blog.csdnimg.cn/20200402132830132.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="151"></p>
<h1><span id="concurrenthashmapjdk17">ConcurrentHashMap(jdk1.7)</span></h1><h2><span id="segement">Segement</span></h2><p>segement 是什么？Segement 本身就相当于一个 HashMap 对象。</p>
<p>同 HashMap 一样，Segement 包含一个 <strong><em>HashEntry</em></strong> 数组，数组中每一个 HashEntry 既是一个键值对，也是一个链表的头节点。</p>
<p>单一的 Segement 结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200402132848808.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="152"></p>
<p>像这样的Segment对象，在ConcurrentHashMap集合中有多少个呢？有2的N次方个，共同保存在一个名为segments的数组当中。</p>
<p>因此整个ConcurrentHashMap的结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200402132907172.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="153"></p>
<p>可以说，ConcurrentHashMap 是一个<strong><em>二级哈希表</em></strong>。<u>在一个总的哈希表下面，有若干个子哈希表</u>。</p>
<p>这样的二级结构，和数据库的水平拆分有些相似。</p>
<p>ConcurrentHashMap 这样设计有什么好处？</p>
<p><img src="https://img-blog.csdnimg.cn/2020040213292369.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="154"></p>
<h2><span id="并发读写">并发读写</span></h2><h3><span id="case1不同的-segment-的并发写入">case1：不同的 Segment 的并发写入</span></h3><p><img src="https://img-blog.csdnimg.cn/20200402132948803.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="155"></p>
<p>不同的 Segment 的写入是可以并发执行的</p>
<h3><span id="case2同一个-segment-的一写一读">Case2：同一个 Segment 的一写一读</span></h3><p><img src="https://img-blog.csdnimg.cn/20200402133003507.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="156"></p>
<p>同一 Segment 的写和读是可以并发执行的</p>
<h3><span id="case3同一-segment-的并发写入">Case3：同一 Segment 的并发写入</span></h3><p><img src="https://img-blog.csdnimg.cn/20200402133018758.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="157"></p>
<p>Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。</p>
<p><strong>总结：</strong> 由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p>
<h2><span id="读写详细过程">读写详细过程</span></h2><h3><span id="get-方法">Get 方法：</span></h3><ol>
<li>为输入的 key 做 <strong>hash运算</strong>，得到 hash 值</li>
<li>通过hash值，定位到对应的Segment对象</li>
<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>
</ol>
<h3><span id="put-方法">Put 方法：</span></h3><ol>
<li>为输入的Key做Hash运算，得到hash值。</li>
<li>通过hash值，定位到对应的Segment对象</li>
<li>获取可重入锁</li>
<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>
<li>插入或覆盖HashEntry对象。</li>
<li>释放锁。</li>
</ol>
<p>从步骤可以看出，ConcurrentHashMap 在读写时需要二次定位，首先定位到 Segment，之后定位到 Segment 内的具体数组下标</p>
<h2><span id="size-一致性问题">size() 一致性问题</span></h2><p>Size方法的目的是统计ConcurrentHashMap的总元素数量， 自然需要把各个Segment内部的元素数量汇总起来。</p>
<p>但是，如果在统计Segment元素数量的过程中，已统计过的Segment瞬间插入新的元素，这时候该怎么办呢？</p>
<p><img src="https://img-blog.csdnimg.cn/20200402133036205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="158"></p>
<p><img src="https://img-blog.csdnimg.cn/20200402133051916.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="159"></p>
<p><img src="https://img-blog.csdnimg.cn/20200402133110649.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="160"></p>
<p>ConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：</p>
<ol>
<li>遍历所有的Segment.</li>
<li>把Segment的元素数量累加起来。</li>
<li>把Segment的修改次数累加起来。</li>
<li>判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li>
<li>如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。</li>
<li>再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。</li>
<li>释放锁，统计结束。</li>
</ol>
<h3><span id="源码">源码</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">   <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之Filter</title>
    <url>/2020/04/01/SpringBoot%E4%B9%8BFilter/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://github.com/Snailclimb/springboot-guide/blob/master/docs/basis/springboot-filter.md" target="_blank" rel="noopener">Filter介绍</a></p>
<blockquote>
<p>Filter 过滤器主要是用来过滤用户请求的，它允许我们对用户请求进行前置处理和后置处理，比如实现 URL 级别的权限控制，过滤非法请求等等。Filter 过滤器是面向切面编程 — AOP具体实现</p>
</blockquote>
<a id="more"></a>

<p>Filter 是依赖于 Servlet 容器，<code>Filter</code> 接口就在 Servlet 包下面，属于 Servlet 规范的一部分。所以，很多时候我们也称其为“增强版 Servlet”。</p>
<p>如果我们需要自定义 Filter 的话非常简单，只需要实现 <code>javax.Servlet.Filter</code> 接口，然后重写里面的三个方法即可！</p>
<p>Filter.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//初始化过滤器后执行的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 对请求进行过滤</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest var1, ServletResponse var2, FilterChain var3)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">   <span class="comment">// 销毁过滤器后执行的操作，主要用户对某些资源的回收</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="filter-是如何实现拦截的">Filter 是如何实现拦截的？</span></h1><p><code>Filter</code> 接口中有一个叫做 <code>doFilter</code> 的方法，这个方法实现了对用户请求的过滤。具体流程大体是这样的：</p>
<ol>
<li>用户发送请求到 web 服务器，请求会先到过滤器；</li>
<li>过滤器会对请求进行一些处理比如过滤请求的参数、修改返回给客户端的 response 的内容、判断是否让用户访问该接口等等。</li>
<li>用户请求响应完毕</li>
<li>进行一些自己想要的其他操作</li>
</ol>
<h1><span id="如何自定义-filter">如何自定义 Filter</span></h1><h2><span id="webfilter-注解">@WebFilter 注解</span></h2><p>@WebFilter 用于将一个类声明为过滤器，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为过滤器。该注解具有下表给出的一些常用属性 ( 以下所有属性均为可选属性，但是 value、urlPatterns、servletNames 三者必需至少包含一个，且 value 和 urlPatterns 不能共存，如果同时指定，通常忽略 value 的取值 )</p>
<h2><span id="示例">示例</span></h2><p><a href="https://gitee.com/mikeLv01/security-filter-demo.git" target="_blank" rel="noopener">https://gitee.com/mikeLv01/security-filter-demo.git</a></p>
<p>结果示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200406151727685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="161"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全之跨域请求</title>
    <url>/2020/04/01/Web%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://www.jianshu.com/p/f880878c1398" target="_blank" rel="noopener">什么是跨域请求以及实现跨域的方案</a></p>
<h1><span id="什么是跨域请求">什么是跨域请求</span></h1><h2><span id="概述">概述</span></h2><p>在 Html 中，<code>&lt;a&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;img&gt;</code>,  <code>&lt;script&gt;</code>,  <code>&lt;iframe&gt;</code>,  <code>&lt;link&gt;</code>  等标签以及 Ajax 都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。</p>
<p>举个例子：假如一个域名为<code>aaa.cn</code>的网站，它发起一个资源路径为<code>aaa.cn/books/getBookInfo</code>的 Ajax 请求，那么这个请求是同域的，因为资源路径的协议、域名以及端口号与当前域一致（例子中协议名默认为http，端口号默认为80）。但是，如果发起一个资源路径为<code>bbb.com/pay/purchase</code>的 Ajax 请求，那么这个请求就是跨域请求，因为域不一致，与此同时由于安全问题，这种请求会受到同源策略限制。</p>
<a id="more"></a>

<h2><span id="跨域请求的安全问题">跨域请求的安全问题</span></h2><p>通常，浏览器会对上面提到的跨域请求作出限制。浏览器之所以要对跨域请求作出限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动 <strong>CSRF</strong>攻击。</p>
<h3><span id="csrf">CSRF</span></h3><p>   CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p>
<p>   CSRF 攻击的原理大致描述如下：有两个网站，其中A网站是真实受信任的网站，而B网站是危险网站。在用户登陆了受信任的A网站是，本地会存储A网站相关的Cookie，并且浏览器也维护这一个Session会话。这时，如果用户在没有登出A网站的情况下访问危险网站B，那么危险网站B就可以模拟发出一个对A网站的请求（跨域请求）对A网站进行操作，而在A网站的角度来看是并不知道请求是由B网站发出来的（Session和Cookie均为A网站的），这时便成功发动一次CSRF 攻击。</p>
<p>   因而 CSRF 攻击可以简单理解为：攻击者盗用了你的身份，以你的名义发送而已请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p>
<p>   因此，大多数浏览器都会跨域请求作出限制，这是从浏览器层面上的对 CSRF 攻击的一种防御，但是需要注意的是在复杂的网络环境中借助浏览器来防御 CSRF 攻击并不足够，还需要从服务端或者客户端方面入手防御。详细可以参考这篇文章<a href="https://link.jianshu.com?t=http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a></p>
<h2><span id="同源策略sample-origin-policy">同源策略(Sample-Origin Policy)</span></h2><h3><span id="概述">概述</span></h3><ul>
<li><p>同源策略是 Netscape 提出的一个著名的安全策略</p>
</li>
<li><p>同源策略是浏览器最核心最基础的安全策略</p>
</li>
<li><p>现在所有的可支持 Javascript 的浏览器都会使用这个策略</p>
</li>
<li><p>web构建在同源策略基础之上，浏览器对非同源脚本的限制措施是对同源策略的具体实现</p>
</li>
</ul>
<h3><span id="同源策略的含义">同源策略的含义</span></h3><ul>
<li><p>DOM 层面的同源策略：限制了来自不同源的”Document”对象或 JS 脚本，对当前“document”对象的读取或设置某些属性</p>
</li>
<li><p>Cookie和XMLHttprequest层面的同源策略：禁止 Ajax 直接发起跨域HTTP请求（其实可以发送请求，结果被浏览器拦截，不展示），同时 Ajax 请求不能携带与本网站不同源的 Cookie。</p>
</li>
<li><p>同源策略的非绝对性：<code>&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;</code>等带有src属性的标签可以从不同的域加载和执行资源。</p>
</li>
<li><p>其他插件的同源策略：<code>flash、java applet、silverlight、googlegears</code>等浏览器加载的第三方插件也有各自的同源策略，只是这些同源策略不属于浏览器原生的同源策略，如果有漏洞则可能被黑客利用，从而留下XSS攻击的后患</p>
</li>
</ul>
<h3><span id="同源的具体含义">同源的具体含义</span></h3><p><strong>域名</strong>，<strong>协议</strong>，<strong>端口</strong> 有一个不同就不是同源，三者均相同，这两个网站才是同源</p>
<h2><span id="跨域解决方法">跨域解决方法</span></h2><p>虽然在安全层面上同源限制是必要的，但有时同源策略会对我们的合理用途造成影响，为了避免开发的应用受到限制，有多种方式可以绕开同源策略，下面介绍的是经常使用的 JSONP, CORS 方法。</p>
<h3><span id="jsonp">JSONP</span></h3><h4><span id="原理">原理</span></h4><ul>
<li>JSONP 是一种非官方的跨域数据交互协议</li>
<li>JSONP 本质上是利用 <code>&lt;script&gt;&lt;img&gt;&lt;iframe&gt;</code> 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输</li>
<li>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</li>
<li>JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段  Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。</li>
</ul>
<h4><span id="示例">示例</span></h4><p>首先当前页面中声明有这样的一个函数，它将作为 JSONP 的回调函数处理作为函数参数传入的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">dosomething</span><span class="params">(jsondata)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//处理获得的json数据</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，我们就可以借助 <code>&lt;img&gt;&lt;iframe&gt;</code> 等标签可以引入不同域资源的特性，将需要发送的请求的路径作为src参数，其中需要注意的是：需要告知服务端回调函数的函数名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://example.com/data.php?callback=dosomething"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时服务端在返回数据的时候，就会返回一端 Javascript 代码，在 Javascript代码中调用了回调函数，并且需要返回的数据作为回调函数的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dosomething([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);</span><br></pre></td></tr></table></figure>

<p>最后页面成功加载了刚才指定路径的资源后，将会执行该 Javascript 代码，<code>dosomething</code>函数将执行，这时一次跨域请求完成。</p>
<p>另外，如果页面引入了 jQuery，那么可以通过它封装的方法很方便的实现JSONP操作了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using YQL and JSONP</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"http://query.yahooapis.com/v1/public/yql"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The name of the callback parameter, as specified by the YQL service</span></span><br><span class="line">    jsonp: <span class="string">"callback"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell jQuery we're expecting JSONP</span></span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell YQL what we want and that we want JSON</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        q: <span class="string">"select title,abstract,url from search.news where query=\"cat\""</span>,</span><br><span class="line">        format: <span class="string">"json"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Work with the response</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params"> response </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( response ); <span class="comment">// server response</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4><span id="优缺点">优缺点</span></h4><p>JSONP 的优点是：它不像<code>XMLHttpRequest</code>对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行。</p>
<p>JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求</p>
<h3><span id="cors">CORS</span></h3><h4><span id="介绍">介绍</span></h4><p>跨源资源共享 <strong>Cross-Origin Resource Sharing(CORS)</strong> 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制。</p>
<p>另外，规范也要求对于非简单请求，浏览器必须首先使用 OPTION 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求，在服务器确定允许后，才发起实际的HTTP请求。对于简单请求、非简单请求以及预检请求的详细资料可以阅读<a href="https://link.jianshu.com?t=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a> 。</p>
<h4><span id="http-协议-header-简析">HTTP 协议 Header 简析</span></h4><p>下面对 CORS 中新增的 HTTP 首部字段进行简析：</p>
<ul>
<li><p>Access-Control-Allow-Origin</p>
<p>响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源，其语法如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: <span class="xml"><span class="tag">&lt;<span class="name">origin</span>&gt;</span> | *</span></span><br></pre></td></tr></table></figure>

<p>其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。</p>
</li>
<li><p>Access-Control-Allow-Methods</p>
<p>该首部字段用于预检请求的响应，指明实际请求所允许使用的HTTP方法。其语法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: <span class="tag">&lt;<span class="name">method</span>&gt;</span>[, <span class="tag">&lt;<span class="name">method</span>&gt;</span>]*</span><br></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Allow-Headers</p>
<p>该首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段。其语法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Headers: <span class="tag">&lt;<span class="name">field-name</span>&gt;</span>[, <span class="tag">&lt;<span class="name">field-name</span>&gt;</span>]*</span><br></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Max-Age</p>
<p>该首部字段用于预检请求的响应，指定了预检请求能够被缓存多久，其语法如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Access-Control-Max-Age: <span class="xml"><span class="tag">&lt;<span class="name">delta-seconds</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。其语法如下：</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>  另外，如果要把 Cookie 发送到服务器，除了服务端要带上<code>Access-Control-Allow-Credentials</code>首部字段外，另一方面请求中也要带上<code>withCredentials</code>属性。</p>
<p>  但是需要注意的是：如果需要在 Ajax 中设置和获取 Cookie，那么<code>Access-Control-Allow-Origin</code>首部字段不能设置为<code>*</code> ，必须设置为具体的 origin 源站。详细可阅读文章<a href="https://www.jianshu.com/p/13d53acc124f" target="_blank" rel="noopener">CORS 跨域 Cookie 的设置与获取</a></p>
<ul>
<li><p>Origin</p>
<p>该首部字段表明预检请求或实际请求的源站。不管是否为跨域请求，Origin字段总是被发送。其语法如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Origin: <span class="xml"><span class="tag">&lt;<span class="name">origin</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Request-Method</p>
<p>该首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。其语法如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Access-Control-Request-Method: <span class="xml"><span class="tag">&lt;<span class="name">method</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Request-Headers</p>
<p>该首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。其语法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Access-Control-Request-Headers: <span class="tag">&lt;<span class="name">field-name</span>&gt;</span>[, <span class="tag">&lt;<span class="name">field-name</span>&gt;</span>]*</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4><span id="示例">示例</span></h4><p>假设我们在 bbb.cn 域名下，发送一个 Ajax 请求到 aaa.cn 域名，其路径如下：<code>http://aaa.cn/localserver/api/corsTest</code> 。由于同源策略，这样的 Ajax 请求将会被浏览器所拦截，得到下面的信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200401194516318.png#pic_center" alt="145"></p>
<p>若想能够发送跨域请求，我们只需要在服务器的响应中配置适当的CORS HTTP 首部字段就可以了，例如可以加入以下的首部字段：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods：*</span><br></pre></td></tr></table></figure>

<p>此时，Ajax请求就可以顺利的发送和接收了，对应的请求和响应头部如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200401194530479.png#pic_center" alt="146"></p>
<p><img src="https://img-blog.csdnimg.cn/20200401194541400.png#pic_center" alt="147"></p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全之CSRF(跨站请求伪造)</title>
    <url>/2020/03/30/Web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<p>CSRF(Cross Site Request Forgery)，跨站请求伪造</p>
<blockquote>
<p>攻击者(黑客，钓鱼网站) 盗用你的身份，以你的名义发送恶意请求，这些请求包括发送邮件，发送消息，盗取账号，购买商品，银行转账，从而使你的个人隐私泄漏和财产损失</p>
</blockquote>
<a id="more"></a>

<h1><span id="现状">现状</span></h1><p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到2006年才开始被关注，2008年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：纽约时报，Metafilter，YouTube和百度。。。。而现在，互联网的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p>
<h1><span id="攻击实例">攻击实例</span></h1><p>我们先假设支付宝存在CSRF漏洞，我的支付宝账号是lyq，攻击者的支付宝账号是xxx。然后我们通过网页请求的方式 <a href="https://link.jianshu.com?t=http://zhifubao.com/withdraw?account=lyq&amount=10000&for=lyq2" target="_blank" rel="noopener">http://zhifubao.com/withdraw?account=lyq&amp;amount=10000&amp;for=lyq2</a> 可以把我账号lyq的10000元转到我的另外一个账号lyq2上去。通常情况下，该请求发送到支付宝服务器后，服务器会先验证该请求是否来自一个合法的session并且该session的用户已经成功登陆。攻击者在支付吧也有账号xxx，他知道上文中的URL可以进行转账操作，于是他自己可以发送一个请求 <a href="https://link.jianshu.com?t=http://zhifubao.com/withdraw?account=lyq&amount=10000&for=xxx" target="_blank" rel="noopener">http://zhifubao.com/withdraw?account=lyq&amp;amount=10000&amp;for=xxx</a> 到支付宝后台。但是这个请求是来自攻击者而不是来自我lyq，所以不能通过安全认证，因此该请求作废。这时，攻击者xxx想到了用CSRF的方式，他自己做了个黄色网站，在网站中放了如下代码：<a href="https://link.jianshu.com?t=http://zhifubao.com/withdraw?account=lyq&amount=10000&for=xxx" target="_blank" rel="noopener">http://zhifubao.com/withdraw?account=lyq&amp;amount=10000&amp;for=xxx</a> 并且通过黄色链接诱使我来访问他的网站。当我禁不住诱惑时就会点了进去，上述请求就会从我自己的浏览器发送到支付宝，而且这个请求会附带我的浏览器中的cookie。大多数情况下，该请求会失败，因为支付宝要求我的认证信息，但是我如果刚访问支付宝不久，还没有关闭支付宝页面，我的浏览器中的cookie存有我的认证信息，这个请求就会得到响应<br> ，从我的账户中转10000元到xxx账户里，而我丝毫不知情，攻击者拿到钱后逍遥法外。所以以后一定要克制住自己，不要随便打开别人的链接。</p>
<h1><span id="原理">原理</span></h1><p><img src="https://img-blog.csdnimg.cn/20200330235439457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="144"></p>
<p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成以下两个步骤：</p>
<ul>
<li>登录受信任网站A，并在本地生成Cookie。</li>
<li>在不登出A的情况下，访问危险网站B。</li>
</ul>
<p>看到这里，你也许会问：“如果我不满足以上两个条件中的一个，我就不会受到CSRF攻击”。是滴，确实如此，但是你不能保证以下情况不会发生：</p>
<ul>
<li>你不能保证你登录了一个网站之后，不再打开一个tab页面并访问其它的网站（黄网）。</li>
<li>你不能保证你关闭浏览器之后，你本地的Cookie立刻过期，你上次的会话已经结束。</li>
<li>上述中所谓的攻击网站，可能就是一个钓鱼网站或者黄色网站。</li>
</ul>
<h1><span id="防御">防御</span></h1><h2><span id="验证-http-referer-字段">验证 Http Referer 字段</span></h2><p>根据HTTP协议，在HTTP头部中有一个Referer字段，它记录了该HTTP请求所在的地址，表示HTTP请求从那个页面发出的。比如当你访问 <a href="https://link.jianshu.com?t=http://zhifubao.com/withdraw?account=lyq&amount=10000&for=xxx" target="_blank" rel="noopener">http://zhifubao.com/withdraw?account=lyq&amp;amount=10000&amp;for=xxx</a> ，用户必须先登录支付宝网站，然后通过点击页面的的按钮来触发转账事件。此时，转账请求的Referer值就是转账页面所在的URL，通常是以<a href="https://link.jianshu.com?t=http://zhifubao.com" target="_blank" rel="noopener">zhifubao.com</a>域名开头的地址。如果攻击者要实行CSRF攻击，那么他只能在自己的站点构造请求，此时Referer的值就指向黑客自己的网站。因此要防御CSRF攻击，支付宝只需要对每一个转账请求验证其Referer值，如果是以<a href="https://link.jianshu.com?t=http://zhifubao.com" target="_blank" rel="noopener">zhifubao.com</a>开头的域名，则是合法请求，相反，则是非法请求并拒绝。<br> 这种方法的好处就是简单易行，只需要在后台添加一个拦截器来检查Referer即可。然而这种办法并不是万无一失，Referer的值是由浏览器提供的，一些低级的浏览器可以通过某种方式篡改Referer的值，这就给了攻击者可乘之机；而一些高级浏览器处于安全考虑，可以让用户设置发送HTTP请求时不再提供Referer值，这样当他们正常访问支付宝网站时，因为没有提供Referer值而被误认为CERF攻击，拒绝访问。实际应用中通常采用第二种方法来防御CSRF攻击。</p>
<h2><span id="添加-token-验证">添加 token 验证</span></h2><p>CSRF攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都存在cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过安全验证。要防止CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie之中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token，如果请求中没有token或者token不正确，则认为可能是CSRF攻击而拒绝该请求。<br> 现在业界一致的做法就是使用Anti CSRF Token来防御CSRF。</p>
<ol>
<li><p>用户访问某个表单页面。</p>
</li>
<li><p>服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。</p>
</li>
<li><p>在页面表单附带上Token参数。</p>
</li>
<li><p>用户提交请求后，服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。</p>
</li>
</ol>
<p>这个Token值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token应注意Token的保密性，尽量把敏感操作由GET改成POST，以form或者AJAX形式提交，避免Token泄露。</p>
<h2><span id="验证码">验证码</span></h2><p>验证码，强制用户必须与应用进行交互，才能完成最终请求。通常情况下，验证码能够很好的遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段。</p>
<h2><span id="尽量使用post限制get">尽量使用POST，限制GET</span></h2><p>GET接口能够直接将请求地址暴露给攻击者，所以要防止CSRF一定最好不要用GET。当然POST并不是万无一失，攻击者只需要构造一个form表单就可以，但需要在第三方页面做，这样就增加了暴露的可能性。</p>
<h2><span id="在http头部添加自定义属性">在HTTP头部添加自定义属性</span></h2><p>这种方法也是使用token并验证，但是它是把token放在HTTP请求头部中。通过使用AJAX我们可以在我们的请求头部中添加我们的自定义属性，但是这种方法要求我们将整个站的请求全部改成AJAX，如果是新站还好，老站的话无疑是需要重写整个站点的，这是很不可取的。</p>
<p>转载自：</p>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB安全之-CSRF（跨站请求伪造）</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之JPA</title>
    <url>/2020/03/29/SpringBoot%E4%B9%8BJPA/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://blog.csdn.net/zhangtongpeng/article/details/79609942" target="_blank" rel="noopener">spring-boot工程中，jpa下hibernate的ddl-auto的各种属性</a></p>
<a id="more"></a>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jpa:</span></span><br><span class="line">  <span class="attr">hibernate:</span></span><br><span class="line">    <span class="attr">ddl-auto:</span> <span class="string">create</span></span><br></pre></td></tr></table></figure>

<p>ddl-auto:create—-每次运行该程序，没有表格会新建表格，表内有数据会清空</p>
<p>ddl-auto:create-drop—-每次程序结束的时候会清空表</p>
<p>ddl-auto:update—-每次运行程序，没有表格会新建表格，表内有数据不会清空，只会更新</p>
<p>ddl-auto:validate—-运行程序会校验数据与数据库的字段类型是否相同，不同会报错</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库三大范式</title>
    <url>/2020/03/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html" target="_blank" rel="noopener">数据库设计三大范式</a></p>
<p>为了建立冗余较小，结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<a id="more"></a>

<h1><span id="第一范式">第一范式</span></h1><blockquote>
<p>确保每列保持原子性</p>
</blockquote>
<p>第一范式是最基本的范式。如果数据库表中<strong>所有字段值都是不可分解的原子值</strong>，就说明该数据库表满足了第一范式。</p>
<p>第一范式的合理遵循需要根据系统的<strong>实际需求</strong>来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200328232809813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="114.png"></p>
<p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>
<h1><span id="第二范式">第二范式</span></h1><blockquote>
<p>确保表中的每列都和主键相关</p>
</blockquote>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关(主要针对联合主键而言)。<strong>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</strong></p>
<p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示：</p>
<p><strong>订单信息表</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200328232833579.png#pic_center" alt="115.png"></p>
<p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。</p>
<p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200328232850989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="116.png"></p>
<p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p>
<h1><span id="第三范式">第三范式</span></h1><blockquote>
<p>确保每列都和主键列直接相关，而不是间接相关</p>
</blockquote>
<p>第三范式需要确保数据表中的<strong>每一列数据都和主键直接相关，而不是间接相关。</strong></p>
<p>比如在设计一个订单数据库表的时候，可以将客户编号作为一个外键和订单表建立相关的关系。而不可以在订单表中添加关于客户其他信息(比如姓名，所属公司等) 的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p>
<p><img src="https://img-blog.csdnimg.cn/20200328232908880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="117.png"></p>
<p>这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常总结</title>
    <url>/2020/03/26/Java%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.nowcoder.com/test/question/done?tid=31937511&qid=22460#summary" target="_blank" rel="noopener">Java异常</a></p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200326130859755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="111"></p>
<ol>
<li><p>粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.</p>
</li>
<li><p>浅蓝色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除…</p>
</li>
<li><p>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识点总结</title>
    <url>/2020/03/26/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://www.cnblogs.com/lizhenghn/p/5322887.html" target="_blank" rel="noopener">Redis常用数据类型介绍、使用场景及其操作命令</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/63737596" target="_blank" rel="noopener">面试官问分布式技术面试题，一脸懵逼怎么办？</a></p>
<h1><span id="redis-的主从复制是如何实现">Redis 的主从复制是如何实现？</span></h1><ol>
<li>从服务器连接主服务器，发送 SYNC 命令</li>
<li>主服务器接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令</li>
<li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令</li>
</ol>
<a id="more"></a>

<h1><span id="redis-的-key-是如何寻址的">Redis 的 key 是如何寻址的</span></h1><p>(1) redis 中的每一个数据库，都由一个 redisDb 的结构存储，其中：</p>
<ul>
<li>redisDb.id 存储着 redis 数据库以整数表示的号码</li>
<li>redisDb.dict 存储着该库所有的键值对数据</li>
<li>redisDb.expires 保存着每一个键的过期时间</li>
</ul>
<p>(2) 当 redis 服务器初始化时，会预先分配 16 个数据库 (该数量可以通过配置文件配置),所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己在哪个数据库时，直接读取 redisDb.id 即可。</p>
<p>(3) redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表(ht[0]) 主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p>
<p>(4) 既然是哈希，那么我们知道就会有哈希碰撞，那么当多个哈希键 hash 之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 <strong>O(1)</strong>。</p>
<h2><span id="寻址-key-的步骤">寻址 key 的步骤</span></h2><ol>
<li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li>
<li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中则有可能存储该 key。如果正在进行 rehash，将调用一次 _dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash。</li>
<li>计算哈希表，根据当前字典与 key 进行哈希值的计算</li>
<li>根据哈希值与当前字典计算哈希表的索引值</li>
<li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1</li>
<li>当 ht[0] 查找完了之后，再进行了一次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li>
</ol>
<h1><span id="redis-的集群是如何实现的">Redis 的集群是如何实现的</span></h1><p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis3.0 版本推出</p>
<p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p>
<h2><span id="redis-cluster-节点分配">Redis Cluster 节点分配</span></h2><p>Redis Cluster 特点：</p>
<ol>
<li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽</li>
<li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效</li>
<li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li>
<li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。</li>
<li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li>
</ol>
<h2><span id="redis-cluster-主从模式">Redis Cluster 主从模式</span></h2><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p>
<p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p>
<h2><span id="redis-sentinel">Redis Sentinel</span></h2><p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p>
<ul>
<li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p>
<p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。</p>
<p>假设集群仅仅部署 2 个节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>

<p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p>
<h1><span id="redis-如何实现分布式锁-zookeeper-如何实现分布式锁">Redis 如何实现分布式锁? Zookeeper 如何实现分布式锁?</span></h1><p>分布式锁的三种实现：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存(Redis等) 实现分布式锁</li>
<li>基于 Zookeeper 实现分布式锁</li>
</ul>
<h2><span id="redis-实现">Redis 实现</span></h2><ol>
<li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID, 通过此在释放锁的时候进行诊断</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h2><span id="zookeeper-实现">ZooKeeper 实现</span></h2><ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud之Security总结</title>
    <url>/2020/03/24/SpringCloud%E4%B9%8BSecurity%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://docs.spring.io/spring-security/site/docs/5.3.1.BUILD-SNAPSHOT/reference/html5/#preface" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://www.springcloud.cc/spring-security.html#jc-form" target="_blank" rel="noopener">Spring Security参考，中文文档值得关注</a></p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_04?id=mall整合springsecurity和jwt实现认证和授权（一）" target="_blank" rel="noopener">mall整合SpringSecurity和JWT实现认证和授权（一）</a></p>
<p><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">COOKIE和SESSION有什么区别？</a></p>
<p><a href="https://juejin.im/post/5a437441f265da43294e54c3" target="_blank" rel="noopener">聊一聊JWT与session</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247486003&idx=1&sn=7cea98049764fa7d8f7dbe05472d2e02&scene=21#wechat_redirect" target="_blank" rel="noopener">手把手带你入门 Spring Security！</a></p>
<p><a href="https://segmentfault.com/a/1190000012557493" target="_blank" rel="noopener">spring security系列一：架构概述</a></p>
<p><a href="https://segmentfault.com/a/1190000012668936" target="_blank" rel="noopener">spring security系列二：过滤器机制</a></p>
<p><a href="https://blog.csdn.net/zhoucheng05_13/article/details/60466980" target="_blank" rel="noopener">SpringSecurity学习笔记之二：SpringSecurity结构及基本配置</a></p>
<p><a href="https://blog.csdn.net/zhoucheng05_13/article/details/60467089" target="_blank" rel="noopener">SpringSecurity学习笔记之三：配置用户存储</a></p>
<p><a href="https://blog.csdn.net/zhoucheng05_13/article/details/60467234" target="_blank" rel="noopener">SpringSecurity学习笔记之四：拦截请求</a></p>
<p><a href="https://www.cnblogs.com/demingblog/p/10874753.html#%E4%BB%8E%E4%B8%80%E4%B8%AAspring-security%E7%9A%84%E4%BE%8B%E5%AD%90%E5%BC%80%E5%A7%8B" target="_blank" rel="noopener">从一个Spring Security的例子开始</a></p>
<p><a href="https://www.jianshu.com/p/ac42f38baf6e" target="_blank" rel="noopener">Spring Security 详解</a></p>
<h1><span id="定义">定义</span></h1><blockquote>
<p>SpringSecurity是一个强大的可高度定制的认证和授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。</p>
</blockquote>
<p>一般会结合 <strong><em>JWT</em></strong> 进行使用</p>
<blockquote>
<p>JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。</p>
</blockquote>
<a id="more"></a>

<h1><span id="授权和认证">授权和认证</span></h1><p>认证就是让服务器知道你是谁；授权就是服务器让你知道你什么能干，什么不能干</p>
<h1><span id="jwt">JWT</span></h1><h2><span id="定义">定义</span></h2><p>JSON Web Token（JWT）是一种开放标准（RFC 7519），它定义了一种紧凑且独立的方式，可以将各方之间的信息作为JSON对象进行安全传输。该信息可以验证和信任，因为是经过数字签名的。</p>
<h2><span id="组成">组成</span></h2><p>JWT token 的格式：<strong>header</strong>.<strong>payload</strong>.<strong>signature</strong></p>
<ul>
<li><strong><em>header</em></strong> 中用于存放签名的生成算法。通常包含两个字段，分别是 <u>typ(type)</u> 和 <u>alg(algorithm)</u><ul>
<li>typ：token的类型，这里固定为 JWT</li>
<li>alg：使用的 hash 算法，例如：HMAC SHA256 或者 RSA</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>payload</em></strong> 存储我们需要传递的信息的部分，存放用户名，token的生成时间和过期时间，</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"sub"</span>:<span class="string">"admin"</span>,<span class="attr">"created"</span>:<span class="number">1489079981393</span>,<span class="attr">"exp"</span>:<span class="number">1489684781</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>signature</em></strong> 以 header 和 payload 生成的签名，一旦 header 和 payload 被篡改，验证将失败</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//secret为加密算法的密钥</span></span><br><span class="line">String signature = HMACSHA512(base64UrlEncode(header) + <span class="string">"."</span> +base64UrlEncode(payload),secret)</span><br></pre></td></tr></table></figure>

<h2><span id="实例">实例</span></h2><p>这是一个JWT的字符串</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE1NTY3NzkxMjUzMDksImV4cCI6MTU1NzM4MzkyNX0.d-iki0193X0bBOETf2UN3r3PotNIEAV7mzIxxeI5IxFyzzkOZxS0PGfF_SK6wxCv2K8S0cZjMkv6b5bCqc0VBwCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2><span id="实现认证和授权的原理">实现认证和授权的原理</span></h2><ol>
<li>用户调用登录接口，登录成功后获取到 JWT 的 token</li>
<li>之后用户每次调用接口都在 http 的 header 中添加一个 [头叫 <strong><em>Authorization</em></strong> 的，值为 JWT 的 token]</li>
<li>后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。</li>
</ol>
<h2><span id="流程图">流程图</span></h2><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/109.png" alt="109.png"></p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/134.png" alt="134.png"></p>
<h2><span id="jwt-存在的问题">JWT 存在的问题</span></h2><ol>
<li>续签问题，这是被很多人诟病的问题之一，传统的cookie+session的方案天然的支持续签，但是jwt由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入redis，虽然可以解决问题，但是jwt也变得不伦不类了。</li>
<li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改secret来实现注销，服务端secret修改后，已经颁发的未过期的token就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li>
<li>密码重置，密码重置后，原本的token依然可以访问系统，这时候也需要强制修改secret。</li>
<li>基于第2点和第3点，一般建议不同用户取不同secret。</li>
</ol>
<h1><span id="session-和-cookie">Session 和 Cookie</span></h1><blockquote>
<p>Session 是服务端用来记录用户的状态的一种机制。</p>
</blockquote>
<p>由于 HTTP 协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建特定的 Session，用于标识这个用户，并且跟踪用户。</p>
<p>这个 Session 是保存在服务端的，有一个唯一标识。在服务端保存 Session 的方法很多，内存，数据库，文件都有，<strong>不过一般是通过 redis 进行存储</strong>。</p>
<h2><span id="服务端如何识别特定的客户">服务端如何识别特定的客户？</span></h2><p>这个时候 Cookie 登场了，每次 Http 请求的时候，客户端都会发送相应的 Cookie 信息到服务端。实际上大多数应用都是用 Cookie 来实现 Session 跟踪的。每一次创建 Session 的时候，服务端会在 Http 协议中告诉客户端，需要在 Cookie 里面记录一个 Session ID，以后每次请求把这个 <strong><em>会话ID</em></strong> 发送到服务器，服务端就知道你是谁了。</p>
<p>有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做 <strong><em>URL重写</em></strong>  的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 <u>sid=xxxxx</u> 这样的参数，服务端据此来识别用户。</p>
<h2><span id="cookie">Cookie</span></h2><p>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</p>
<h2><span id="流程图">流程图</span></h2><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/110.png" alt="110"></p>
<h2><span id="总结">总结</span></h2><p>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；<br>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p>
<h2><span id="优劣势">优劣势</span></h2><h3><span id="优点">优点</span></h3><ul>
<li><p>相比JWT，最大的优势就在于可以主动清除session了</p>
</li>
<li><p>session保存在服务器端，相对较为安全</p>
</li>
<li><p>结合cookie使用，较为灵活，兼容性较好</p>
</li>
</ul>
<h3><span id="劣势">劣势</span></h3><ul>
<li>cookie + session在跨域场景表现并不好</li>
<li>如果是分布式部署，需要做多机共享session机制，实现方法可将session存储到数据库中或者redis中</li>
<li>基于 cookie 的机制很容易被 CSRF</li>
<li>查询session信息可能会有数据库查询操作</li>
</ul>
<h1><span id="核心组件">核心组件</span></h1><h2><span id="securitycontextholder">SecurityContextHolder</span></h2><blockquote>
<p>SecurityContextHolder 它持有的是安全上下文( security context ) 的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限等等，这些都被保存在 SecurityContextHolder 中。SecurityContextHolder 默认使用 ThreadLocal 策略来存储认证信息。看到ThreadLocal 也就意味着，这是一种与线程绑定的策略。在web环境下，Spring Security在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。</p>
<p>SecurityContextHolder 是一个类，它的功能方法是静态的</p>
<p>SecurityContextHolder可以设置指定JVM策略(SecurityContext的存储策略)，这个策略有三种：</p>
<ul>
<li>MODE_THREADLOCAL：SecurityContext 存储在线程中。</li>
<li>MODE_INHERITABLETHREADLOCAL：SecurityContext 存储在线程中，但子线程可以获取到父线程中的 SecurityContext。</li>
<li>MODE_GLOBAL：SecurityContext 在所有线程中都相同。</li>
<li>SecurityContextHolder默认使用MODE_THREADLOCAL模式，即存储在当前线程中。在spring security应用中，我们通常能看到类似如下的代码：</li>
</ul>
</blockquote>
<p><strong>获取当前用户信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object principal =SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line"><span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails) &#123;</span><br><span class="line">    String username = ((UserDetails)principal).getUsername();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    String username = principal.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getAuthentication() 返回认证信息，getPrincipal() 返回身份信息，UserDetails 便是 Spring 对身份信息封装的一个接口</p>
<h2><span id="securitycontext">SecurityContext</span></h2><blockquote>
<p>安全上下文,主要持有 Authentication 对象，如果用户未鉴权，那 Authentication 对象将会是空的。用户通过SpringSecurity的校验之后，验证信息存储在SecurityContext中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecurityContext</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function">Authentication <span class="title">getAuthentication</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthentication</span><span class="params">(Authentication var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="authentication">Authentication</span></h2><blockquote>
<p>鉴权对象，该对象主要包含了用户的详细信息(UserDetails) 和用户鉴权时所需要的信息，如用户提交的用户密码，Remeber-me Token, 或者 digest hash 值等，按不同鉴权方式使用不同的 Authentication</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.security.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Authentication 是 Spring Security 包中的接口，直接继承自 Principal 类，而 Principal 是位于 java.security 包中。可以见得，Authentication在spring security中是最高级别的身份/认证的抽象。</li>
<li>由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。</li>
<li><strong><em>getAuthorities()</em></strong>，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。</li>
<li><strong><em>getCredentials()</em></strong>，密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</li>
<li><strong><em>getDetails()</em></strong>，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。</li>
<li><strong><em>getPrincipal()</em></strong>，敲黑板！！！最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类，也是框架中的常用接口之一。</li>
</ol>
<h2><span id="grantedauthority">GrantedAuthority</span></h2><blockquote>
<p>该接口表示了当前用户所拥有的权限(或者角色) 信息。这些信息由授权负责对象 AccessDecisionManager 来使用，并决定最终用户可以访问某资源 (URL 或方法调用或域对象)。鉴权时并不会使用到该对象</p>
</blockquote>
<h2><span id="userdetails">UserDetails</span></h2><blockquote>
<p>这个接口规范了用户详细信息所拥有的字段，譬如用户名、密码、账号是否过期、是否锁定等。在Spring Security中，获取当前登录的用户的信息,一般情况是需要在这个接口上面进行扩展，用来对接自己系统的用户</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.security.core.userdetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="userdetailsservice">UserDetailsService</span></h2><blockquote>
<p>这个接口只提供一个接口loadUserByUsername(String username)，这个接口非常重要，一般情况我们都是通过扩展这个接口来显示获取我们的用户信息，用户登陆时传递的用户名和密码也是通过这里这查找出来的用户名和密码进行校验，但是真正的校验不在这里，而是由AuthenticationManager以及AuthenticationProvider负责的，需要强调的是，如果用户不存在，不应返回NULL，而要抛出异常UsernameNotFoundException</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ~ Methods</span></span><br><span class="line">    <span class="comment">// ========================================================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Locates the user based on the username. In the actual implementation, the search</span></span><br><span class="line"><span class="comment">	 * may possibly be case sensitive, or case insensitive depending on how the</span></span><br><span class="line"><span class="comment">	 * implementation instance is configured. In this case, the &lt;code&gt;UserDetails&lt;/code&gt;</span></span><br><span class="line"><span class="comment">	 * object that comes back may have a username that is of a different case than what</span></span><br><span class="line"><span class="comment">	 * was actually requested..</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> username the username identifying the user whose data is required.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a fully populated user record (never &lt;code&gt;null&lt;/code&gt;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> UsernameNotFoundException if the user could not be found or the user has no</span></span><br><span class="line"><span class="comment">	 * GrantedAuthority</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="authenticationmanager">AuthenticationManager</span></h2><blockquote>
<p>初次接触Spring Security的朋友相信会被AuthenticationManager，ProviderManager ，AuthenticationProvider …这么多相似的Spring认证类搞得晕头转向，但只要稍微梳理一下就可以理解清楚它们的联系和设计者的用意。AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用用户名+密码登录，同时允许用户使用邮箱+密码，手机号码+密码登录，甚至，可能允许用户使用指纹登录（还有这样的操作？没想到吧），所以说AuthenticationManager一般不直接认证，AuthenticationManager接口的常用实现类ProviderManager 内部会维护一个List&lt;AuthenticationProvider&gt;列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式：用户名+密码（UsernamePasswordAuthenticationToken），邮箱+密码，手机号码+密码登录则对应了三个AuthenticationProvider。这样一来就好理解多了？。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">    AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">    Authentication result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依次进行验证</span></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">                         + provider.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有Authentication信息，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccountStatusException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="comment">// SEC-546: Avoid polling additional providers if auth failure is due to</span></span><br><span class="line">            <span class="comment">// invalid account status</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line">            prepareException(e, authentication);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Allow the parent to try.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parent.authenticate(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore as we will throw below if no other exception occurred prior to</span></span><br><span class="line">            <span class="comment">// calling parent and the parent</span></span><br><span class="line">            <span class="comment">// may throw ProviderNotFound even though a provider in the child already</span></span><br><span class="line">            <span class="comment">// handled the request</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">            &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">            <span class="comment">//移除密码</span></span><br><span class="line">            ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布登录成功事件</span></span><br><span class="line">        eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行到此，说明没有认证成功，包装异常信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastException == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lastException = <span class="keyword">new</span> ProviderNotFoundException(messages.getMessage(</span><br><span class="line">            <span class="string">"ProviderManager.providerNotFound"</span>,</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; toTest.getName() &#125;,</span><br><span class="line">            <span class="string">"No AuthenticationProvider found for &#123;0&#125;"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareException(lastException, authentication);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="核心类图">核心类图</span></h2><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/135.png" alt="135.png"></p>
<h1><span id="spring-security-是如何完成身份认证的">Spring Security 是如何完成身份认证的？</span></h1><ol>
<li>用户名和密码被过滤器获取到，封装成 Authentication，通常情况下是<strong><em>UsernamePasswordAuthenticationToken</em></strong> 这个实现类</li>
<li>AuthenticationManager 身份管理器负责验证这个 Authentication</li>
<li>认证成功后，<strong><em>AuthenticationManager</em></strong> 身份管理器返回一个被填满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication 实例</li>
<li><strong><em>SecurityContextHolder</em></strong>安全上下文容器将第3步填充了信息的Authentication，通过SecurityContextHolder.getContext().setAuthentication()方法，设置到其中。</li>
</ol>
<h1><span id="过滤器机制">过滤器机制</span></h1><p>Spring Security 框架的过滤器是 <strong>基于filter</strong> 来实现，这样它可以不需要依赖任何 web 框架，甚至连 SpringMVC 框架都不需要依赖，这样整个spring security过滤器就会变得异常的轻量级和无侵入性。</p>
<h2><span id="spring-security-处理请求流程">Spring Security 处理请求流程</span></h2><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/136.png" alt="136.png"></p>
<p>用户发起请求，认证管理器（Authentication Manager）会发起拦截，验证用户发起请求时的一些凭证信息，未通过验证信息审核的那么返回给用户，通过审核的，那么继续进行请求访问，访问页面之前，会被访问决策管理（Access Decision Manager）拦截，访问决策管理器验证用户是否有访问页面的权限，如果有，那么继续到访问页面。</p>
<p>另外spring security是通过委托代理（delegates）的方式去实现过滤器链的，<br>首先先通过过滤器拦截用户的请求，拦截后通过servlet来进行处理，如果处理成功那么进行正常访问，在返回给用户一个请求。</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/137.png" alt="137.png"></p>
<ol>
<li>ChannelProcessingFilter，使用它因为我们可能会指向不同的协议(如:Http,Https)</li>
<li>SecurityContextPersistenceFilter，负责从SecurityContextRepository 获取或存储 SecurityContext。SecurityContext 代表了用户安全和认证过的session</li>
<li>ConcurrentSessionFilter,使用SecurityContextHolder的功能，更新来自“安全对象”不间断的请求,进而更新SessionRegistry</li>
<li>认证进行机制，UsernamePasswordAuthenticationFilter，CasAuthenticationFilter，BasicAuthenticationFilter等等–SecurityContextHolder可能会修改含有Authentication这样认证信息的token值</li>
<li>SecurityContextHolderAwareRequestFilter,如果你想用它的话，需要初始化spring security中的HttpServletRequestWrapper到你的servlet容器中。</li>
<li>JaasApiIntegrationFilter，如果JaasAuthenticationToken在SecurityContextHolder的上下文中，在过滤器链中JaasAuthenticationToken将作为一个对象。</li>
<li>RememberMeAuthenticationFilter，如果还没有新的认证程序机制更新SecurityContextHolder，并且请求已经被一个“记住我”的服务替代，那么将会有一个Authentication对象将存放到这（就是 已经作为cookie请求的内容）。</li>
<li>AnonymousAuthenticationFilter，如果没有任何认证程序机制更新SecurityContextHolder，一个匿名的对象将存放到这。</li>
<li>ExceptionTranslationFilter，为了捕获spring security的错误，所以一个http响应将返回一个Exception或是触发AuthenticationEntryPoint。</li>
<li>FilterSecurityInterceptor，当连接被拒绝时，保护web URLS并且抛出异常。</li>
</ol>
<h1><span id="基本配置">基本配置</span></h1><p>Spring Security3.2分为11个模块，如下表所示：</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/139.png" alt="139.png"></p>
<p>Spring Security3.2引入了新的Java配置方案，完全不在需要通过XML来配置安全性功能。如下，展现了Spring Security最简单的Java配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spitter.config;</span><br><span class="line">......</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableWebSecurity 注解将会启动 Web 安全功能，但它本身没什么功能。Spring Security必须配置在一个实现了WebSecurityConfigurer的bean中，或者扩展WebSecurityConfigurerAdapter，扩展该类是最简单的配置方法。<br>这样做有以下几点好处：</p>
<ul>
<li><p>a、该注解配置了一个Spring MVC参数解析器（argument<br>resolver），这样处理器方法能够通过带有@AuthenticationPrincipal注解的参数获得认证用户的principal（或username）。</p>
</li>
<li><p>b、它配置了一个bean，在使用Spring表单绑定标签库来定义表单时，这个bean会自动添加一个隐藏的跨站请求伪造token输入域。</p>
</li>
</ul>
<p>我们可以通过重载WebSecurityConfigurerAdapter中的一个或多个方法来指定Web安全的细节。例如WebSecurityConfigurerAdapter的三个configure()方法：configure(WebSecurity)、configure(HttpSecurity)、configure(AuthenticationManagerBuilder)，详情如下表：<br><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/140.png" alt="140"></p>
<p>上面的程序清单中没有重写任何一个configure()方法，所以应用现在是被严格锁定的，没有任何人能够进入系统。为了让Spring Security满足我们应用的需求，还需要再添加一点配置。具体来讲，我们需要：</p>
<ul>
<li><p>a、配置用户存储</p>
</li>
<li><p>b、指定哪些请求需要认证，哪些请求不需要认证，以及需要的权限。</p>
</li>
<li><p>c、提供一个自定义的登录页面，替代原来简单的默认登录页。</p>
</li>
</ul>
<h1><span id="配置用户存储">配置用户存储</span></h1><h2><span id="使用基于内存的用户存储">使用基于内存的用户存储</span></h2><p>重写 <strong><em>configure(AuthenticationManagerBuilder)</em></strong> 方法可以方便地配置Spring Security对认证的支持。通过inmMemoryAuthentication()方法，我们可以启用、配置并任意填充基于内存的用户存储。实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvcSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication().withUser(<span class="string">"user"</span>).password(<span class="string">"password"</span>).roles(<span class="string">"USER"</span>).and().withUser(<span class="string">"admin"</span>).password(<span class="string">"password"</span>).roles(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>withUser()方法返回的是UserDetailsManagerConfigurer.UserDetailsBuilder，这个对象提供了多个进一步配置用户的方法，如上面的为用户设置密码的password()方法、授予用户多个角色权限的roles()方法。UserDetailsManagerConfigurer.UserDetailsBuilder对象的更多方法如下表：<br><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/141.png" alt="141.png"></p>
<h2><span id="基于数据库表进行认证">基于数据库表进行认证</span></h2><p>用户数据通常会存储在关系型数据库中，并通过JDBC进行访问。所需的最少配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    auth</span><br><span class="line">        .jdbcAuthentication()</span><br><span class="line">        .dataSource(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用JDBCAuthentication()方法来实现一JDBC为支撑的用户存储，必须要配置的只是一个DataSource，就能访问关系型数据库了。</p>
<h3><span id="重写默认的用户查询功能">重写默认的用户查询功能</span></h3><p>Spring Security内部默认的查询语句是写定的，可能在某些情况下并不适用。我们可以按照如下的方式配置自己的查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Authentication auth)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    auth</span><br><span class="line">        .jdbcAuthentication()</span><br><span class="line">        .dataSource(dataSource)</span><br><span class="line">        .usersByUsernameQuery(<span class="string">"select username,password,true from Spitter where username=?"</span>)</span><br><span class="line">        .authoritiesByUsernameQuery(<span class="string">"select username,'ROLE_USER' from Spitter where username=?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="使用转码后的密码">使用转码后的密码</span></h3><p>通常数据库中的密码都会加密，那么如果我们只是按照上面那样配置的话，用户提交的明文密码和数据库的加密密码就会不匹配，从而认证失败。为了解决这个问题，我们需要借助passwordEncoder()方法指定一个密码转码器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Authentication auth)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    auth</span><br><span class="line">        .jdbcAuthentication()</span><br><span class="line">        .dataSource(dataSource)</span><br><span class="line">        .usersByUsernameQuery(<span class="string">"select username,password,true from Spitter where username=?"</span>)</span><br><span class="line">        .authoritiesByUsernameQuery(<span class="string">"select username,'ROLE_USER' from Spitter where username=?"</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> StandardPasswordEncoder(<span class="string">"53cr3t"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>passwordEncoder()方法可以接受Spring Security中PasswordEncoder接口的任意实现。Spring Security的加密模块包括三个这样的实现：</p>
<ul>
<li><input checked disabled type="checkbox"> <strong><em>BCryptPasswordEncoder</em></strong></li>
<li><input checked disabled type="checkbox"> <strong><em>NoOpPasswordEncoder</em></strong></li>
<li><input checked disabled type="checkbox"> <strong><em>StandardPasswordEncoder</em></strong>。</li>
</ul>
<h2><span id="配置自定义的用户服务">配置自定义的用户服务</span></h2><p>如果我们需要认证的用户存储在非关系型数据库中，如Mongo或Neo4j，那么我们需要提供一个自定义的UserDetailsService接口实现。UserDetailsService接口非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span></span>&#123;</span><br><span class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要做的就是实现loadUserByUsername()方法，根据给定的用户名来查找用户。该方法会返回代表给定用户的UserDetails对象。当我们自定义的配置类完成后，以SpitterUserService（实现了UserDetailsSevice接口并重写了loadUserByUsername方法）为例，可以通过如下方式将其配置为用户存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">SpitterRepository spitterRepository;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    auth.userDetailsService(<span class="keyword">new</span> SpitterUserSevice(spitterRepository));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="拦截请求">拦截请求</span></h1><p>在任何应用中，并不是所有请求都需要同等程度地保护起来。有些请求需要认证，有些不需要。</p>
<p>对每个请求进行细粒度安全性控制的关键在于重载 <strong><em>configure(HttpSecurity)</em></strong> 方法。如下代码片段展现了重载的configure(HttpSecurity)方法，它为不同的URL路径有选择地应用安全性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">"/spitters/me"</span>).authenticated()</span><br><span class="line">        .antMatchers(HttpMethod.POST,<span class="string">"/spittles"</span>).authenticated()</span><br><span class="line">        .anyRequest().permitAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>antMatchers()</em></strong> 方法所设定的路径支持 <strong><em>Ant</em></strong> 风格的通配符。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/spitters/**"</span>,<span class="string">"spittles/mine"</span>).authenticated();          <span class="comment">//Ant风格</span></span><br></pre></td></tr></table></figure>

<p>antMatchers() 方法所使用的路径可能会包括 Ant 风格的通配符，而 <strong>regexMatchers()</strong> 方法则能够接受正则表达式来定义请求路径。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.regexMatchers(<span class="string">"spitters/.*"</span>).authenticated();   <span class="comment">//正则表达式风格</span></span><br></pre></td></tr></table></figure>

<p>除了路径选择，我们还通过 <strong><em>authenticated()</em></strong> 和 <strong><em>permitAll()</em></strong> 来定义该如何保护路径。</p>
<p><strong><u>authenticated()</u></strong> 要求在执行该请求时，必须已经登录了应用。如果用户没有认证，Spring Security的Filter将会捕获该请求，并将用户重定向到应用的登录界面。</p>
<p><strong><u>permitAll()</u></strong> 方法允许请求没有任何的安全限制。</p>
<p>除了authenticated()和permitAll()以外，authorizeRequests()方法返回的对象还有更多的方法用于细粒度地保护请求。如下所示：</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/142.png" alt="142"></p>
<p>我们可以将任意数量的antMatchers()、regexMatchers()和anyRequest()连接起来，以满足Web应用安全规则的需要。</p>
<p>注意，将最不具体的路径（如anyRequest()）放在最后面。如果不这样做，那不具体的路径配置将会覆盖掉更为具体的路径配置。</p>
<h2><span id="使用-spring-表达式进行安全保护">使用 Spring 表达式进行安全保护</span></h2><p>上面的方法虽然满足了大多数应用场景，但并不是全部。如果我们希望限制某个角色只能在星期二进行访问的话，那么就比较困难了。同时，上面的大多数方法都是一维的，如hasRole()方法和hasIpAddress()方法没办法同时限制一个请求路径。</p>
<p>借助access()方法，我们可以将SpEL作为声明访问限制的一种方式。例如，如下就是使用SpEL表达式来声明具有“ROLE_SPITTER”角色才能访问“/spitter/me”URL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/spitters/me"</span>).access(<span class="string">"hasRole('ROLE_SPITTER')"</span>);</span><br></pre></td></tr></table></figure>

<p>回顾下 SpEL 的知识吧</p>
<blockquote>
<p>SpEL（Spring Expression Language），即Spring表达式语言.</p>
<p>Spring表达式语言（简称SpEl）是一个支持查询和操作运行时对象导航图功能的强大的表达式语言. 它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">"'Hello World'.concat('!')"</span>);</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>结果将是 <em>Hello World!</em></p>
</blockquote>
<p>让SpEL更强大的原因在于，hasRole()仅是Spring支持的安全相关表达式中的一种。下表列出了Spring Security支持的所有SpEL表达式。</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/143.png" alt="143"></p>
<p>现在，如果我们想限制“/spitter/me”URL的访问，不仅需要ROLE_SPITTER角色，还需要来自指定的IP地址，那么我们可以按照如下的方式调用access()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/spitter/me"</span>)</span><br><span class="line">    .access(<span class="string">"hasRole('SPITTER') and hasIpAddress('127.0.0.1')"</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="spring-security拦截请求的另外一种方式强制通道的安全性">Spring Security拦截请求的另外一种方式：强制通道的安全性</span></h2><p>通过 Http 发送的数据没有经过加密，黑客就有机会拦截请求并且能够看到它们想看的数据。这就是为什么敏感信息要通过HTTPS来加密发送的原因。传递到 configure() 方法中的 HttpSecurity 对象，除了具有 authorizeRequest() 方法以外，还有一个 requiresChannel() 方法，借助这个方法能够为各种 URL 模式声明所要求的通道( 如 Https)</p>
<p>在注册表单中，用户会希望敏感信息（用户不希望泄露的信息，如信用卡号等）是私密的。为了保证注册表单的数据通过HTTPS传送，我们可以在配置中添加requiresChannel()方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">"/spitter/me"</span>).hasRole(<span class="string">"SPITTER"</span>)</span><br><span class="line">        .antMatchers(HttpMethod.POST,<span class="string">"/spittles"</span>).hasRole(<span class="string">"SPITTER"</span>)</span><br><span class="line">        .anyRequest().permitAll();</span><br><span class="line">    .and()</span><br><span class="line">        .requiresChannel()</span><br><span class="line">        .antMatchers(<span class="string">"spitter/form"</span>).requiresSecure();   <span class="comment">//需要 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论何时，只要是对“/spitter/form”的请求，Spring Security都视为需要安全通道（通过调用requiresChannel()确定的）并自动将请求重定向到HTTPS上。<br>与之相反，有些页面并不需要通过HTTPS传送。例如，首页不包含任何敏感信息，因此并不需要通过HTTPS传送。我们可以使用requiresInsecure()代替requiresSecure()方法，将首页声明为始终通过HTTP传送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/"</span>).requiresInsecure();</span><br></pre></td></tr></table></figure>

<h2><span id="防止跨站请求伪造">防止跨站请求伪造</span></h2><p>什么是跨站请求伪造？下面是一个简单的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"http://www.spittr.com/Spittles"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"massage"</span> <span class="attr">value</span>=<span class="string">"I'm a stupid"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Click here to win a new car!"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是跨站请求伪造（cross-site request forgery，CRSF）的一个简单样例。简单来讲，入过一个站点欺骗用户提交请求到其他服务器的话，就会发生CSRF攻击，这可能会带来很严重的后果。</p>
<p>从Spring Security3.2开始，默认就会启用CSRF攻击。</p>
<p>Spring Security通过一个同步token的方式来实现CSRF防护。它会拦截状态变化的请求并检查CSRF token。如果请求不包含CSRF token，或token不能与服务器端的token相匹配，请求将会失败，并抛出CsrfException。<br>Spring Security已经简化了将token放到请求的属性中这一任务。</p>
<h1><span id="认证用户">认证用户</span></h1><p>如果我们使用如下的最简单的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spitter.config;</span><br><span class="line">......</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>那么就能地得到一个登陆页面：</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/112.png" alt="112"></p>
<p>实际上，在重写configure(HttpSecurity)之前，我们都能使用一个简单却功能完备的登录页。但是，一旦重写了configure(HttpSecurity)方法，就是失去了这个简单的登录界面。不过，这个功能要找回也容易。我们只需要在configure(HttpSecurity)方法中，<strong><em>调用formLogin()</em></strong>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    http</span><br><span class="line">        .formLogin()</span><br><span class="line">        .and()</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">"/spitter/me"</span>).hasRole(<span class="string">"SPITTER"</span>)</span><br><span class="line">        .antMatchers(HttpMethod.POST,<span class="string">"/spittles"</span>).hasRole(<span class="string">"SPITTER"</span>)</span><br><span class="line">        .anyRequest().permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .requiresChannel()</span><br><span class="line">        .antMatchers(<span class="string">"/spitter/form"</span>).requiresSecure();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们访问应用的“/login”链接或者导航到需要认证的页面，那么将会在浏览器中展现登录界面。这个界面在审美上没什么令人兴奋的，但是它却能实现所需的功能。</p>
<h2><span id="添加自定义的登录页">添加自定义的登录页</span></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spitter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"text/css"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">th:href</span>=<span class="string">"@&#123;/resources/style.css&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">'document.f.username.focus();'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span> <span class="attr">th:include</span>=<span class="string">"page :: header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/spitter/register&#125;"</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">'f'</span> <span class="attr">th:action</span>=<span class="string">'@&#123;/login&#125;'</span> <span class="attr">method</span>=<span class="string">'POST'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>User:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">name</span>=<span class="string">'username'</span> <span class="attr">value</span>=<span class="string">''</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'password'</span> <span class="attr">name</span>=<span class="string">'password'</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">'2'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"remember_me"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"remember_me"</span> <span class="attr">class</span>=<span class="string">"inline"</span>&gt;</span>Remember me<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">'2'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span> <span class="attr">th:include</span>=<span class="string">"page :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="启用-http-basic-认证">启用 Http Basic 认证</span></h2><p>如果要启用HTTP Basic认证的话，只需要在configure()方法所传入的HttpSecurity对象上调用httpBasic()即可。另外，还可以通过调用realmName()方法指定域。如下是在Spring Security中启用HTTP Basic认证的典型配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    http</span><br><span class="line">        .formLogin()</span><br><span class="line">        .loginPage(<span class="string">"/login"</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .httpBasic()</span><br><span class="line">        .realmName(<span class="string">"Spittr"</span>)</span><br><span class="line">        .and()</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在httpBasic()方法中，并没有太多的可配置项，甚至不需要什么额外配置。HTTP Basic认证要么开启，要么关闭。</p>
<h2><span id="启用remember-me功能">启用Remember-me功能</span></h2><p>站在用户的角度来讲，如果应用程序不用每次都提示他们登录是更好的。这就是为什么许多站点提供了Remember-me功能。你只要登录过一次，应用就会记住你。<br>Spring Security使得为应用添加Remember-me功能变得非常容易。只需要在configure()方法所传入的HttpSecurity对象上调用 <strong><em>rememberMe()</em></strong> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    http</span><br><span class="line">        .formLogin()</span><br><span class="line">        .loginPage(<span class="string">"/login"</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        .tokenValiditySeconds(<span class="number">2419200</span>)</span><br><span class="line">        .key(<span class="string">"spittrKey"</span>)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这个功能是通过在Cookie中存储一个token完成的，这个token最多两周内有效。但是，在这里，我们指定这个token最多四周内有效（2,419,200秒）。存储在cookie中的token包含用户名、密码、过期时间和一个私匙——在写入cookie前都进行了MD5哈希。默认情况下，私匙的名为SpringSecured，但是这里我们将其设置为spitterKey，使他专门用于Spittr应用。<br>既然Remember-me功能已经启用，我们需要有一种方式来让用户表明他们希望应用程序记住他们。为了实现这一点，登录请求必须包含一个名为remember-me的参数。在登录表单中，增加一个简单复选框就可以完成这件事：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"remember-me"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lable</span> <span class="attr">for</span>=<span class="string">"remember-me"</span> <span class="attr">class</span>=<span class="string">"inline"</span>&gt;</span>Remember me<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="退出">退出</span></h2><p>其实，按照我们的配置，退出功能已经可以使用了，不需要再做其他的配置了。我们需要的只是一个使用该功能的链接。  </p>
<p>退出功能是通过Servlet容器的Filter实现的（默认情况下），这个Filter会拦截针对“/logout”的请求。在新版本的SpringSecurity中，出于安全的考虑（防止CSRF攻击），已经修改了LogoutFilter，使得Get方式的“/logout”请求不可用。必须以POST方式发起对该链接的请求才能生效。因此，为应用添加退出功能只需要添加如下表单即可（如下以Thymeleaf代码片段的形式进行了展现）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/logout&#125;"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提交这个表单，会发起对“/logout”的请求，这个请求会被Spring Security的LogoutFilter所处理。用户会退出应用，所有的Remember-me token都会被清楚掉。在退出完成后，用户浏览器将会重定向到“/login?logout”，从而允许用户进行再次登录。如果希望被重定向到其他的页面，如应用的首页，那么可以在configure()中进行配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    http</span><br><span class="line">        .formLogin()</span><br><span class="line">        .loginPage(<span class="string">"/login"</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .logout()</span><br><span class="line">        .logoutSuccessUrl(<span class="string">"/"</span>)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了logoutSuccessUrl()方法之外，你可能还希望重写默认的LogoutFilter拦截路径。我们可以通过调用logoutUrl()方法实现这一功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.logout()</span><br><span class="line">   .logoutSuccessUrl(<span class="string">"/"</span>)</span><br><span class="line">   .logoutUrl(<span class="string">"/signout"</span>)</span><br></pre></td></tr></table></figure>

<h1><span id="注解与spring-el">注解与Spring EL</span></h1><ul>
<li><strong>@EnableWebSecurity：</strong>开启 Spring Security 注解</li>
<li><strong>@EnableGlobalMethodSecurity(prePostEnabled=true)</strong>：开启 security 方法注解</li>
<li><strong>@PreAuthorize：</strong>在方法调用前，通过SpringEL表达式限制方法访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('ROLE_ADMIN')"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果具有权限 ROLE_ADMIN 访问该方法</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@PostAuthorize：允许方法调用，但时如果表达式结果为false抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//returnObject可以获取返回对象user，判断user属性username是否和访问该方法的用户对象的用户名一样。不一样则抛出异常。</span></span><br><span class="line"><span class="meta">@PostAuthorize</span>(<span class="string">"returnObject.user.username==principal.username"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">   <span class="comment">//允许进入</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> user;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@PostFilter</strong>：允许方法调用，但必须按表达式过滤方法结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将结果过滤，即选出性别为男的用户</span></span><br><span class="line"><span class="meta">@PostFilter</span>(<span class="string">"returnObject.user.sex=='男' "</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//允许进入</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> user;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@PreFilter</strong>：允许方法调用，但必须在进入方法前过滤输入值</li>
</ul>
<h2><span id="spring-el-表达式">Spring EL 表达式：</span></h2><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hasRole ([role])</td>
<td align="center">当前用户是否拥有指定角色</td>
</tr>
<tr>
<td align="center">hasAnyRole([role1,role2])</td>
<td align="center">多个角色是一个以逗号进行分隔的字符串。如果当前用户拥有指定角色中的任意一个则返回true</td>
</tr>
<tr>
<td align="center">hasAuthority ([auth])</td>
<td align="center">等同于hasRole</td>
</tr>
<tr>
<td align="center">hasAnyAuthority([auth1,auth2])</td>
<td align="center">等同于 hasAnyRole</td>
</tr>
<tr>
<td align="center">Principle</td>
<td align="center">代表当前用户的 principle对象</td>
</tr>
<tr>
<td align="center">authentication</td>
<td align="center">直接从 Security context获取的当前 Authentication对象</td>
</tr>
<tr>
<td align="center">permitAll</td>
<td align="center">总是返回true,表示允许所有的访问</td>
</tr>
<tr>
<td align="center">denyAll</td>
<td align="center">总是返回false,表示拒绝所有的访问访问</td>
</tr>
<tr>
<td align="center">isAnonymous()</td>
<td align="center">当前用户是否是一个匿名用户</td>
</tr>
<tr>
<td align="center">isRememberMe</td>
<td align="center">表示当前用户是否是通过remember - me自动登录的</td>
</tr>
<tr>
<td align="center">isAuthenticated()</td>
<td align="center">表示当前用户是否已经登录认证成功了</td>
</tr>
<tr>
<td align="center">isFullAuthenticated()</td>
<td align="center">如果当前用户既不是一个匿名用户,同时又不是通过Remember-Me自动登录的,则返回true</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之插入排序</title>
    <url>/2020/03/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>把 n 个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含 1 个元素，无序表中包含有 n - 1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复 n - 1 次可完成排序的过程。</p>
</blockquote>
<a id="more"></a>

<p>直接插入排序的时间复杂度是 <strong><em>O(N^2)</em></strong>, 且是一个稳定的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;arr.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//插入的数</span></span><br><span class="line">        <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line">        <span class="comment">//被插入的位置(准备和前一个数比较)</span></span><br><span class="line">        <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果插入的数比被插入的数小</span></span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span>&amp;&amp;insertVal &lt; arr[index])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将把 arr[index] 向后移动</span></span><br><span class="line">            arr[index+<span class="number">1</span>]=arr[index];</span><br><span class="line">            <span class="comment">//让 index 向前移动</span></span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把插入的数放入合适位置</span></span><br><span class="line">        arr[index+<span class="number">1</span>]=insertVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法之二分查找</title>
    <url>/2020/03/24/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p>又称为 <strong>折半查找</strong>，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi=array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">        mid=(lo+hi)/<span class="number">2</span>;<span class="comment">//中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(array[mid] == key)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; key)&#123; <span class="comment">//向右查找</span></span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//向左查找</span></span><br><span class="line">            hi=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之快速排序</title>
    <url>/2020/03/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://zhuanlan.zhihu.com/p/57436476" target="_blank" rel="noopener">快速排序你真的会了吗？</a></p>
<p><a href="https://blog.csdn.net/MoreWindows/article/details/6684558" target="_blank" rel="noopener">白话经典算法系列之六 快速排序 快速搞定</a></p>
<blockquote>
<p>快速排序利用了分治的策略。而分治的基本基本思想是：将原问题划分为若干与原问题类似子问题，解决这些子问题，将子问题的解组成原问题的解。</p>
</blockquote>
<a id="more"></a>

<p>快速排序是在实践中最快的已知排序算法，平均运行时间为 <strong>O(NlogN)</strong>，最坏的运行时间为 <strong>O(N^2)</strong></p>
<p>该方法的基本思想是：</p>
<ol>
<li>先从数列中取出一个数作为基准数</li>
<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边</li>
<li>再对左右区间重复第二步，直到各区间只有一个数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = low;</span><br><span class="line">    <span class="keyword">int</span> end = high;</span><br><span class="line">    <span class="keyword">int</span> key = a[low]; </span><br><span class="line">    <span class="keyword">while</span>(end&gt;start)&#123;</span><br><span class="line">        <span class="comment">//从后往前比较</span></span><br><span class="line">        <span class="keyword">while</span>(end&gt;start&amp;&amp;a[end]&gt;=key) </span><br><span class="line">            <span class="comment">//如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span></span><br><span class="line">            end--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[end]&lt;=key)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[end];</span><br><span class="line">            a[end] = a[start];</span><br><span class="line">            a[start] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从前往后比较</span></span><br><span class="line">        <span class="keyword">while</span>(end&gt;start&amp;&amp;a[start]&lt;=key)</span><br><span class="line">            <span class="comment">//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span></span><br><span class="line">            start++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[start]&gt;=key)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[start];</span><br><span class="line">            a[start] = a[end];</span><br><span class="line">            a[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的</span></span><br><span class="line">        <span class="comment">//值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span>(start&gt;low) sort(a,low,start-<span class="number">1</span>);<span class="comment">//左边序列。第一个索引位置到关键值索引-1</span></span><br><span class="line">    <span class="keyword">if</span>(end&lt;high) sort(a,end+<span class="number">1</span>,high);<span class="comment">//右边序列。从关键值索引+1 到最后一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之冒泡排序</title>
    <url>/2020/03/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://juejin.im/post/5bbc7c6de51d450e5c47a26c" target="_blank" rel="noopener">漫画：什么是冒泡排序？</a></p>
<p>由于这几天即将参加 广发银行的广州分行 的技术面试。所以准备这几天 “临时抱佛脚”，看看能不能成功上岸哈哈。</p>
<p>记得大学学的冒泡排序是最简单的排序算法，没有任何的优化处理。参考了下前辈的文章，果然我跟优秀的人还是由很大的差距！</p>
<a id="more"></a>

<blockquote>
<p>冒泡排序的英文 <strong>Bubble Sort</strong>，是一种最基础的交换排序。</p>
</blockquote>
<p>该排序算法实现的效果有点像汽水中常常有许多小小的气泡，哗啦哗啦飘到上面来。</p>
<p>而我们的冒泡排序之所以叫做冒泡排序，正是因为这种排序算法的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。</p>
<p>原始的冒泡排序是 <strong><em>稳定的排序</em></strong>。由于该排序算法的每一轮要遍历所有元素，轮转的次数和元素数量相当，所以时间复杂度是<strong>O（N^2）</strong> 。</p>
<p>冒泡排序的第一版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp  = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;        </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)        </span><br><span class="line">		&#123;            </span><br><span class="line">			<span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])            </span><br><span class="line">			&#123;                </span><br><span class="line">				tmp = array[j];                </span><br><span class="line">				array[j] = array[j+<span class="number">1</span>];                </span><br><span class="line">				array[j+<span class="number">1</span>] = tmp;            </span><br><span class="line">			&#125;        </span><br><span class="line">		&#125;    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;    </span><br><span class="line">	sort(array);    </span><br><span class="line">	System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在排序的过程中可能出现已经有序的情况下，仍进行排序的话，就会造成许多的无用功。所以将排序进行了改良，性能得到大大的提升。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;    </span><br><span class="line">	<span class="keyword">int</span> tmp  = <span class="number">0</span>;    </span><br><span class="line">	<span class="comment">//记录最后一次交换的位置    </span></span><br><span class="line">	<span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;    </span><br><span class="line">	<span class="comment">//无序数列的边界，每次比较只需要比到这里为止    </span></span><br><span class="line">	<span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;        </span><br><span class="line">		<span class="comment">//有序标记，每一轮的初始是true        </span></span><br><span class="line">		<span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;        </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++)&#123;            </span><br><span class="line">			<span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])   </span><br><span class="line">			&#123;                </span><br><span class="line">				tmp = array[j];                </span><br><span class="line">				array[j] = array[j+<span class="number">1</span>];                </span><br><span class="line">				array[j+<span class="number">1</span>] = tmp;                </span><br><span class="line">				<span class="comment">//有元素交换，所以不是有序，标记变为false                </span></span><br><span class="line">				isSorted = <span class="keyword">false</span>;                </span><br><span class="line">				<span class="comment">//把无序数列的边界更新为最后一次交换元素的位置                </span></span><br><span class="line">				lastExchangeIndex = j;            </span><br><span class="line">			&#125;        </span><br><span class="line">		&#125;        </span><br><span class="line">		sortBorder = lastExchangeIndex;        </span><br><span class="line">		<span class="keyword">if</span>(isSorted)&#123;            </span><br><span class="line">			<span class="keyword">break</span>;        </span><br><span class="line">		&#125;    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;    </span><br><span class="line">	sort(array);    </span><br><span class="line">	System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Thread总结</title>
    <url>/2020/03/24/Java%E4%B9%8BThread%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>

<h1><span id="threadyield详解">Thread.yield详解</span></h1><p>转载自：</p>
<p><a href="https://blog.csdn.net/dabing69221/article/details/17426953" target="_blank" rel="noopener">Java Thread.yield详解</a></p>
<blockquote>
<p>使当前线程从 执行状态(运行状态) 变为 可执行状态(就绪状态).</p>
</blockquote>
<p>cpu 会从众多的 <strong>可执行态</strong> 里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其它线程而该线程在下一次中不会执行到。</p>
<p>Java线程中有一个Thread.yield( )方法，很多人翻译成线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行。</p>
<p>打个比方：现在有很多人在排队上厕所，好不容易轮到这个人上厕所了，突然这个人说：“我要和大家来个竞赛，看谁先抢到厕所！”，然后所有的人在同一起跑线冲向厕所，有可能是别人抢到了，也有可能他自己有抢到了。我们还知道线程有个优先级的问题，那么手里有优先权的这些人就一定能抢到厕所的位置吗? 不一定的，他们只是概率上大些，也有可能没特权的抢到了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker网络</title>
    <url>/2020/03/23/Docker%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.cnblogs.com/zuxing/articles/8780661.html" target="_blank" rel="noopener">Docker：网络模式详解</a></p>
<p>最近在使用 docker 部署 mall 商城的项目，可是在部署的时候碰到了错误，<code>docker: Error response from daemon: Cannot link to /mysql, as it does not belong to the default network</code>，后来发现 mysql 容器运行的网络空间确实不是默认的网络空间。看了网上的资料，发现可通过添加 <code>--net xxx_network_space</code> 来解决问题。可这是治标不治本的方法。因为修改了默认访问空间后，<code>mall-admin</code> 就无法注册到 <code>mall-registry</code> 上了(因为不在同一个网段下了)，最后通过重新运行一个新的 mysql 容器解决问题。</p>
<p>可是好奇心还是驱使我去了解下它的原理！</p>
<a id="more"></a>

<h1><span id="概述">概述</span></h1><p>Docker 自身的 4种网络工作方式，和一些自定义网络模式</p>
<p>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</p>
<ul>
<li><p><strong>host：</strong>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
</li>
<li><p><strong>Container</strong>：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</p>
</li>
<li><p><strong>None</strong>：该模式关闭了容器的网络功能。</p>
</li>
<li><p><strong>Bridge</strong>：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</p>
</li>
</ul>
<p>以上都是不用动手的，真正需要配置的是自定义网络。</p>
<h1><span id="默认网络">默认网络</span></h1><p>当你安装Docker时，它会自动创建三个网络。你可以使用以下docker network ls命令列出这些网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line">7fca4eb8c647        bridge              bridge</span><br><span class="line">9f904ee27bf5        none                null</span><br><span class="line">cf03ee007fb4        host                host</span><br></pre></td></tr></table></figure>

<p>Docker 内置这三个网络，运行容器时，可以使用 <code>--network</code> 标志来指定容器应该连接到哪些网络</p>
<p>该bridge网络代表docker0所有Docker安装中存在的网络。除非你使用该docker run –network=<network>选项指定，否则Docker守护程序默认将容器连接到此网络。</network></p>
<p>我们在使用docker run创建Docker容器时，可以用 –net 选项指定容器的网络模式，Docker可以有以下4种网络模式：</p>
<ul>
<li><p>host模式：使用 –net=host 指定。</p>
</li>
<li><p>none模式：使用 –net=none 指定。</p>
</li>
<li><p>bridge模式：使用 –net=bridge 指定，默认设置。</p>
</li>
<li><p>container模式：使用 –net=container:NAME_or_ID 指定。</p>
</li>
</ul>
<p>下面分别介绍一下Docker的各个网络模式。</p>
<h2><span id="host">Host</span></h2><p>相当于Vmware中的桥接模式，与宿主机在同一个网络中，但没有独立IP地址。众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p>例如，我们在10.10.0.186/24的机器上用host模式启动一个含有nginx应用的Docker容器，监听tcp80端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行容器;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name=nginx_host --net=host -p 80:80 -d nginx</span></span><br><span class="line">74c911272942841875f4faf2aca02e3814035c900840d11e3f141fbaa884ae5c</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps  </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">74c911272942        nginx               "nginx -g 'daemon ..."   25 seconds ago      Up 25 seconds                           nginx_host</span><br></pre></td></tr></table></figure>

<p>当我们在容器中执行任何类似ifconfig命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用10.10.0.186:80即可，不用任何NAT转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -nplt | grep nginx</span></span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      27340/nginx: master</span><br></pre></td></tr></table></figure>

<h2><span id="container">Container</span></h2><p>在理解了host模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>
<h2><span id="none">None</span></h2><p>该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以下两种情况下是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）。</p>
<p>overlay</p>
<p>在docker1.7代码进行了重构，单独把网络部分独立出来编写，所以在docker1.8新加入的一个overlay网络模式。Docker对于网络访问的控制也是在逐渐完善的。</p>
<h2><span id="bridge">Bridge</span></h2><p>相当于Vmware中的Nat模式，容器使用独立network Namespace，并连接到docker0虚拟网卡（默认模式）。通过docker0网桥以及Iptables nat表配置与宿主机通信；bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。下面着重介绍一下此模式。</p>
<h1><span id="bridge模式">Bridge模式</span></h1><h2><span id="bridge模式的拓扑">Bridge模式的拓扑</span></h2><p>当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。</p>
<p><strong>虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中</strong>。</p>
<p>接下来就要为容器分配IP了，Docker会从RFC1918所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如一般Docker会使用172.17.0.0/16这个网段，并将172.17.0.1/16分配给docker0网桥（在主机上使用ifconfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。单机环境下的网络拓扑如下，主机地址为10.10.0.186/24。</p>
<p><img src="https://img-blog.csdnimg.cn/2020032320545397.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2><span id="docker网络模式详解">Docker：网络模式详解</span></h2><p>Docker完成以上网络配置的过程大致是这样的：</p>
<ol>
<li><p>在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p>
</li>
<li><p>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.02425f21c208       no</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行容器;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name=nginx_bridge --net=bridge -p 80:80 -d nginx       </span></span><br><span class="line">9582dbec7981085ab1f159edcc4bf35e2ee8d5a03984d214bce32a30eab4921a</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE          COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">9582dbec7981        nginx          "nginx -g 'daemon ..."   3 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp   nginx_bridge</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器网络;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect 9582dbec7981</span></span><br><span class="line">"Networks": &#123;</span><br><span class="line">    "bridge": &#123;</span><br><span class="line">        "IPAMConfig": null,</span><br><span class="line">        "Links": null,</span><br><span class="line">        "Aliases": null,</span><br><span class="line">        "NetworkID": "9e017f5d4724039f24acc8aec634c8d2af3a9024f67585fce0a0d2b3cb470059",</span><br><span class="line">        "EndpointID": "81b94c1b57de26f9c6690942cd78689041d6c27a564e079d7b1f603ecc104b3b",</span><br><span class="line">        "Gateway": "172.17.0.1",</span><br><span class="line">        "IPAddress": "172.17.0.2",</span><br><span class="line">        "IPPrefixLen": 16,</span><br><span class="line">        "IPv6Gateway": "",</span><br><span class="line">        "GlobalIPv6Address": "",</span><br><span class="line">        "GlobalIPv6PrefixLen": 0,</span><br><span class="line">        "MacAddress": "02:42:ac:11:00:02"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network inspect bridge</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Name": "bridge",</span><br><span class="line">        "Id": "9e017f5d4724039f24acc8aec634c8d2af3a9024f67585fce0a0d2b3cb470059",</span><br><span class="line">        "Created": "2017-08-09T23:20:28.061678042-04:00",</span><br><span class="line">        "Scope": "local",</span><br><span class="line">        "Driver": "bridge",</span><br><span class="line">        "EnableIPv6": false,</span><br><span class="line">        "IPAM": &#123;</span><br><span class="line">            "Driver": "default",</span><br><span class="line">            "Options": null,</span><br><span class="line">            "Config": [</span><br><span class="line">                &#123;</span><br><span class="line">                    "Subnet": "172.17.0.0/16"</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        "Internal": false,</span><br><span class="line">        "Attachable": false,</span><br><span class="line">        "Ingress": false,</span><br><span class="line">        "Containers": &#123;</span><br><span class="line">            "9582dbec7981085ab1f159edcc4bf35e2ee8d5a03984d214bce32a30eab4921a": &#123;</span><br><span class="line">                "Name": "nginx_bridge",</span><br><span class="line">                "EndpointID": "81b94c1b57de26f9c6690942cd78689041d6c27a564e079d7b1f603ecc104b3b",</span><br><span class="line">                "MacAddress": "02:42:ac:11:00:02",</span><br><span class="line">                "IPv4Address": "172.17.0.2/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "Options": &#123;</span><br><span class="line">            "com.docker.network.bridge.default_bridge": "true",</span><br><span class="line">            "com.docker.network.bridge.enable_icc": "true",</span><br><span class="line">            "com.docker.network.bridge.enable_ip_masquerade": "true",</span><br><span class="line">            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",</span><br><span class="line">            "com.docker.network.bridge.name": "docker0",</span><br><span class="line">            "com.docker.network.driver.mtu": "1500"</span><br><span class="line">        &#125;,</span><br><span class="line">        "Labels": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>网络拓扑介绍完后，接着介绍一下bridge模式下容器是如何通信的。</p>
<h2><span id="bridge-模式下容器的通信">bridge 模式下容器的通信</span></h2><p>在bridge模式下，连在同一网桥上的容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，<strong>方法是在DOCKER_OPTS变量中设置–icc=false，这样只有使用–link才能使两个容器通信）</strong>。</p>
<p>Docker可以开启容器间通信（意味着默认配置–icc=true），也就是说，宿主机上的所有容器可以不受任何限制地相互通信，这可能导致拒绝服务攻击。进一步地，Docker可以通过–ip_forward和–iptables两个选项控制容器间、容器和外部世界的通信。</p>
<p>容器也可以与外部通信，我们看一下主机上的Iptable规则，可以看到这么一条</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-A POSTROUTING -s <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> ! -o docker0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。这么说可能不太好理解，举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p>
<p>那么，外面的机器是如何访问Docker容器的服务呢？我们首先用下面命令创建一个含有web应用的容器，将容器的80端口映射到主机的80端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --name=nginx_bridge --net=bridge -p 80:80 -d nginx</span></span><br></pre></td></tr></table></figure>

<p>然后查看Iptable规则的变化，发现多了这样一条规则：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-A DOCKER ! -i docker0 -p tcp -m tcp --dport <span class="number">80</span> -j DNAT --to-destination <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>此条规则就是对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中的服务。</p>
<p>除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的。</p>
<h1><span id="自定义网络">自定义网络</span></h1><p>建议使用自定义的网桥来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。Docker提供了创建这些网络的默认网络驱动程序，你可以创建一个新的Bridge网络，Overlay或Macvlan网络。你还可以创建一个网络插件或远程网络进行完整的自定义和控制。</p>
<p>你可以根据需要创建任意数量的网络，并且可以在任何给定时间将容器连接到这些网络中的零个或多个网络。此外，您可以连接并断开网络中的运行容器，而无需重新启动容器。当容器连接到多个网络时，其外部连接通过第一个非内部网络以词法顺序提供。</p>
<p>接下来介绍Docker的内置网络驱动程序。</p>
<h2><span id="bridge">bridge</span></h2><p>一个bridge网络是Docker中最常用的网络类型。桥接网络类似于默认bridge网络，但添加一些新功能并删除一些旧的能力。以下示例创建一些桥接网络，并对这些网络上的容器执行一些实验。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network create --driver bridge new_bridge</span></span><br></pre></td></tr></table></figure>

<p>创建网络后，可以看到新增加了一个网桥（172.18.0.1）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line">br-f677ada3003c: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.0.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        ether 02:42:2f:c1:db:5a  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 4001976  bytes 526995216 (502.5 MiB)</span><br><span class="line">        RX errors 0  dropped 35  overruns 0  frame 0</span><br><span class="line">        TX packets 1424063  bytes 186928741 (178.2 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"> </span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:5fff:fe21:c208  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:5f:21:c2:08  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 12  bytes 2132 (2.0 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 24  bytes 2633 (2.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<h2><span id="macvlan">Macvlan</span></h2><p>Macvlan是一个新的尝试，是真正的网络虚拟化技术的转折点。Linux实现非常轻量级，因为与传统的Linux Bridge隔离相比，它们只是简单地与一个Linux以太网接口或子接口相关联，以实现网络之间的分离和与物理网络的连接。</p>
<p>Macvlan提供了许多独特的功能，并有充足的空间进一步创新与各种模式。这些方法的两个高级优点是绕过Linux网桥的正面性能以及移动部件少的简单性。删除传统上驻留在Docker主机NIC和容器接口之间的网桥留下了一个非常简单的设置，包括容器接口，直接连接到Docker主机接口。由于在这些情况下没有端口映射，因此可以轻松访问外部服务。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8接口新特性</title>
    <url>/2020/03/23/Java8%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://blog.csdn.net/aitangyong/article/details/54134385" target="_blank" rel="noopener">JDK8新特性：接口的静态方法和默认方法</a></p>
<h1><span id="jdk8接口新特性">JDK8接口新特性</span></h1><p>在 JDK8 之前，interface的方法和变量规定如下：</p>
<ul>
<li>变量必须是 public，static，final</li>
<li>方法必须是 public，abstract 的</li>
</ul>
<a id="more"></a>

<p>由于修饰符都是默认的，所以在 JDK8 之前，下面的写法都是等价的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JDK8BeforeInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> field1 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> field2 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK8及以后，允许我们在接口中定义 <strong><em>static</em></strong> 方法和 <strong><em>default</em></strong> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JDK8Interface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// static修饰符定义静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// default修饰符定义默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口中的默认方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">JDK8Interface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现接口后，因为默认方法不是抽象方法，所以可以不重写，但是如果开发需要，也可以重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法，只能通过接口名调用，不可以通过实现的类名或者实现类的对象调用。</p>
<p>default方法，只能通过接口实现类的对象来调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// static方法必须通过接口类调用</span></span><br><span class="line">        JDK8Interface.staticMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//default方法必须通过实现类的对象调用</span></span><br><span class="line">        <span class="keyword">new</span> JDK8InterfaceImpl().defaultMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java支持一个实现类可以实现多个接口，如果多个接口中存在同样的static和default方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为jdk8只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。但是如果两个接口中定义了一模一样的默认方法，并且一个实现类同时实现了这两个接口，那么必须在实现类中重写默认方法，否则编译失败。</p>
<h1><span id="jdk8-抽象类和接口的区别">JDK8, 抽象类和接口的区别</span></h1><h2><span id="抽象">抽象</span></h2><ol>
<li>抽象类中可以由构造方法</li>
<li>抽象类中可以存在普通属性，方法，静态属性和方法</li>
<li>抽象类中可以存在抽象方法</li>
<li>抽象类中可以存在抽象方法</li>
<li>如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法</li>
<li>抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的</li>
</ol>
<h2><span id="接口">接口</span></h2><ol>
<li>在接口中只有常量，因为定义的变量，在编译的时候都会默认加上 public static final </li>
<li>接口中没有构造方法，也不能实例化接口的对象。</li>
<li>接口可以实现多继承</li>
<li>接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。</li>
</ol>
<h1><span id="面试的回答">面试的回答</span></h1><ol>
<li>从设计层面上讲，抽象类是 <strong>类的抽象</strong>, 接口是 <strong>行为抽象</strong>。</li>
<li>抽象类有构造方法；接口没有</li>
<li>接口可以实现多继承；抽象类不行</li>
<li>抽象类可以有普通成员变量；接口中的变量只能是常量</li>
<li>抽象类不一定有抽象方法；接口必须有</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud之OpenFeign总结</title>
    <url>/2020/03/23/SpringCloud%E4%B9%8BOpenFeign%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/2.2.2.RELEASE/reference/html/" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>Feign 是一个声明式的 WebService 服务客户端, 让编写 Web 服务客户端更加容易，只需创建一个接口并在接口上添加注解</p>
</blockquote>
<a id="more"></a>

<p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200323160326858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200323153456465"></p>
<p>OpenFeign 的日志输出级别</p>
<ul>
<li><strong>NONE：</strong>默认的，不显示任何日志</li>
<li><strong>BASIC：</strong>仅记录请求方法，URL，响应状态码及执行时间</li>
<li><strong>HEADERS：</strong>除了 BASIC 中定义的信息之外，还有请求和响应的头信息</li>
<li>*<em>FULL: *</em>除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud之Gateway总结</title>
    <url>/2020/03/22/SpringCloud%E4%B9%8BGateway%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://www.bilibili.com/video/av93813318?p=66" target="_blank" rel="noopener">尚硅谷</a></p>
<p><a href="https://www.cicoding.cn/springcloud/spring-cloud-gateway-route-forwarding/" target="_blank" rel="noopener">聊聊Spring Cloud Gateway网关路由</a></p>
<p><a href="https://www.jianshu.com/p/af1554553b5c" target="_blank" rel="noopener">Spring GateWay 路由源码分析</a></p>
<blockquote>
<p>SpringCloud Gateway 使用的 Webflux 中的 reactor-netty 响应式编程组件，底层使用了 Netty 通讯框架</p>
</blockquote>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200322233751799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200322232150746"></p>
<p>在 SpringCloud Finchley 正式版之前，SpringCloud 推荐的网关是 Netflix 提供的 Zuul</p>
<ol>
<li>Zuul 1.x 是一个基于阻塞 I/O 的 API Gateway</li>
<li>Zuul 1.x <strong>基于 Servlet 2.5 使用阻塞架构</strong> 它不支持任何长连接(如 WebSocket) Zuul 的设计模式和 Nginx 很像，每次 I/O 操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成</li>
<li>Spring Cloud Gateway 建立在 Spring Framework5, Project Reactor 和 Spring Boot 2 之上，使用非阻塞 API</li>
<li>Spring Cloud Gateway 还支持 WebSocket</li>
</ol>
<p>传统的 Web 框架，比如说：Struts2，SpringMVC 等都是基于 Servlet API 与 Servlet 容器基础之上运行的</p>
<p>但是在 Servlet3.1 之后有了异步非阻塞的支持。而 WebFlux 是一个典型的非阻塞异步的框架，它的核心是基于 Reactor 的相关 API 实现的。</p>
<p>Spring WebFlux 是 Spring5.0 引入的新的响应式框架，区别于 SpringMVC，它不需要依赖 Servlet API，它是完全异步非阻塞的，并且基于 Reactor 来实现响应式流规范</p>
<p><img src="https://img-blog.csdnimg.cn/20200323162617378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200323085301908"></p>
<h1><span id="三大核心概念">三大核心概念</span></h1><ul>
<li><strong>Route(路由)</strong></li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">路由是构建网关的基本模块, 它由ID, 目标URI, 一系列的断言和过滤器组成, 如果断言为<span class="literal">true</span>则匹配该路由</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Predicate(断言)</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">参考的是 <span class="selector-tag">Java8</span> 的 <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.function</span><span class="selector-class">.Predicate</span></span><br><span class="line">开发人员可以匹配 <span class="selector-tag">HTTP</span> 请求中的所有内容(例如请求头或请求参数), 如果请求与断言相匹配则进行路由</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200323162639747.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="聊聊Spring Cloud Gateway的PrefixPath及StripPrefix功能"></p>
<ul>
<li><strong>Filter(过滤器)</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指的是 Spring 框架中 GatewayFilter 的实例, 使用过滤器,可以在请求被路由前或者之后对请求进行修改</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200323162659704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200323085732682"></p>
<p>官网 Gateway 处理请求如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200323162714867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="Spring Cloud Gateway Diagram"></p>
<p>客户端向 Spring Cloud Gateway 发出请求, 然后在 Gateway Handler Mapping 中找到与请求相匹配的路由,  将其发送到 Gateway Web Handler</p>
<p>Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p>
<p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前 (“pre”) 或之后 (“post”) 执行业务逻辑</p>
<p>Filter 在 “<strong>pre</strong>“ 类型的过滤器可以做参数校验，权限校验, 流量监控，日志输出，协议转换等; 在 “<strong>post</strong>“ 类型的过滤器中可以做响应内容，响应头的修改，日志的输出，流量监控等非常重要的作用</p>
<h1><span id="gatewayfilter-factories">GatewayFilter Factories</span></h1><p>路由过滤器可用于修改进入的 HTTP 请求和返回的 HTTP 响应, 路由过滤器只能指定路由进行使用</p>
<p>SpringCloud Gateway 内置了多种路由过滤器，它们都是由 GatewayFilter 的工厂类来产生</p>
<h1><span id="yml中配置路由">yml中配置路由</span></h1><p>示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span> <span class="comment">#使用小写服务名，默认是大写</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001 #匹配提供服务的路由地址(路由地址写死，避免)</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言, 路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">            <span class="comment">#uri: http://localhost:8001 #匹配提供服务的路由地址</span></span><br><span class="line">            <span class="attr">uri:</span> <span class="string">lb://服务名称</span></span><br><span class="line">            <span class="attr">predicates:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span> <span class="comment">#断言, 路径相匹配的进行路由</span></span><br></pre></td></tr></table></figure>

<h1><span id="编码方式配置路由">编码方式配置路由</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">            .route(<span class="string">"path_route2"</span>,r -&gt; r.path(<span class="string">"/user/getByUsername"</span>)</span><br><span class="line">                   .uri(<span class="string">"http://localhost:8201/user/getByUsername"</span>))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <strong><em>url</em></strong> 后面接上 <code>/user/getByUsername</code> 则会跳转至 <code>http://localhost:8201/user/getByUsername</code> 进行访问</p>
<h1><span id="自定义过滤器">自定义过滤器</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGatewayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"***********************come in MyLogGatewayFilter："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">"*********用户名为 null，非法用户"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//过滤器数值越低, 优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <strong><em>url</em></strong> 后面携带的参数不是 uname 格式，或者格式不正确 ，就会返回 <code>401 UNAUTHORIZED</code> 未授权的错误</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker错误总结</title>
    <url>/2020/03/22/Docker%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>好记忆不如烂笔头</p>
</blockquote>
<h1><span id="1docker-error-response-from-daemon-cannot-link-to-mysql-as-it-does-not-belong-to-the-default-network">1.docker: Error response from daemon: Cannot link to /mysql, as it does not belong to the default network</span></h1><p>参考</p>
<p><a href="https://lhalcyon.com/docker-networklink-issue/" target="_blank" rel="noopener">无法链接到由docker-compose启动的正在运行的容器问题解决</a></p>
<p>首先要通过 <code>--link mysql</code>, 链接到 mysql。通过 <code>docker inspect mysql</code> ，可以看到</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200322223814662.png#pic_center" alt="image-20200322223735944"></p>
<p>首先通过命令列出所有 docker 网络 .</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200322223828851.png#pic_center" alt="image-20200322223220201"></p>
<p>docker-compose 在运行时会创建一个新的网络 .例如在我遇到的情况中,是已有一个由 docker-compose 运行的 base-service_default 的网络 , 后面想通过 <code>docker run xxx</code> 命令链接上 <code>base-service_default</code> 网络 .</p>
<p>原来的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:8080 --name mall-admin \</span><br><span class="line">--link 679 \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/admin/logs:/var/logs \</span><br><span class="line">-d mall/mall-admin:1.0-SNAPSHOT</span><br></pre></td></tr></table></figure>

<p>正确的运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:8080 --name mall-admin \</span><br><span class="line">--link 679 \</span><br><span class="line">--net base-service_default \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/admin/logs:/var/logs \</span><br><span class="line">-d mall/mall-admin:1.0-SNAPSHOT</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker可视化管理工具</title>
    <url>/2020/03/22/Docker%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/deploy/mall_swarm_deploy_docker?id=可视化管理工具" target="_blank" rel="noopener">可视化管理工具</a></p>
<blockquote>
<p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便的管理Docker环境，包括单机环境和集群环境</p>
</blockquote>
<ul>
<li>官网地址：<a href="https://github.com/portainer/portainer" target="_blank" rel="noopener">https://github.com/portainer/portainer</a></li>
<li>获取Docker镜像文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull portainer/portainer</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>使用docker容器运行Portainer：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 9000:9000 -p 8000:8000 --name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v /mydata/portainer/data:/data \</span><br><span class="line">-d portainer/portainer</span><br></pre></td></tr></table></figure>

<ul>
<li>查看Portainer的DashBoard信息：</li>
</ul>
<p><img src="http://www.macrozheng.com/images/mall_swarm_linux_01.png" alt="img"></p>
<ul>
<li>查看所有运行中的容器信息：</li>
</ul>
<p><img src="http://www.macrozheng.com/images/mall_swarm_linux_02.png" alt="img"></p>
<ul>
<li>查看所有已经下载的Docker镜像：</li>
</ul>
<p><img src="http://www.macrozheng.com/images/mall_swarm_linux_03.png" alt="img"></p>
<ul>
<li>查看<code>mall-portal</code>应用的统计信息：</li>
</ul>
<p><img src="http://www.macrozheng.com/images/mall_swarm_linux_04.png" alt="img"></p>
<ul>
<li>查看<code>mall-portal</code>应用的运行过程中打印的日志信息：</li>
</ul>
<p><img src="http://www.macrozheng.com/images/mall_swarm_linux_05.png" alt="img"></p>
<ul>
<li>进入<code>mall-portal</code>应用的容器内部来操作容器内部系统：</li>
</ul>
<p><img src="http://www.macrozheng.com/images/mall_swarm_linux_06.png" alt="img"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>mall-swarm优秀项目学习总结</title>
    <url>/2020/03/22/mall-swarm%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://mp.weixin.qq.com/s/K46F_Yuh8xhOmK_2qjfLkw" target="_blank" rel="noopener">文章</a></p>
<p><a href="https://github.com/macrozheng/mall-swarm" target="_blank" rel="noopener">项目地址</a></p>
<h1><span id="结构">结构</span></h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mall</span><br><span class="line">├── mall-common <span class="comment">-- 工具类及通用代码模块</span></span><br><span class="line">├── mall-mbg <span class="comment">-- MyBatisGenerator生成的数据库操作代码模块</span></span><br><span class="line">├── mall-<span class="keyword">security</span> <span class="comment">-- 封装SpringSecurity+JWT的安全认证的模块</span></span><br><span class="line">├── mall-registry <span class="comment">-- 基于Eureka的微服务注册中心</span></span><br><span class="line">├── mall-config <span class="comment">-- 基于Spring Cloud Config的微服务配置中心</span></span><br><span class="line">├── mall-gateway <span class="comment">-- 基于Spring Cloud Gateway的微服务API网关服务</span></span><br><span class="line">├── mall-monitor <span class="comment">-- 基于Spring Boot Admin的微服务监控中心</span></span><br><span class="line">├── mall-<span class="keyword">admin</span> <span class="comment">-- 后台管理系统服务</span></span><br><span class="line">├── mall-<span class="keyword">search</span> <span class="comment">-- 基于Elasticsearch的商品搜索系统服务</span></span><br><span class="line">├── mall-portal <span class="comment">-- 移动端商城系统服务</span></span><br><span class="line">└── mall-demo <span class="comment">-- 微服务远程调用测试服务</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1><span id="mall-security">mall-security</span></h1><p>##</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>mall</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架之gRPC</title>
    <url>/2020/03/22/RPC%E6%A1%86%E6%9E%B6%E4%B9%8BgRPC/</url>
    <content><![CDATA[<p>gradlew = gradle + wrapper</p>
<p>该命令可允许运行环境不存在 gradle 的文件或者文件，通过这个命令会下载相关的 gradle 运行环境以及文件</p>
<a id="more"></a>

<p>未完成…</p>
]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件Kafka</title>
    <url>/2020/03/21/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://lotabout.me/2018/kafka-introduction/" target="_blank" rel="noopener">Kafka 入门介绍</a></p>
<h1><span id="概述">概述</span></h1><blockquote>
<p>kafka 是一个 <strong>分布式</strong> 的基于 <strong>发布/订阅模式</strong> 的 <strong>消息队列</strong>, 主要应用于大数据实时处理领域</p>
</blockquote>
<a id="more"></a>

<h1><span id="mq传统应用场景之异步处理">MQ传统应用场景之异步处理</span></h1><p><img src="https://img-blog.csdnimg.cn/20200322221342646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200322162858699"></p>
<h1><span id="使用消息队列的好处">使用消息队列的好处</span></h1><ul>
<li>解耦</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">允许你独立的扩展或修改两边的处理过程,只要确保它们遵守同样的接口约束</span><br></pre></td></tr></table></figure>

<ul>
<li>可恢复性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统的一部分组件失效时, 不会影响到整个系统。消息队列降低了进程间的耦合度,所以即使一个处理消息的进程挂掉,加入队列中的消息仍然可以在系统恢复后被处理</span><br></pre></td></tr></table></figure>

<ul>
<li>缓冲</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有助于控制和优化数据流经过系统的速度,解决生产消息和消费消息的处理速度不一致的情况</span><br></pre></td></tr></table></figure>

<ul>
<li>灵活性 &amp;  峰值处理能力</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">在访问量剧增的情况下, 应用仍然需要继续发挥作用，但是这样的突发流量并不常见。使用消息队列能够使关键组件顶住突发的访问压力,而不会因为突发的超负荷的请求而完全崩溃.</span><br></pre></td></tr></table></figure>

<h1><span id="消息队列的两种模式">消息队列的两种模式</span></h1><h2><span id="点对点模式">点对点模式</span></h2><p>一对一，消费者主动拉取数据，消息收到后消息清除</p>
<p>消息生产者生产消息发送到 Queue 种，然后消息消费者从 Queue 中取出并且消费消息。消息被消费后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>
<p><img src="https://img-blog.csdnimg.cn/20200324163814977.png#pic_center" alt="image-20200323212356791"></p>
<h2><span id="发布订阅模式">发布订阅模式</span></h2><p>一对多，消费者消费数据之后不会清除消息</p>
<p>消息生产者 (发布) 将消息发布到 topic 中，同时有多个消息消费者 (订阅) 消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费</p>
<p><img src="https://img-blog.csdnimg.cn/20200324163834909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200323212620425"></p>
<h1><span id="kafka-工作流程及文件存储机制">Kafka 工作流程及文件存储机制</span></h1><p><img src="https://img-blog.csdnimg.cn/2020032416384885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200324110116815"></p>
<p>在图中，各个名词的解释：</p>
<ul>
<li><strong>broker：</strong>一个broker就是一个节点，由众多的节点构成一个 Kafka 集群</li>
<li><strong>Topic：</strong>直译为 <strong>主题</strong>。生产者与消费者交互数据的地方</li>
<li><strong>leader 和 follower：</strong>在每个节点中都有两个 <strong>replication(即副本)</strong>，每个leader 的 follower 都不在同一个节点中，为了防止某个节点 down 机，导致这个 topic 所有数据丢失。follower 的主要作用是为了备份 leader 的数据。</li>
<li><strong>offset：</strong>偏移量，记录数据保存的下标。consumer 每次消费完数据后都会记录 offset</li>
</ul>
<p><strong>topic</strong> 是逻辑上的概念，而 <strong>partition</strong> 是物理上的概念，每个 partition 对应于一个 <strong>log</strong> 文件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log <strong>文件末端</strong>，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己消费到哪个 offset。以便出错恢复时，从上次的位置继续消费。</p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM知识点集合</title>
    <url>/2020/03/21/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2><span id="1">1</span></h2><p>JVM 内存可简单分为三个区：</p>
<ol>
<li><strong>堆区(heap)</strong>: 用于存放所有对象，是线程共享的</li>
<li><strong>栈区(stack)</strong>: 用于存放基本数据类型的数据和对象的引用，是线程私有的(分为：虚拟机栈和本地方法栈)</li>
<li><strong>方法区(method):</strong> 用于存放类信息，常量，静态变量，编译后的字节码等，是线程共享的(也被称为非堆，即None-Heap)</li>
</ol>
<p><strong>Java 的垃圾回收器(GC) 主要针对堆区</strong></p>
<a id="more"></a>

<h2><span id="2">2</span></h2><p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2><span id="jvm-生命周期">JVM 生命周期</span></h2><h3><span id="虚拟机启动">虚拟机启动</span></h3><p>Java 虚拟机的启动是通过<strong>引导类加载器</strong>(bootstrap class loader)创建一个初始类(initial class)来完成，这个类是由虚拟机的具体实现指定的</p>
<h3><span id="虚拟机的执行">虚拟机的执行</span></h3><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li>
<li>程序开始执行时他才运行，程序结束时就停止</li>
<li>执行一个所谓的Java程序的时候，真正在执行的是一个叫做Java虚拟机的进程</li>
</ul>
<h3><span id="虚拟机退出">虚拟机退出</span></h3><p>有如下几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机终止</li>
<li>某线程调用Runtime类 或 System 类的exit方法，或halt方法</li>
</ul>
<h2><span id="类加载器及类加载过程">类加载器及类加载过程</span></h2><p><img src="https://img-blog.csdnimg.cn/20200321102825441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200208133950667"></p>
<ul>
<li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由 <strong>Execution Engine决定</strong> </li>
<li>加载的类信息存放于一块称为 <strong>方法区的内存空间。</strong>除了类的信息外，方法区还会存放运行时<strong>常量池信息</strong>，可能还包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)</li>
</ul>
<h3><span id="类加载器classloader角色">类加载器ClassLoader角色</span></h3><ol>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例</li>
<li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区</li>
<li>在 .class 文件 -&gt; JVM -&gt; 最终成为元数据模板，此过程就要一个 <strong>运输工具(类加载器 Class Loader)</strong> , 扮演一个<strong>快递员</strong>的角色</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020032110285062.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="image-20200208135633071"></p>
<h3><span id="类加载过程">类加载过程</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321102910207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200208140055491"></p>
<h4><span id="加载">加载：</span></h4><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的放嗯入口</li>
</ol>
<h4><span id="链接">链接：</span></h4><p><img src="https://img-blog.csdnimg.cn/20200321102926237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200208140713449"></p>
<h4><span id="初始化">初始化：</span></h4><ul>
<li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程</li>
<li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li>&lt;clinit&gt;() 不同于类的构造器</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;() 方法在多线程下被同步加锁</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321102941718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211212324816"></p>
<h3><span id="类加载器的分类">类加载器的分类</span></h3><ul>
<li>JVM 支持两种类加载器，分别为 <strong>引导类加载器(Bootstrap ClassLoader)</strong> 和 <strong>自定义类加载器(User-Defined ClassLoader)</strong></li>
<li>从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范没有这么定义，而是 <strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li>
</ul>
<h4><span id="关于-class-loader">关于 Class Loader</span></h4><p>ClassLoader 类，它是一个<strong>抽象类</strong>，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器)</p>
<p><img src="https://img-blog.csdnimg.cn/20200321102957103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211215059187"></p>
<p>自定义类加载器源码</p>
<p>Launcher.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandlerFactory;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlContext;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.CodeSource;</span><br><span class="line"><span class="keyword">import</span> java.security.PermissionCollection;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedActionException;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedExceptionAction;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> sun.net.www.ParseUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandlerFactory factory = <span class="keyword">new</span> Launcher.Factory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandler fileHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Launcher.ExtClassLoader var1;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">        String var2 = System.getProperty(<span class="string">"java.security.manager"</span>);</span><br><span class="line">        <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SecurityManager var3 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">""</span>.equals(var2) &amp;&amp; !<span class="string">"default"</span>.equals(var2)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var3 = (SecurityManager)<span class="keyword">this</span>.loader.loadClass(var2).newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException var6) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var7) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassCastException var8) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var3 = <span class="keyword">new</span> SecurityManager();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create SecurityManager: "</span> + var2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.setSecurityManager(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URLClassPath <span class="title">getBootstrapClassPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Launcher.BootClassPathHolder.bcp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URL[] pathToURLs(File[] var0) &#123;</span><br><span class="line">        URL[] var1 = <span class="keyword">new</span> URL[var0.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">            var1[var2] = getFileURL(var0[var2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getClassPath(String var0) &#123;</span><br><span class="line">        File[] var1;</span><br><span class="line">        <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> var2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> var3 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> var4 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> var5;</span><br><span class="line">            <span class="keyword">int</span> var7;</span><br><span class="line">            <span class="keyword">for</span>(var5 = <span class="number">0</span>; (var7 = var0.indexOf(File.pathSeparator, var5)) != -<span class="number">1</span>; var5 = var7 + <span class="number">1</span>) &#123;</span><br><span class="line">                ++var3;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line">            var4 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var5 = <span class="number">0</span>; (var7 = var0.indexOf(File.pathSeparator, var5)) != -<span class="number">1</span>; var5 = var7 + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var7 - var5 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    var1[var2++] = <span class="keyword">new</span> File(var0.substring(var5, var7));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    var1[var2++] = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var5 &lt; var0.length()) &#123;</span><br><span class="line">                var1[var2++] = <span class="keyword">new</span> File(var0.substring(var5));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var1[var2++] = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2 != var3) &#123;</span><br><span class="line">                File[] var6 = <span class="keyword">new</span> File[var2];</span><br><span class="line">                System.arraycopy(var1, <span class="number">0</span>, var6, <span class="number">0</span>, var2);</span><br><span class="line">                var1 = var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> URL <span class="title">getFileURL</span><span class="params">(File var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var0 = var0.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ParseUtil.fileToEncodedURL(var0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">            <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">            <span class="keyword">super</span>(var1, var2, Launcher.factory);</span><br><span class="line">            <span class="keyword">this</span>.ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">            <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">                SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">                <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">                Class var5 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">                <span class="keyword">if</span> (var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.resolveClass(var5);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> var5;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PermissionCollection <span class="title">getPermissions</span><span class="params">(CodeSource var1)</span> </span>&#123;</span><br><span class="line">            PermissionCollection var2 = <span class="keyword">super</span>.getPermissions(var1);</span><br><span class="line">            var2.add(<span class="keyword">new</span> RuntimePermission(<span class="string">"exitVM"</span>));</span><br><span class="line">            <span class="keyword">return</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendToClassPathForInstrumentation</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">super</span>.addURL(Launcher.getFileURL(<span class="keyword">new</span> File(var1)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">            PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">            ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">            AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BootClassPathHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> URLClassPath bcp;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">BootClassPathHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            URL[] var0;</span><br><span class="line">            <span class="keyword">if</span> (Launcher.bootClassPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var0 = (URL[])AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;URL[]&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> URL[] run() &#123;</span><br><span class="line">                        File[] var1 = Launcher.getClassPath(Launcher.bootClassPath);</span><br><span class="line">                        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">                        HashSet var3 = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var2; ++var4) &#123;</span><br><span class="line">                            File var5 = var1[var4];</span><br><span class="line">                            <span class="keyword">if</span> (!var5.isDirectory()) &#123;</span><br><span class="line">                                var5 = var5.getParentFile();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (var5 != <span class="keyword">null</span> &amp;&amp; var3.add(var5)) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(var5);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> Launcher.pathToURLs(var1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var0 = <span class="keyword">new</span> URL[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bcp = <span class="keyword">new</span> URLClassPath(var0, Launcher.factory, (AccessControlContext)<span class="keyword">null</span>);</span><br><span class="line">            bcp.initLookupCache((ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class var0 = Launcher.ExtClassLoader<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                <span class="keyword">synchronized</span>(Launcher.ExtClassLoader<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        instance = createExtClassLoader();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        File[] var1 = Launcher.ExtClassLoader.getExtDirs();</span><br><span class="line">                        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                            MetaIndex.registerDirectory(var1[var3]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException var1) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException)var1.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addExtURL</span><span class="params">(URL var1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.addURL(var1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">            String var0 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">            File[] var1;</span><br><span class="line">            <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">                <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">                var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                    var1[var4] = <span class="keyword">new</span> File(var2.nextToken());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> URL[] getExtURLs(File[] var0) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            Vector var1 = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">                String[] var3 = var0[var2].list();</span><br><span class="line">                <span class="keyword">if</span> (var3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3.length; ++var4) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!var3[var4].equals(<span class="string">"meta-index"</span>)) &#123;</span><br><span class="line">                            File var5 = <span class="keyword">new</span> File(var0[var2], var3[var4]);</span><br><span class="line">                            var1.add(Launcher.getFileURL(var5));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            URL[] var6 = <span class="keyword">new</span> URL[var1.size()];</span><br><span class="line">            var1.copyInto(var6);</span><br><span class="line">            <span class="keyword">return</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">            var1 = System.mapLibraryName(var1);</span><br><span class="line">            URL[] var2 = <span class="keyword">super</span>.getURLs();</span><br><span class="line">            File var3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var2.length; ++var4) &#123;</span><br><span class="line">                URI var5;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var5 = var2[var4].toURI();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (URISyntaxException var9) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                File var6 = Paths.get(var5).toFile().getParentFile();</span><br><span class="line">                <span class="keyword">if</span> (var6 != <span class="keyword">null</span> &amp;&amp; !var6.equals(var3)) &#123;</span><br><span class="line">                    String var7 = VM.getSavedProperty(<span class="string">"os.arch"</span>);</span><br><span class="line">                    File var8;</span><br><span class="line">                    <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        var8 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(var6, var7), var1);</span><br><span class="line">                        <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var8 = <span class="keyword">new</span> File(var6, var1);</span><br><span class="line">                    <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var3 = var6;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">            ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">            AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">            instance = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">URLStreamHandlerFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String PREFIX = <span class="string">"sun.net.www.protocol"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> URLStreamHandler <span class="title">createURLStreamHandler</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">            String var2 = PREFIX + <span class="string">"."</span> + var1 + <span class="string">".Handler"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class var3 = Class.forName(var2);</span><br><span class="line">                <span class="keyword">return</span> (URLStreamHandler)var3.newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ReflectiveOperationException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"could not load "</span> + var1 + <span class="string">"system protocol handler"</span>, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.free.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200321103017468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211215932039"></p>
<p>获取上层类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.free.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200321103033480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211220143673"></p>
<p>Java 核心类库都是使用 <strong>引导类加载器进行加载</strong></p>
<p>引导类加载器</p>
<p><img src="https://img-blog.csdnimg.cn/2020032110304999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211220932509"></p>
<p>扩展类加载器</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103104303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211221222697"></p>
<p>应用程序类加载器</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103117180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211221323558"></p>
<h3><span id="为什么需要自定义类加载器">为什么需要自定义类加载器</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321103133478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211221759736"></p>
<h3><span id="自定义类加载器的步骤">自定义类加载器的步骤</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321103200884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211222041729"></p>
<h3><span id="对类加载器的引用">对类加载器的引用</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321103217829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211225220425"></p>
<h2><span id="双亲委派机制">双亲委派机制</span></h2><p><img src="https://img-blog.csdnimg.cn/20200321103233525.png" alt="image-20200211222740092"></p>
<h3><span id="工作原理">工作原理</span></h3><ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是<strong>双亲委派机制</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200321103250438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211223930852"></p>
<h3><span id="沙箱安全机制">沙箱安全机制</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321103309486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211224941769"></p>
<h2><span id="类的主动使用和被动使用">类的主动使用和被动使用</span></h2><p><img src="https://img-blog.csdnimg.cn/20200321103324898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211225435415"></p>
<h2><span id="运行时数据区内部结构">运行时数据区内部结构</span></h2><p><img src="https://img-blog.csdnimg.cn/20200321103340570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211225957157"></p>
<p>阿里jvm示意图</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103354710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211230736650"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103415806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200211230839506"></p>
<p>每个虚拟机有且只对应一个 Runtime实例</p>
<h3><span id="线程">线程</span></h3><ul>
<li>线程是一个程序里的运行单元。JVM 允许一个应用由多个线程并行的执行</li>
<li>在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li>
</ul>
<h4><span id="jvm-系统线程">JVM 系统线程</span></h4><p><img src="https://img-blog.csdnimg.cn/20200321103435154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212101134300"></p>
<h3><span id="程序计数器">程序计数器</span></h3><p>JVM 中的 PC寄存器是对物理PC 寄存器的一种抽象模拟</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103451892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212101756499"></p>
<h3><span id="虚拟机栈">虚拟机栈</span></h3><p>由于跨平台的设计，Java 的指令都是根据 <strong>栈</strong> 来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的</p>
<p><em>优点：跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</em></p>
<h4><span id="内存中的栈与堆">内存中的栈与堆</span></h4><p>栈是 <strong>运行时</strong> 的单位，而堆是 <strong>存储</strong> 的单位</p>
<p>栈解决程序的运行问题，即 <em>程序如何执行，或者说如何处理数据</em>。堆解决的是数据存储的问题，即 <em>数据怎么放，放在哪儿</em>。</p>
<h4><span id="基本内容">基本内容</span></h4><p><img src="https://img-blog.csdnimg.cn/20200321103508455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212110233907"></p>
<h4><span id="优点">优点</span></h4><p><img src="https://img-blog.csdnimg.cn/20200321103526751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212111524501"></p>
<h4><span id="栈可能出现的异常">栈可能出现的异常</span></h4><p><img src="https://img-blog.csdnimg.cn/20200321103542451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212111911949"></p>
<h4><span id="设置栈内存大小">设置栈内存大小</span></h4><p>我们可以使用参数 -Xss 选项来设置线程的最大占空间，栈的大小直接决定了<strong>函数调用的最大可达深度</strong></p>
<h4><span id="栈的存储单位">栈的存储单位</span></h4><ul>
<li>每个线程都有自己的栈，栈中的数据都是以 *<em>栈帧(Stack Frame) *</em>的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h4><span id="栈运行原理">栈运行原理</span></h4><p><img src="https://img-blog.csdnimg.cn/2020032110361174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212125513737"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103632334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212125536047"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103648481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image"></p>
<h4><span id="栈帧的内部结构">栈帧的内部结构</span></h4><p><img src="https://img-blog.csdnimg.cn/20200321103703486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212130707269"></p>
<p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表</strong></li>
<li><strong>操作数栈</strong></li>
<li>动态链接(指向运行时常量池的方法引用)</li>
<li>方法返回地址 (方法正常退出或者异常退出的定义)</li>
<li>一些附加j信息</li>
</ul>
<h5><span id="局部变量表重要">局部变量表(重要)</span></h5><ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>定义一个数字数组，主要用于存储 <em>方法参数</em> 和 <em>定义在方法体内的局部变量</em>，这些数据类型包括各类<strong>基本数据类型</strong>，<strong>对象引用</strong>，以及<strong>returnAddress类型</strong></li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此 <em>不存在数据安全问题</em></li>
<li>局部变量表所需的容量大小是在 <em>编译期</em> 定下来的,并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表大小的</li>
</ul>
<h6><span id="变量槽slot">变量槽slot</span></h6><ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li>
<li>局部变量表，<em>最基本的存储单元是 *</em>slot(变量槽)***</li>
<li>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型，returnAddress类型的变量</li>
<li>在局部变量表里，<em>32位以内的类型只占用一个 slot(包括returnAddress类型),64位的类型(long 和 double) 占用两个 slot</em>  <ul>
<li>byte，short，char 在存储前被转换为 int；boolean 也被转换为 int</li>
<li>long 和 double 则占据两个 slot</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321103721620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212135535007"></p>
<p><em>实例方法对应的栈帧的数组种的第一个元素即为 this</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">long</span> arg2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myPrint = <span class="number">1</span>;</span><br><span class="line">    System.out.println(myPrint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    descriptor: (IJ)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore        <span class="number">4</span></span><br><span class="line">         3: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         <span class="number">6</span>: iload         <span class="number">4</span></span><br><span class="line">         8: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">11</span></span><br><span class="line">      LocalVariableTable:(重点关注这里，发现数组第一个元素即为<span class="keyword">this</span>,其他才是 方法参数 和 局部变量 )</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/free/demo/stack/StackErrorDemo;</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">1</span>  arg1   I</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">2</span>  arg2   J</span><br><span class="line">            <span class="number">3</span>       <span class="number">9</span>     <span class="number">4</span> myPrint   I</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      arg1</span><br><span class="line">      arg2</span><br></pre></td></tr></table></figure>

<p><em>静态方法种没有 this 变量</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: iconst_1</span><br><span class="line">        <span class="number">1</span>: istore_0</span><br><span class="line">        <span class="number">2</span>: iconst_2</span><br><span class="line">        <span class="number">3</span>: istore_1</span><br><span class="line">        4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        7: ldc           #4                  // String test2</span><br><span class="line">        9: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">19</span>: <span class="number">2</span></span><br><span class="line">       line <span class="number">20</span>: <span class="number">4</span></span><br><span class="line">       line <span class="number">21</span>: <span class="number">12</span></span><br><span class="line">     LocalVariableTable:(重点故关注这里，发现只有局部变量 i1 和 i2)</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">2</span>      <span class="number">11</span>     <span class="number">0</span>    i1   I</span><br><span class="line">           <span class="number">4</span>       <span class="number">9</span>     <span class="number">1</span>    i2   I</span><br></pre></td></tr></table></figure>

<h6><span id="slot-的重复利用">slot 的重复利用</span></h6><p><em>栈帧中的局部变量表中的槽位是可以重用的</em>,</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103739741.png" alt="image-20200212142754211"></p>
<h5><span id="操作数栈重要">操作数栈(重要)</span></h5><ul>
<li>每个独立的栈帧中除了包含局部变量表以外，还包含一个 <em>后进先出</em> 的<strong>操作数栈</strong>，也可称之为<strong>表达式栈</strong></li>
<li><em>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)</em><ul>
<li>某些字节码指令将值压入操作操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行赋值，交换，求和等操作</li>
</ul>
</li>
<li><em>Java 虚拟机的解释引擎是基于 *</em>栈** 的执行引擎，其中栈指的是<strong>操作数栈*</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321103754837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212204608787"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103808457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212205037031">·</p>
<h5><span id="动态链接">动态链接</span></h5><p><img src="https://img-blog.csdnimg.cn/20200321103824276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212211245377"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103838793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212212148682"></p>
<h5><span id="方法返回地址">方法返回地址</span></h5><ul>
<li>存放调用该方法的pc寄存器的值</li>
<li>一个方法的结束，有两种方式<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过 <em>异常表</em> 来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321103855537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216103304370"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321103909269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216103611394"></p>
<p>实例：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321103933542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216104156334"></p>
<h4><span id="栈顶缓存技术">栈顶缓存技术</span></h4><p><img src="https://img-blog.csdnimg.cn/20200321103951992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212210806803"></p>
<h4><span id="方法的调用">方法的调用</span></h4><p>在 JVM 中，将 <em>符号引用</em> 转换为调用方法的 <em>直接引用</em> 与方法的绑定机制有关</p>
<ul>
<li><p><strong>静态链接</strong></p>
<p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接</p>
</li>
<li><p><strong>动态链接</strong></p>
<p>如果 <strong>被调用的方法在编译期无法确定下来，</strong>也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</li>
</ul>
<p><em>虚函数</em> 是不能再 编译期 确定该调用哪个版本</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104055301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212214040762"></p>
<p>虚拟机提供了以下几条方法调用指令</p>
<ul>
<li>普通调用指令</li>
</ul>
<ol>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用&lt;init&gt;方法，私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
<ul>
<li>动态调用指令</li>
</ul>
<ol start="5">
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200321104108675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200213093547736"></p>
<h3><span id="堆区">堆区</span></h3><p>转自：</p>
<p><a href="https://mp.weixin.qq.com/s/7bGtO9NfakQNHHcT26Ia7Q" target="_blank" rel="noopener">看懂这6张图，理解JVM内存布局就没问题了！</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104129182.png" alt="image-20200217204943499"></p>
<p>堆时 OOM 故障最主要的区域，它是内存中区域最大的一块区域，<strong>被所有线程共享</strong>。存储着几乎所有的实例对象。<strong>所有的对象实例以及数组都要在堆上分配。</strong>但是随着JIT编译器的发展与<strong>逃逸分析技术</strong>逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，<strong>所有的对象都分配在堆上也渐渐变得不是那么“绝对”了</strong>。</p>
<p>Java 堆是垃圾收集器管理的主要区域。从内存回收的角度看，由于现在收集器基本都采用 <em>分代收集算法</em>，所以 Java堆还可以细分为：<strong>新生代和老年代</strong>。</p>
<p>新生代</p>
<ul>
<li><strong>Eden空间</strong></li>
<li><strong>From Survivor空间</strong></li>
<li><strong>To Survivor空间</strong></li>
</ul>
<p>从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。</p>
<h4><span id="堆区调整">堆区调整</span></h4><p>根据Java虚拟机规范的规定，<strong>Java堆可以处于物理上不连续的内存空间中</strong>，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以在运行时动态地调整</p>
<p>如何调整呢？</p>
<p>通过设置如下参数，可以设定堆区的初始值和最大值，比如 <code>-Xms256M -Xmx 1024M</code>，其中 <code>-X</code>这个字母代表它是JVM运行时参数，<code>ms</code>是<code>memory start</code>的简称，中文意思就是内存初始值，<code>mx</code> 是 <code>memory max</code>的简称，意思就是最大内存。</p>
<p><strong>值得注意的是，在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，会形成不必要的系统压力 所以在线上生产环境中 JVM的<code>Xms</code>和 <code>Xmx</code>会设置成同样大小，避免在GC 后调整堆大小时带来的额外压力。</strong></p>
<h4><span id="堆的默认空间分配">堆的默认空间分配</span></h4><p>堆空间内存分配的大体情况</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3E2czF4Mmh3Mi5ia3QuY2xvdWRkbi5jb20vNzcucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>执行如下命令，就可以看到当前 JDK 版本所有默认的 JVM 参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version</span><br></pre></td></tr></table></figure>

<p>对应输出应该有几百行，主要看两个关键参数</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;java -XX:+PrintFlagsFinal -version</span><br><span class="line">[Global flags]</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">    uintx InitialSurvivorRatio                      = 8</span><br><span class="line">    uintx NewRatio                                  = 2</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">java version <span class="string">"1.8.0_131"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure>

<p>参数解释</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:InitialSurvivorRatio</td>
<td align="left">新生代Eden/Survivor空间的初始比例</td>
</tr>
<tr>
<td align="left">-XX:NewRatio</td>
<td align="left">Old区/Young区的内存比例</td>
</tr>
</tbody></table>
<p>因为新生代是由Eden + S0 + S1组成的，所以按照上述默认比例，如果eden区内存大小是40M，那么两个survivor区就是5M，整个young区就是50M，然后可以算出Old区内存大小是100M，堆区总大小就是150M。</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError</code> 可以让JVM在遇到OOM异常时，输出堆内信息</p>
<h4><span id="创建一个新对象内存分配流程">创建一个新对象，内存分配流程</span></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3E2czF4Mmh3Mi5ia3QuY2xvdWRkbi5jb20vNzgucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>绝大部分对象在 Eden 区生成，当 Eden 区装填满的时候，会触发 <strong>Young Garbage Collection</strong>，即 <code>YGC</code>。垃圾回收的时候，在 Eden 区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到Survivor区。Survivor区分为so和s1两块内存空间。每次<code>YGC</code>的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果<code>YGC</code>要移送的对象大于Survivor区容量的上限，则直接移交给老年代。一个对象也不可能永远呆在新生代，就像人到了18岁就会成年一样，在JVM中<code>－XX:MaxTenuringThreshold</code>参数就是来配置一个对象从新生代晋升到老年代的阈值。默认值是<strong>15</strong>， 可以在Survivor区交换14次之后，晋升至老年代。</p>
<h3><span id="元空间">元空间</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321104340358.png" alt="image-20200217211401315"></p>
<p>在 HotSpot JVM 中，<strong>永久代（ ≈ 方法区）\</strong>中用于*<em>存放类和方法的元数据以及常量池**,比如 *Class</em> 和 <em>Method</em>。每当一个类被初次加载的时候，它的元数据都会放到永久代。</p>
<p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code>，为此我们不得不对虚拟机做调优。</p>
<p>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</p>
<ol>
<li>由于 PermGen 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li>
<li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li>
</ol>
<p>根据上面的各种原因，PermGen 最终被移除，<strong>方法区移至 Metaspace，字符串常量池移至堆区</strong>。</p>
<p>准确来说，Perm 区中的<strong>字符串常量池被移到了堆内存</strong>中是在Java7 之后，Java 8 时，PermGen 被元空间代替，<strong>其他内容比如类元信息、字段、静态属性、方法、常量等都移动到元空间区</strong>。比如<code>java/lang/Object</code>类元信息、静态属性<code>System.out</code>、整形常量 <code>100000</code>等。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。（和后面提到的直接内存一样，都是使用本地内存）</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
<p><strong>对应的JVM调参：</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:MetaspaceSize</td>
<td align="left">分配给Metaspace（以字节计）的初始大小</td>
</tr>
<tr>
<td align="left">-XX:MaxMetaspaceSize</td>
<td align="left">分配给Metaspace 的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td>
</tr>
<tr>
<td align="left">-XX:MinMetaspaceFreeRatio</td>
<td align="left">在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</td>
</tr>
<tr>
<td align="left">-XX:MaxMetaspaceFreeRatio</td>
<td align="left">在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</td>
</tr>
</tbody></table>
<h3><span id="本地方法接口">本地方法接口</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321104356879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216110618851"></p>
<h4><span id="什么是本地方法">什么是本地方法</span></h4><p><em>一个 Native Method就是一个 Java 调用非 Java 代码的接口。</em>一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。</p>
<p><img src="https://img-blog.csdnimg.cn/2020032110442188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216110925645"></p>
<p>例如 Object.java 中的 <em>getClass()</em> 方法就是一个 native 方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104439634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216111105667"></p>
<h4><span id="native-与-abstract-的区别">native 与 abstract 的区别</span></h4><p>native 是有方法体的，只不过是用 C 来实现</p>
<p>而 abstract 是没有方法体的，具体由子类去实现。</p>
<p>native 和 abstract 两者不能共用。</p>
<h3><span id="变量">变量</span></h3><p><em>变量的分类：</em></p>
<p>1.基本数据类型 2.引用数据类型</p>
<p><em>按照在类中声明的位置分类：</em></p>
<ol>
<li><p>成员变量：在使用前，都经历过默认初始化赋值</p>
<ol>
<li><strong>类变量</strong>：linking的prepare阶段，给类变量默认赋值 —-》 initial:给类变量显示赋值</li>
<li><strong>实例变量：</strong>随着对象创建，会在堆空间分配实例变量空间，并进行默认赋值</li>
</ol>
</li>
<li><p>局部变量：在使用前，必须要进行显式赋值！否则，编译不通过</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200321104453426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200212194503832"></p>
<h3><span id="方法调用关于-invokedynamic-指令">方法调用：关于 invokedynamic 指令</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321104506523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216094404600"></p>
<h3><span id="方法的调用方法重写的本质">方法的调用：方法重写的本质</span></h3><p><img src="https://img-blog.csdnimg.cn/20200321104518699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200216094821151"></p>
<h3><span id="方法的调用虚方法表">方法的调用：虚方法表</span></h3><ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<em>为了提高性能</em>，JVM 采用在类的方法区建立一个虚方法表(virtual method table)(<strong>非虚方法不会出现在表中</strong>)来实现。使用索引表来代替查找</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</li>
</ul>
<h2><span id="垃圾回收器">垃圾回收器</span></h2><h3><span id="对象引用分类">对象引用分类</span></h3><p>参考：</p>
<p><a href="https://juejin.im/post/5b4dea755188251ac1098e98" target="_blank" rel="noopener">JVM系列(五) - JVM垃圾回收算法</a></p>
<p><a href="https://juejin.im/post/5b651200f265da0fa00a38d7#heading-3" target="_blank" rel="noopener">JVM系列(六) - JVM垃圾回收器</a></p>
<blockquote>
<h4><span id="强引用">强引用</span></h4></blockquote>
<p>在代码中普遍存在的，类似<code>Object obj = new Object()</code>这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</p>
<blockquote>
<h4><span id="软引用softreference">软引用(SoftReference)</span></h4></blockquote>
<p><strong>有用但并非必需</strong> 的对象，可用<code>SoftReference</code>类来实现软引用。在系统将要发生<strong>内存溢出异常</strong>之前，将会把这些对象列进回收范围之中进行<strong>二次回收</strong>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<blockquote>
<h4><span id="弱引用weakreference">弱引用(WeakReference)</span></h4></blockquote>
<p><strong>非必需</strong> 的对象，但它的<strong>强度</strong>比软引用更弱，被弱引用关联的对象<strong>只能</strong>生存到下一次垃圾收集发生之前，<code>JDK</code>提供了<code>WeakReference</code>类来实现弱引用。无论当前内存是否足够，用软引用相关联的对象都会被回收掉。</p>
<blockquote>
<h4><span id="虚引用phatomreference">虚引用(PhatomReference)</span></h4></blockquote>
<p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系，<code>JDK</code>提供了<code>PhantomReference</code>类来实现虚引用。为一个对象设置虚引用的唯一目的是：能在这个对象在<strong>垃圾回收器</strong>回收时收到一个<strong>系统通知</strong></p>
<h3><span id="finalize-二次标记">finalize() 二次标记</span></h3><p>一个对象是否应该在垃圾回收器在<code>GC</code>时回收，至少要经历<strong>两次标记过程</strong>。</p>
<p>第一次标记过程，通过<strong>可达性分析算法</strong>分析对象是否与<code>GC Roots</code>可达。经过第一次标记，并且被筛选为<strong>不可达</strong>的对象会进行第二次标记。</p>
<p>第二次标记过程，判断不可达对象是否有必要执行<code>finalize</code>方法。执行条件是当前对象的<code>finalize</code>方法被重写，并且还未被系统调用过。如果允许执行那么这个对象将会被放到一个叫<code>F-Query</code>的队列中，等待被执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：由于finalize由一个优先级比较低的Finalizer线程运行，所以该对象的的finalize方法不一定被执行，即使被执行了，也不保证finalize方法一定会执行完。如果对象第二次小规模标记，即finalize方法中拯救自己，只需要重新和引用链上的任一对象建立关联即可。</span><br></pre></td></tr></table></figure>

<h3><span id="垃圾回收算法">垃圾回收算法</span></h3><p>参考：</p>
<p><a href="https://www.cnblogs.com/chenpt/p/9799095.html" target="_blank" rel="noopener">Jvm垃圾回收器（算法篇）</a></p>
<blockquote>
<h4><span id="标记-清除算法">标记-清除算法</span></h4></blockquote>
<ul>
<li>标记</li>
</ul>
<p>标记出所有需要回收的对象</p>
<p><strong>一次标记：</strong>在经过 <em>可达性分析算法</em> 后，对象没有与 GC Root 相关的引用链，那么则被第一次标记，并且进行一次筛选：当对象有必要执行 finalize() 方法时，则将该对象放入 F-Queue 队列中</p>
<p><strong>二次标记：</strong>对 F-Queue 队列中的对象进行二次标记。在执行 finalize() 方法时，如果对象重新与 GC Root 引用链上的任意对象建立了关联，则将其移除 “即将回收” 集合。否则即将被回收</p>
<p>对被第一次标记且被第二次标记的，就可以判定位可回收对象了。</p>
<ul>
<li>清除</li>
</ul>
<p>两次标记后，还在 “即将回收” 集合的对象进行回收</p>
<p>执行过程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104534826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>优点：</strong>最基础的可达性算法，后续的收集算法都是基于这种思想实现的</p>
<p><strong>缺点：</strong>标记和清除效率不高，产生大量不连续的内存碎片，导致创建大对象找不到连续的空间，不得不提前触发另一次的垃圾回收</p>
<blockquote>
<h3><span id="复制算法">复制算法</span></h3></blockquote>
<p>将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活的对象复制到另外一块内存上，然后再把已使用过的内存空间一次清理掉</p>
<p>复制算法过程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020032110454857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>优点：</strong>实现简单，效率高。解决了标记-清除算法导致的内存碎片问题</p>
<p><strong>缺点：</strong>代价大，将内存缩小了一半。效率随对象的存活率升高而降低。</p>
<p>现在的商业虚拟机都采用这种算法（需要改良1:1的缺点）来回收新生代。</p>
<ul>
<li>改良算法</li>
</ul>
<p><strong>1.弱代理论</strong>　</p>
<p>分代垃圾收集基于弱代理论。具体描述如下：</p>
<ul>
<li>大多说分配了内存的对象并不会存活太长时间，在处于年轻时代就会死掉。</li>
<li>很少有对象会从老年代变成年轻代。</li>
</ul>
<p>其中IBM研究表明：新生代中98%的对象都是”朝生夕死”； 所以并不需要按1:1比例来划分内存（解决了缺点1）；</p>
<p><strong>2.Hotspot虚拟机新生代内存布局及算法</strong></p>
<p>新生代内存分配一块较大的Eden空间和两块较小的Survivor空间</p>
<p>每次使用Eden和其中一块Survivor空间</p>
<p>回收时将Eden和Survivor空间中存活的对象一次性复制到另一块Survivor空间上</p>
<p>最后清理掉Eden和使用过的Survivor空间。</p>
<p>Hotspot虚拟机默认Eden和Survivor的大小比例是8:1。</p>
<p><strong>分配担保</strong></p>
<p>如果另一块 Survivor 空间没有足够内存来存放上一次新生代收集下来的存活对象，那么这些对象则直接通过担保机制进入老年代。</p>
<blockquote>
<h3><span id="标记-整理算法">标记-整理算法</span></h3></blockquote>
<p>标记-整理算法是根据老年代的特点应运而生</p>
<ul>
<li>标记</li>
</ul>
<p>标记过程和标记-清理算法一致（也是基于可达性分析算法）。</p>
<ul>
<li>整理</li>
</ul>
<p>和标记-清理不同的是，该算法不是针对可回收对象进行清理，而是根据存活对象进行整理。让存活对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p>标记-整理算法示意图</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104615802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>优点：</strong>不会像复制算法那样随着存活对象的升高而降低效率，不像标记-清除算法那样产生不连续的内存碎片</p>
<p><strong>缺点：</strong>效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率更低。</p>
<blockquote>
<h3><span id="分代收集算法">分代收集算法</span></h3></blockquote>
<p>当前商业虚拟机的垃圾收集都是采用“ 分代收集 ”算法。</p>
<p>根据对象存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代。JVM根据各个年代的特点采用不同的收集算法。</p>
<p>新生代中，每次进行垃圾回收都会发现大量对象死去，只有少量存活，因此比较适合复制算法。只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中，因为对象存活率较高，没有额外的空间进行分配担保，所以适合标记-清理、标记-整理算法来进行回收。</p>
<h3><span id="七种垃圾回收器">七种垃圾回收器</span></h3><p>参考：</p>
<p><a href="https://www.cnblogs.com/chenpt/p/9803298.html" target="_blank" rel="noopener">JVM垃圾回收器</a></p>
<p>在 <code>JVM</code> 中，具体实现有</p>
<ul>
<li><code>Serial</code>,</li>
<li><code>ParNew</code> ，</li>
<li><code>Pallel Scavenge</code> , </li>
<li><code>CMS</code> , </li>
<li><code>Serial Old(MSC)</code> ，</li>
<li><code>Parallel Old</code> ,</li>
<li><code>G1</code> 等。</li>
</ul>
<p>在下图中，你可以看到 <strong>不同垃圾回收器</strong> 适合于 <strong>不同的内存区域</strong>，如果两个垃圾回收器之间 <strong>存在连线</strong>，那么表示两者可以 <strong>配合使用</strong>。</p>
<p>如果当 <strong>垃圾回收器</strong> 进行垃圾清理时，必须 <strong>暂停</strong> 其他所有的 <strong>工作线程</strong>，直到它完全收集结束。我们称这种需要暂停工作线程才能进行清理的策略为 <em>Stop-the-World</em>。</p>
<p>以上回收器中， <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Serial Old</code>、<code>Parallel Old</code> 均采用的是 <code>Stop-the-World</code> 的策略。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3E2czF4Mmh3Mi5ia3QuY2xvdWRkbi5jb20vODkucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>图中有 <code>7</code> 种不同的 <strong>垃圾回收器</strong>，它们分别用于不同分代的垃圾回收。</p>
<ul>
<li><strong>新生代回收器：</strong>Serial，ParNew，Parallel Scavenge</li>
<li><strong>老年代回收器：</strong>Serial Old，Parallel Old，CMS</li>
<li><strong>整堆回收器：</strong>G1</li>
</ul>
<p>两个 <strong>垃圾回收器</strong> 之间有连线表示它们可以 <strong>搭配使用</strong>，可选的搭配方案如下：</p>
<table>
<thead>
<tr>
<th align="left">新生代</th>
<th align="left">老年代</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Serial</td>
<td align="left">Serial Old</td>
</tr>
<tr>
<td align="left">Serial</td>
<td align="left">CMS</td>
</tr>
<tr>
<td align="left">ParNew</td>
<td align="left">Serial Old</td>
</tr>
<tr>
<td align="left">ParNew</td>
<td align="left">CMS</td>
</tr>
<tr>
<td align="left">Parallel Scavenge</td>
<td align="left">Serial Old</td>
</tr>
<tr>
<td align="left">Parallel Scavenge</td>
<td align="left">Parallel Old</td>
</tr>
<tr>
<td align="left">G1</td>
<td align="left">G1</td>
</tr>
</tbody></table>
<blockquote>
<h4><span id="单线程垃圾回收器">单线程垃圾回收器</span></h4></blockquote>
<ul>
<li><h4><span id="serial-xxuseserialgc">Serial（-XX:+UseSerialGC）</span></h4></li>
</ul>
<p>Serial收集器是最基本的、发展历史最悠久的收集器。</p>
<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。</p>
<p><strong>应用场景</strong>：适用于Client模式下的虚拟机。</p>
<p><strong>Serial / Serial Old收集器运行示意图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104657654.png" alt="img"></p>
<ul>
<li><h4><span id="serial-old-xxuseserialgc">Serial Old（-XX:+UseSerialGC）</span></h4></li>
</ul>
<p>Serial Old是Serial收集器的老年代版本。</p>
<p><strong>特点</strong>：同样是单线程收集器，采用标记-整理算法。</p>
<p><strong>应用场景</strong>：主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。</p>
<p>Server模式下主要的两大用途（在后续中详细讲解···）：</p>
<ol>
<li>在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。</li>
</ol>
<p>Serial / Serial Old收集器工作过程图（Serial收集器图示相同）：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104657654.png" alt="91.png"></p>
<blockquote>
<h4><span id="多线程垃圾回收器吞吐量优先">多线程垃圾回收器(吞吐量优先)</span></h4></blockquote>
<ul>
<li><h4><span id="parnew-xxuseparnewgc">ParNew（-XX:+UseParNewGC）</span></h4></li>
</ul>
<p>ParNew收集器其实就是Serial收集器的多线程版本。</p>
<p>除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<p>　　　和Serial收集器一样存在Stop The World问题</p>
<p><strong>应用场景</strong>：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。</p>
<p><strong>ParNew/Serial Old组合收集器运行示意图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104725361.png" alt="img"></p>
<ul>
<li><h4><span id="parallel-scavenge-xxuseparallelgc">Parallel Scavenge（-XX:+UseParallelGC）</span></h4></li>
</ul>
<p>与吞吐量关系密切，故也称为吞吐量优先收集器。</p>
<p><strong>特点</strong>：属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ol>
<li><p>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</p>
</li>
<li><p>XX:GCRatio 直接设置吞吐量的大小。</p>
</li>
</ol>
<ul>
<li><h4><span id="parallel-old-xxuseparalleloldgc">Parallel Old（-XX:+UseParallelOldGC）</span></h4></li>
</ul>
<p>是Parallel Scavenge收集器的老年代版本。</p>
<p><strong>特点</strong>：多线程，采用标记-整理算法。</p>
<p><strong>应用场景</strong>：注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。</p>
<p><strong>Parallel Scavenge/Parallel Old收集器工作过程图：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104737684.png" alt="img"></p>
<blockquote>
<h3><span id="其他的回收器停顿时间优先">其他的回收器（停顿时间优先）</span></h3></blockquote>
<ul>
<li><h4><span id="cms-xxuseconcmarksweepgc">CMS（-XX:+UseConcMarkSweepGC）</span></h4></li>
</ul>
<p>一种以获取最短回收停顿时间为目标的收集器。</p>
<p><strong>特点</strong>：基于标记-清除算法实现。并发收集、低停顿。</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务。</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。</p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。</p>
<p><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收。</p>
<p> CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p> CMS收集器的工作过程图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321104748776.png" alt="img"></p>
<p>CMS收集器的缺点：</p>
<ul>
<li>对CPU资源非常敏感。</li>
<li>无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。</li>
<li>因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。</li>
</ul>
<ul>
<li><h4><span id="g1收集器">G1收集器</span></h4></li>
</ul>
<p>一款面向服务端应用的垃圾收集器。</p>
<p><strong>特点如下：</strong></p>
<p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</p>
<p>分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p>
<p>空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。</p>
<p>可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<p>区域化内存划片 Region，整体编为了一些不连续的内存区域，避免了全内存区的GC操作<br>核心思想是将整个堆内存区域分成大小相同的子区域(Region), 在 JVM 启动时会自动设置这些子区域的大小。<br>在堆的使用上，G1 并不要求对象的存储一定是物理上连续的只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数 -XX:G1HeapRegionSize=n 可指定分区大小(1MB<del>32MB),默认将整堆划分为2048个分区<br>大小范围在 1MB</del>32MB，最多能设置 2048 个区域，也即能够支持的最大内存为：32MB * 2048 = 65536MB = 64G内存</p>
<p>针对 Eden 区进行收集，Eden 区耗尽后会被触发，主要是小区域收集 + 形成连续的内存块，避免内存碎片</p>
<ul>
<li>Eden 区的数据移动到 Survivor 区，假如出现 Survivor 区空间不够，Eden 区数据会晋升到 Old 区</li>
<li>Survivor 区的数据移动到新的 Survivor 区，数据晋升到 Old 区</li>
<li>最后 Eden 区收拾干净，GC 结束，用户的应用程序继续执行</li>
</ul>
<p><strong>G1为什么能建立可预测的停顿时间模型？</strong></p>
<p>因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这样就保证了在有限的时间内可以获取尽可能高的收集效率。</p>
<p><strong>G1与其他收集器的区别</strong>：</p>
<p>其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。</p>
<p><strong>G1收集器存在的问题：</strong></p>
<p>Region不可能是孤立的，分配在Region中的对象可以与Java堆中的任意对象发生引用关系。在采用可达性分析算法来判断对象是否存活时，得扫描整个Java堆才能保证准确性。其他收集器也存在这种问题（G1更加突出而已）。会导致Minor GC效率下降。</p>
<p><strong>G1收集器是如何解决上述问题的？</strong></p>
<p>采用Remembered Set来避免整堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于多个Region中（即检查老年代中是否引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。</p>
<p><strong>如果不计算维护 Remembered Set 的操作，G1收集器大致可分为如下步骤：</strong></p>
<p><strong>初始标记</strong>：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。）</p>
<p><strong>并发标记</strong>：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行）</p>
<p><strong>最终标记</strong>：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set Logs里面，把Remembered Set Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。）</p>
<p><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行）</p>
<p><strong>G1收集器运行示意图：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104802941.png" alt="img"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2020/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319214514210" target="_blank" rel="noopener">单例</a></p>
<p><a href="https://blog.csdn.net/itachi85/article/details/50510124" target="_blank" rel="noopener">设计模式（二）单例模式的七种写法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33102022" target="_blank" rel="noopener">漫画：什么是单例模式？(推荐)</a></p>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
</blockquote>
<p>单例模式( Singleton ) 的目的是为了保证在一个进程中，某个类有且仅有一个实例。属于 <strong><em>创建型模式</em></strong></p>
<p>因为这个类只有一个实例，因此，自然不能让调用方法 <code>new Xyz()</code> 来创建实例了。所以单例的构造方法必须是 <code>private</code> ，这样就防止了调用自己创建实例，但是类的内部，是可以用一个静态字段来引用唯一创建的实例的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>那么外部调用方如何获得这个唯一的实例呢？</p>
<p>那么问题来了，外部调用方如何获得这个唯一实例？</p>
<p>答案是提供一个静态方法，直接返回实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接把<code>static</code>变量暴露给外部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，单例模式的实现方式很简单：</p>
<ol>
<li>只有<code>private</code>构造方法，确保外部无法实例化；</li>
<li>通过<code>private static</code>变量持有唯一实例，保证全局唯一性；</li>
<li>通过<code>public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Chinese objref =<span class="keyword">new</span> Chinese();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chinese <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> objref; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChinese</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Chinese obj1 = Chinese.getInstance();</span><br><span class="line">        Chinese obj2 = Chinese.getInstance();</span><br><span class="line">        System.out.println(obj1 == obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="饿汉模式">饿汉模式</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度块。</p>
<p>这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。</p>
<h1><span id="懒汉模式线程不安全">懒汉模式(线程不安全)</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> instance;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。</p>
<h1><span id="懒汉模式线程安全">懒汉模式(线程安全)</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。</p>
<h1><span id="双重检查模式dcl">双重检查模式(DCL)</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    instance= <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="静态内部类单例模式">静态内部类单例模式</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之事务隔离级别以及传播机制</title>
    <url>/2020/03/19/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/1078760" target="_blank" rel="noopener">Java提升篇－事务隔离级别和传播机制</a></p>
<p><a href="https://www.cnblogs.com/zhishan/" target="_blank" rel="noopener">在探索中前行</a></p>
<p><a href="https://blog.csdn.net/vbirdbest/article/details/82313903" target="_blank" rel="noopener">Spring Boot入门教程(四十五): 事务@Transactional</a></p>
<p><a href="https://juejin.im/post/5b00c52ef265da0b95276091" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a></p>
<h1><span id="定义">定义</span></h1><blockquote>
<p>事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致性以及操作隔离</p>
</blockquote>
<p><strong>数据一致</strong> 是指事务提交时保证事务内的所有操作都成功完成，并且永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。</p>
<p><strong>操作隔离</strong> 则是指多个同时执行的事务之间应该相互独立，互不影响。</p>
<a id="more"></a>

<h1><span id="属性和行为">属性和行为</span></h1><p>提到事务，不可避免需要涉及到事务的ACID属性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
<h1><span id="隔离级别">隔离级别</span></h1><p><strong><em>:star::star::star: 隔离级别是为了防止多个事务并发执行时，一个事务的执行不应影响其它事务的执行。</em></strong></p>
<p>InnoDB默认的隔离级别是<code>REPEATABLE READ</code>，其可避免<em>脏读<em>和</em>不可重复读<em>，但不能避免</em>幻读</em></p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td>
</tr>
</tbody></table>
<h1><span id="传播机制">传播机制</span></h1><p><strong><em>传播机制是 Spring 针对方法嵌套调用时事务的创建行为提出的机制，</em></strong></p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_MANDATORY</td>
<td>表示该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>表示如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像PROPAGATION_REQUIRES一样。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>表示当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>表示该方法不应该在一个事务中运行。如果一个现有事务正在进行中，它将在该方法的运行期间被挂起。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>表示当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES</td>
<td>表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。</td>
</tr>
</tbody></table>
<p>按分类的方法可以将 7种 传播级别分为以下几种</p>
<p><u>支持当前事务的情况</u>：</p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong>如果当前存在事务，则加入该事务；如果当前没事务，则以非事务的方式继续运行</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong>如果当前存在事务，则加入该事务；如果当前没事务，则抛出异常  (<strong><em>mandatory：强制性</em></strong>)</li>
</ul>
<p><u>不支持当前事务的情况</u>：</p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong>创建一个新的事务，如果当前存在事务，则把当前事务挂起</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式运行，如果当前存在事务，则把当前事务挂起</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER:</strong>  以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><u>其它情况</u>：</p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED:</strong>  如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<p>需要指出的是，前面的<strong>六种事务</strong>传播行为是 Spring <strong>从 EJB 中引入的</strong>，他们共享相同的概念。而 <strong>PROPAGATION_NESTED</strong> 是 Spring 所特有的。</p>
<p>以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，<strong>嵌套的子事务不能单独提交</strong>。</p>
<p>如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</p>
<h1><span id="spring事务管理接口">Spring事务管理接口</span></h1><ul>
<li><strong>PlatformTransactionManager：</strong>(平台) 事务管理器</li>
<li><strong>TransactionDefinition：</strong>事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li>
<li><strong>TransactionStatus：</strong>事务运行机制</li>
</ul>
<blockquote>
<p><strong>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</strong></p>
</blockquote>
<h2><span id="platformtransactionmanager">PlatformTransactionManager</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。）</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">    <span class="comment">// Commit the given transaction, with regard to its status（使用事务目前的状态提交事务）</span></span><br><span class="line">    <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="comment">// Perform a rollback of the given transaction（对执行的事务进行回滚）</span></span><br><span class="line">    <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="transactiondefinition">TransactionDefinition</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//事务传播机制</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//事务隔离级别</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TransactionDefinition <span class="title">withDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务管理器接口 <strong>PlatformTransactionManager</strong> 通过 <strong>getTransaction(TransactionDefinition definition)</strong> 方法来得到一个事务，这个方法里面的参数是 <strong>TransactionDefinition类</strong> ，这个类就定义了一些基本的事务属性。</p>
<p><img src="https://img-blog.csdnimg.cn/2020031916085413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img1"></p>
<p><img src="https://img-blog.csdnimg.cn/20200319160906456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="img2"></p>
<p>NESTED 传播级别</p>
<p><img src="https://img-blog.csdnimg.cn/20200319160916133.png" alt="image-20200319152322070"></p>
<p>@Transactional 只能应用到 public 方法才有效</p>
<p>未完成。。。</p>
]]></content>
      <categories>
        <category>事务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>隔离级别</tag>
        <tag>传播机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之ThreadLocal的理解</title>
    <url>/2020/03/18/Java%E4%B9%8BThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>转载自：</p>
<p><a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/" target="_blank" rel="noopener">理解Java中的ThreadLocal</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></p>
<h1><span id="定义">定义</span></h1><p>ThreadLocal 是一个关于创建线程局部变量的类</p>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的，而使用 ThreadLocal 创建的变量只能被当前线程访问，其它线程则无法访问和修改。</p>
<a id="more"></a>

<h2><span id="例子">例子</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connect = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect == <span class="keyword">null</span>)&#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect!=<span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p>
<p>　　所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。</p>
<p>　　这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。</p>
<p>　　那么大家来仔细分析一下这个问题，这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。</p>
<p>　　到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Connection connect = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect == <span class="keyword">null</span>)&#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connect!=<span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConnectionManager connectionManager = <span class="keyword">new</span> ConnectionManager();</span><br><span class="line">        Connection connection = connectionManager.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用connection进行操作</span></span><br><span class="line"></span><br><span class="line">        connectionManager.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。</p>
<p><strong><em>注意：</em></strong> 虽然 ThreadLocal 能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用 ThreadLocal 要大</p>
<h1><span id="深入理解">深入理解</span></h1><p>先了解一下 ThreadLocal 类提供的几个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>get()</em></strong> 方法用来获取 ThreadLocal 在当前线程中保存的变量副本</li>
<li><strong><em>set()</em></strong> 用来设置当前线程中变量的副本</li>
<li><strong><em>remove()</em></strong> 用来移除当前线程中变量的副本</li>
<li><strong><em>initialValue()</em></strong> 是一个 protected 方法，一般是用来在使用时进行重写的，它是一个延迟加载方法</li>
</ul>
<h2><span id="get">get()</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//2.然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//3.然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">//4.如果获取成功，则返回value值。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.如果map为空，则调用setInitialValue方法返回value。</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="getmapthread-t">getMap(Thread t)</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用当期线程t，返回当前线程t中的一个成员变量threadLocals</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="threadlocals">threadLocals</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//threadLocals 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类</span></span><br></pre></td></tr></table></figure>

<h2><span id="threadlocalmap">ThreadLocalMap</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment">     * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment">     * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment">     * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment">     * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment">     * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment">     * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment">     * the table starts running out of space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p>
<h2><span id="setinitialvalue">setInitialValue()</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment">     * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map</p>
<h2><span id="createmapthread-t-t-firstvalue">createMap(Thread t, T firstValue)</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="总结">总结</span></h2><p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<h2><span id="例子">例子</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">        stringLocal.set(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        test.set();</span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.set();</span><br><span class="line">                System.out.println(test.getLong());</span><br><span class="line">                System.out.println(test.getString());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">         </span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<p><img src="https://img-blog.csdnimg.cn/20200330132840838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="29.png"></p>
<p>从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。</p>
<h3><span id="小结">小结</span></h3><ol>
<li>实际的通过 ThreadLocal  创建的副本是存储在每个线程自己的 threadLocals 中的;</li>
<li>为何 threadLocals 的类型 ThreadLocalMap 的键值为 ThreadLocal 对象，因为每个线程中可有多个 threadLocal 变量，就像上面代码中的 longLocal 和 stringLocal</li>
<li>在进行 get 之前，必须先 set，否则会报空指针异常</li>
</ol>
<h1><span id="应用的场景">应用的场景</span></h1><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">    = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议,OSI七层协议</title>
    <url>/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE,OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">OSI七层模型详解</a></p>
<p><a href="https://juejin.im/post/5a069b6d51882509e5432656" target="_blank" rel="noopener">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p>
<p><a href="https://blog.csdn.net/zhshulin/article/details/62888061" target="_blank" rel="noopener">一张图了解TCP/IP五层网络模型</a></p>
<a id="more"></a>

<h1><span id="osi七层协议">OSI七层协议</span></h1><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/21.png" alt="21.png"></p>
<h2><span id="物理层">物理层</span></h2><blockquote>
<p>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</p>
</blockquote>
<h2><span id="数据链路层">数据链路层</span></h2><blockquote>
<p>通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p>
</blockquote>
<p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<h2><span id="网络层">网络层</span></h2><blockquote>
<p>通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</p>
</blockquote>
<p>该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p>
<p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。</p>
<h2><span id="传输层">传输层</span></h2><blockquote>
<p>向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</p>
</blockquote>
<p>传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。</p>
<h2><span id="会话层">会话层</span></h2><blockquote>
<p>向两个实体的表示层提供建立和使用连接的方法。</p>
</blockquote>
<h2><span id="表示层"><strong>表示层</strong></span></h2><blockquote>
<p>处理用户信息的表示问题，如编码、数据格式转换和加密解密</p>
</blockquote>
<h2><span id="应用层">应用层</span></h2><blockquote>
<p>直接向用户提供服务，完成用户希望在网络上完成的各种工作</p>
</blockquote>
<p>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/22.png" alt="22.png"></p>
<p><strong>OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</strong></p>
<h1><span id="tcpip-五层协议">TCP/IP 五层协议</span></h1><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/24.png" alt="24.png"></p>
<h1><span id="数据处理流程">数据处理流程</span></h1><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/23.png" alt="23.png"></p>
<p>① 应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>
<p>② TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>
<p>③ IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>
<p>④ 网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<p>⑤ 网络接口（以太网驱动）的处理<br>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>
<p>⑥ IP 模块的处理<br>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>
<p>⑦ TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<p>⑧ 应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>计算机网络</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之集合框架</title>
    <url>/2020/03/17/Java%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>转载自：</p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/63e76826e852" target="_blank" rel="noopener">Java - 集合框架完全解析</a></p>
<p><a href="https://juejin.im/post/5da41417f265da5ba532b21c" target="_blank" rel="noopener">详解Java集合框架，让你全面掌握！</a></p>
<p><a href="https://mp.weixin.qq.com/s/IwwQvK5O9KMvEXNcmy8PFw" target="_blank" rel="noopener">在工作中常用到的集合有哪些？</a></p>
<p>在 Java2 之前，Java 是没有完整的集合框架。它只有一些简单的可以自扩展的容器类，比如 Vector，Stack，Hashtable 等。但由于效率的原因遭受诟病，于是不得不进行改革。</p>
<a id="more"></a>

<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/25.png" alt="25.png"></p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/26.png" alt="26.png"></p>
<p>从上面的集合框架可以看到，</p>
<p>Java集合框架主要包括两种类型的容器，一种是集合(Collection)，存储一个元素集合，</p>
<p>另一种是图(Map)，存储 key/value 映射。</p>
<p>Collection接口：</p>
<ul>
<li>List</li>
<li>Set</li>
<li>Queue</li>
</ul>
<p><strong><em>List</em></strong> 代表了 <strong>有序</strong>, <strong>可重复</strong> 集合，可直接根据元素的索引来访问；</p>
<p><strong><em>Set</em></strong> 代表了 <strong>无序</strong>, <strong>不可重复</strong> 集合，只能根据元素本身来访问；</p>
<p><strong><em>Queue</em></strong> 是队列集合</p>
<p><strong><em>Map</em></strong> 代表的是 <strong>存储key/value</strong> 的集合，可根据元素的 key 来访问 value。</p>
<h1><span id="set-集合">Set 集合</span></h1><blockquote>
<p>如果需要保证集合的元素是唯一的，就应该用到 Set 集合</p>
</blockquote>
<p>Set集合与Collection的方法相同，由于Set集合不允许存储相同的元素，所以如果把两个相同元素添加到同一个Set集合，则添加操作失败，新元素不会被加入，add()方法返回false。</p>
<p>比如说：现在要发送一批消息给用户，我们为了减少「一次发送重复的内容给用户」这样的错误，我们就用Set集合来保存用户的<code>userId/phone</code></p>
<h2><span id="1hashset">1.<strong>HashSet</strong></span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Set&lt;String&gt; set=<span class="keyword">new</span> HashSet();</span><br><span class="line">   set.add(<span class="string">"hello world"</span>);</span><br><span class="line">   set.add(<span class="string">"hello 冰湖一角"</span>);</span><br><span class="line">   set.add(<span class="string">"hello 冰湖一角"</span>);</span><br><span class="line">   System.out.println(<span class="string">"集合中元素个数："</span></span><br><span class="line">        +set.size());</span><br><span class="line">   System.out.println(<span class="string">"集合中元素为："</span></span><br><span class="line">       +set.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可知 <strong><em>HashSet</em></strong> 的底层是通过 <strong><em>HashMap</em></strong> 实现的</p>
<p>查看 <strong>add()</strong> 的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用 HashMap 的 put()</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>put()</strong> 的源码主要是通过 <u>hash值</u> 以及 <u>equals()</u> 方法来避免重复的添加</p>
<h2><span id="2linkedhashset">2.<strong>LinkedHashSet</strong></span></h2><h2><span id="3treeset">3.<strong>TreeSet</strong></span></h2><p>TreeSet 是可以排序的 Set，一般我们需要有序，从数据库拉出来的数据就是有序的，可能往往写<code>order by id desc</code>比较多。</p>
<h2><span id="4enumset">4.<strong>EnumSet</strong></span></h2><h1><span id="queue集合">Queue集合</span></h1><p>在 <u>生产者和消费者模式</u> 中, 最简单的方式就是用 <strong><em>阻塞队列</em></strong> 去写</p>
<h2><span id="示例">示例</span></h2><h3><span id="生产者">生产者</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// true---&gt;生产者一直执行，false---&gt;停掉生产者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector sharedQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共资源的最大数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Vector sharedQueue, <span class="keyword">int</span> SIZE)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sharedQueue = sharedQueue;</span><br><span class="line">        <span class="keyword">this</span>.SIZE = SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"start producer id = "</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">                <span class="comment">// 模拟延迟</span></span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当队列满时阻塞等待</span></span><br><span class="line">                <span class="keyword">while</span> (sharedQueue.size() == SIZE) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (sharedQueue) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Queue is full, producer "</span> + Thread.currentThread().getId()</span><br><span class="line">                                + <span class="string">" is waiting, size："</span> + sharedQueue.size());</span><br><span class="line">                        sharedQueue.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 队列不满时持续创造新元素</span></span><br><span class="line">                <span class="keyword">synchronized</span> (sharedQueue) &#123;</span><br><span class="line">                    <span class="comment">// 生产数据</span></span><br><span class="line">                    data = count.incrementAndGet();</span><br><span class="line">                    sharedQueue.add(data);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"producer create data:"</span> + data + <span class="string">", size："</span> + sharedQueue.size());</span><br><span class="line">                    sharedQueue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="消费者">消费者</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector sharedQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Vector sharedQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sharedQueue = sharedQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"start consumer id = "</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 模拟延迟</span></span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当队列空时阻塞等待</span></span><br><span class="line">                <span class="keyword">while</span> (sharedQueue.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (sharedQueue) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Queue is empty, consumer "</span> + Thread.currentThread().getId()</span><br><span class="line">                                + <span class="string">" is waiting, size："</span> + sharedQueue.size());</span><br><span class="line">                        sharedQueue.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 队列不空时持续消费元素</span></span><br><span class="line">                <span class="keyword">synchronized</span> (sharedQueue) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"consumer consume data："</span> + sharedQueue.remove(<span class="number">0</span>) + <span class="string">", size："</span> + sharedQueue.size());</span><br><span class="line">                    sharedQueue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="测试">测试</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.构建内存缓冲区</span></span><br><span class="line">        Vector sharedQueue = <span class="keyword">new</span> Vector();</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.建立线程池和线程</span></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        Producer prodThread1 = <span class="keyword">new</span> Producer(sharedQueue, size);</span><br><span class="line">        Producer prodThread2 = <span class="keyword">new</span> Producer(sharedQueue, size);</span><br><span class="line">        Producer prodThread3 = <span class="keyword">new</span> Producer(sharedQueue, size);</span><br><span class="line">        Consumer consThread1 = <span class="keyword">new</span> Consumer(sharedQueue);</span><br><span class="line">        Consumer consThread2 = <span class="keyword">new</span> Consumer(sharedQueue);</span><br><span class="line">        Consumer consThread3 = <span class="keyword">new</span> Consumer(sharedQueue);</span><br><span class="line">        service.execute(prodThread1);</span><br><span class="line">        service.execute(prodThread2);</span><br><span class="line">        service.execute(prodThread3);</span><br><span class="line">        service.execute(consThread1);</span><br><span class="line">        service.execute(consThread2);</span><br><span class="line">        service.execute(consThread3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.睡一会儿然后尝试停止生产者(结束循环)</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        prodThread1.stop();</span><br><span class="line">        prodThread2.stop();</span><br><span class="line">        prodThread3.stop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.再睡一会儿关闭线程池</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.shutdown()等待任务执行完才中断线程(因为消费者一直在运行的，所以会发现程序无法结束)</span></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实场景例子：</p>
<ul>
<li>运营要发一条推送消息，首先需要去用户画像系统圈选一个人群，填写对应的人群ID和发送时间。</li>
<li>我通过时间调度，通过RPC拿到人群的信息。遍历HDFS得到这个人群的每个userId</li>
<li>将遍历的userId放到一个阻塞队列里边去，用多个线程while(true)取阻塞队列的数据</li>
</ul>
<p>好处是什么？我在取userId的时候，会有个限制：<strong>要么超出了指定的时间，要么达到BatchSize的值</strong>。这样我就可以<strong>将相同内容的不同userId组成一个Task</strong>。</p>
<p>本来100个userId是100个Task，现在我将100个userId放在一个Task里边（因为发送的内容是相同的，所以我可以这么干）。这样再往下游传的时候，并发量就降低了很多。</p>
<h1><span id="list-集合">List 集合</span></h1><blockquote>
<p>List集合代表一个有序、可重复集合，集合中每个元素都有其对应的顺序索引。List集合默认按照元素的添加顺序设置元素的索引，可以通过索引（类似数组的下标）来访问指定位置的集合元素。</p>
</blockquote>
<h2><span id="1arraylist">1.ArrayList</span></h2><p>ArrayList 底层是动态数组，数组遍历速度快。</p>
<p>在工作中，<strong>遍历的需求比增删多</strong>，即便是增加元素往往也只是从尾部插入元素，而 ArrayList 在尾部插入元素也是 <strong>O(1)</strong>。</p>
<p>ArrayList 增删没有想象中慢，ArrayList 的增删底层调用的 copyOf() 被优化过，加上现代 CPU 对内存可以块操作，普通大小的 ArrayList 增删比 LinkedList 更快</p>
<p>如果考虑到线程安全问题，可以参考 CopyOnWriteArrayList，它的思想在 Linux 文件系统有用到。</p>
<h2><span id="源码">源码</span></h2><p>通过查看源码可以发现 ArrayList 的默认初始容量为 10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="2linkedlist">2.<strong>LinkedList</strong></span></h2><p>LinkedList 底层是链表，链表增删元素快。</p>
<p>LinkedList 本身就实现了 Queue 接口。</p>
<h2><span id="3vector">3.<strong>Vector</strong></span></h2><h2><span id="4stack">4.<strong>Stack</strong></span></h2><h2><span id="5iterator接口和listiterator接口">5.<strong>Iterator接口和ListIterator接口</strong></span></h2><h1><span id="map-集合">Map 集合</span></h1><h2><span id="1hashmap与hashtable">1.<strong>HashMap与Hashtable</strong></span></h2><h2><span id="2linkedhashmap">2.<strong>LinkedHashMap</strong></span></h2><h2><span id="3properties">3.<strong>Properties</strong></span></h2><h2><span id="4treemap">4.<strong>TreeMap</strong></span></h2><h2><span id="5concurrenthashmap">5.ConcurrentHashMap</span></h2><p>ConcurrentHashMap 很多时候用于本地缓存，不想每次都网络请求数据，在本地做缓存。监听数据的变化，如果数据有变动了，就把ConcurrentHashMap对应的值给更新了。</p>
<h1><span id="线程安全">线程安全</span></h1><p>什么时候考虑线程安全的集合类，那当然是线程不安全的时候咯。那什么时候线程不安全？最常见的是：<strong>操作的对象是有状态的</strong></p>
<p>因为我们的操作的对象往往是<strong>无状态</strong>的。<strong>没有共享变量被多个线程访问，自然就没有线程安全问题了</strong>。</p>
<p>SpringMVC是单例的，但SpringMVC都是在方法内操作数据的，每个线程进入方法都会生成栈帧，每个栈帧的数据都是线程独有的，如果不设定共享变量，不会有线程安全问题。</p>
<p>一句话总结：<strong>只要涉及到多个线程操作一个共享变量的时候，就要考虑是不是要用线程安全的集合类</strong>。</p>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之equals理解</title>
    <url>/2020/03/17/Java%E4%B9%8Bequals%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>今天面试的时候，被面试官问到了 ‘ == ‘ 和 ‘ equals ‘ 的区别，最后他还总结 equals 是同通过比较 hashCode() 。其实我当时心里挺疑惑的，我记得好像不是比较 hashCode 的。</p>
<p>于是我看了下 String#equals 源码</p>
<a id="more"></a>

<p>String.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this string to the specified object.  The result is &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * true&#125; if and only if the argument is not &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * String&#125; object that represents the same sequence of characters as this</span></span><br><span class="line"><span class="comment">     * object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  anObject</span></span><br><span class="line"><span class="comment">     *         The object to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the given object represents a &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">     *          equivalent to this string, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>  #compareTo(String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>  #equalsIgnoreCase(String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现比较的顺序</p>
<ol>
<li><strong>比较两个对象的地址是否相同</strong></li>
<li><strong>比较两个对象的类型</strong></li>
<li><strong>比较两个对象的值是否相同</strong></li>
<li><strong>详细比较两个对象的每个字符</strong></li>
</ol>
<blockquote>
<p>如有不对，请指教！</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之线程池解析</title>
    <url>/2020/03/17/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676" target="_blank" rel="noopener">面试必备：Java线程池解析</a></p>
<h1><span id="概念">概念</span></h1><p>简单理解，它就是一个管理线程的池子</p>
<ul>
<li><p><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</p>
</li>
<li><p><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</p>
</li>
<li><p><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p>
</li>
</ul>
<a id="more"></a>

<h1><span id="创建">创建</span></h1><p>线程池可以通过 ThreadPoolExecutor 来创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>几个核心参数的作用：</p>
<ul>
<li><p><strong>corePoolSize：</strong> 线程池核心线程数最大值</p>
</li>
<li><p><strong>maximumPoolSize：</strong> 线程池最大线程数大小</p>
</li>
<li><p><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</p>
</li>
<li><p><strong>unit：</strong> 线程空闲存活时间单位</p>
</li>
<li><p><strong>workQueue：</strong> 存放任务的阻塞队列</p>
</li>
<li><p><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</p>
</li>
<li><p><strong>handler：</strong>  线城池的饱和策略事件，主要有四种类型。</p>
</li>
</ul>
<h1><span id="任务执行">任务执行</span></h1><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/27.png" alt="27.png"></p>
<ul>
<li><p>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</p>
</li>
<li><p>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</p>
</li>
<li><p>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</p>
</li>
<li><p>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</p>
</li>
</ul>
<h2><span id="四种拒绝策略">四种拒绝策略</span></h2><ul>
<li><p>AbortPolicy(抛出一个异常，默认的)</p>
</li>
<li><p>DiscardPolicy(直接丢弃任务)</p>
</li>
<li><p>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</p>
</li>
<li><p>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</p>
</li>
</ul>
<p><strong>为了形象描述线程池执行，我打个比喻：</strong></p>
<ul>
<li><p>核心线程比作公司正式员工</p>
</li>
<li><p>非核心线程比作外包员工</p>
</li>
<li><p>阻塞队列比作需求池</p>
</li>
<li><p>提交任务比作提需求</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/28.png" alt="28.png"></p>
</li>
<li><p>当产品提个需求，正式员工（核心线程）先接需求（执行任务）</p>
</li>
<li><p>如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</p>
</li>
<li><p>如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</p>
</li>
<li><p>如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</p>
</li>
<li><p>如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</p>
</li>
</ul>
<p>好的，到这里。<strong>面试问题1-&gt;Java的线程池说一下，各个参数的作用，如何进行的?</strong> 是否已经迎刃而解啦， 我觉得这个问题，回答：<strong>线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</strong> 就差不多啦。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之intern()深入理解</title>
    <url>/2020/03/17/Java%E4%B9%8Bintern()%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>转载：</p>
<p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">美团大佬技术团队！多关注</a></p>
<p>在 Java 语言中有8中种基本类型和一种比较特殊的类型 <code>String</code>。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个 <strong>Java 系统级别提供的缓存</strong></p>
<p>8种基本类型的常量池都是系统协调的，<code>String</code>类型的常量池比较特殊。它的主要使用方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<a id="more"></a>

<h1><span id="1java代码">1.Java代码</span></h1><p>通过查看源码可以发现，intern() 方法是用 native 修饰的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">     * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">     * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">     * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">     * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">     * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">     *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p>
<h1><span id="2native-代码">2.native 代码</span></h1><p>在 jdk7后，oracle 接管了 JAVA 的源码后就不对外开放了，根据 jdk 的主要开发人员声明 openJdk7 和 jdk7 使用的是同一分主代码，只是分支代码会有些许的变动。所以可以直接跟踪 openJdk7 的源码来探究 intern 的实现。</p>
<ul>
<li><p>native实现代码:</p>
<p>\openjdk7\jdk\src\share\native\java\lang\String.c</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Java_java_lang_String_intern(JNIEnv *env, jobject <span class="keyword">this</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> JVM_InternString(env, <span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\openjdk7\hotspot\src\share\vm\prims\jvm.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* java.lang.String </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">JNIEXPORT jstring JNICALL  </span><br><span class="line">JVM_InternString(JNIEnv *env, jstring str);</span><br></pre></td></tr></table></figure>

<p>\openjdk7\hotspot\src\share\vm\prims\jvm.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String support ///////////////////////////////////////////////////////////////////////////  </span></span><br><span class="line">JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))  </span><br><span class="line">  JVMWrapper(<span class="string">"JVM_InternString"</span>);  </span><br><span class="line">  JvmtiVMObjectAllocEventCollector oam;  </span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  oop <span class="built_in">string</span> = JNIHandles::resolve_non_null(str);  </span><br><span class="line">  oop result = StringTable::intern(<span class="built_in">string</span>, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> (jstring) JNIHandles::make_local(env, result);  </span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">StringTable::intern</span><span class="params">(Handle string_or_null, jchar* name,  </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> len, TRAPS)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = java_lang_String::hash_string(name, len);  </span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);  </span><br><span class="line">  oop <span class="built_in">string</span> = the_table()-&gt;lookup(index, name, len, hashValue);  </span><br><span class="line">  <span class="comment">// Found  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">string</span> != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">string</span>;  </span><br><span class="line">  <span class="comment">// Otherwise, add to symbol to table  </span></span><br><span class="line">  <span class="keyword">return</span> the_table()-&gt;basic_add(index, string_or_null, name, len,  </span><br><span class="line">                                hashValue, CHECK_NULL);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">StringTable::lookup</span><span class="params">(<span class="keyword">int</span> index, jchar* name,  </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">for</span> (HashtableEntry&lt;oop&gt;* l = bucket(index); l != <span class="literal">NULL</span>; l = l-&gt;next()) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (l-&gt;hash() == hash) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (java_lang_String::equals(l-&gt;literal(), name, len)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> l-&gt;literal();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的大体实现结构就是：</p>
<p>Java 使用 <code>JNI</code> 调用 C++ 实现的 <code>StringTable</code> 的 <code>intern</code> 方法，<code>StringTable</code>的<code>intern</code>方法跟Java中的<code>HashMap</code>的实现是差不多的, 只是不能自动扩容。默认大小是1009。</p>
<p>要注意的是，String的String Pool是一个固定大小的<code>Hashtable</code>，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String.intern</code>时性能会大幅下降（因为要一个一个找）。</p>
<p>在 jdk6中<code>StringTable</code>是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，<code>StringTable</code>的长度可以通过一个参数指定：</p>
<ul>
<li><code>-XX:StringTableSize=99991</code></li>
</ul>
<p>相信很多 JAVA 程序员都做做类似 <code>String s = new String(&quot;abc&quot;)</code>这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象。</p>
<h1><span id="示例">示例</span></h1><p>来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果是</p>
<ul>
<li>jdk6 下<code>false false</code></li>
<li>jdk7 下<code>false true</code></li>
</ul>
<p>具体为什么稍后再解释，然后将<code>s3.intern();</code>语句下调一行，放到<code>String s4 = &quot;11&quot;;</code>后面。将<code>s.intern();</code> 放到<code>String s2 = &quot;1&quot;;</code>后面。是什么结果呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<ul>
<li>jdk6 下<code>false false</code></li>
<li>jdk7 下<code>false false</code></li>
</ul>
<h2><span id="解释">解释</span></h2><h3><span id="jdk6中的解释">jdk6中的解释</span></h3><p><img src="https://img-blog.csdnimg.cn/20200317125431592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="jdk6图"></p>
<p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p>
<p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用<code>String.intern</code>方法也是没有任何关系的。</p>
<h3><span id="jdk7中的解释">jdk7中的解释</span></h3><p>再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生<code>java.lang.OutOfMemoryError: PermGen space</code>错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。</p>
<p>正式因为字符串常量池移动到 JAVA Heap 区域后，再来解释为什么会有上述的打印结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200317125452636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="jdk7图1"></p>
<ul>
<li>在第一段代码中，先看 s3和s4字符串。<code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</code>，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的<code>new String(&quot;1&quot;)</code>我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。</li>
<li>接下来<code>s3.intern();</code>这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</li>
<li>最后<code>String s4 = &quot;11&quot;;</code> 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 <code>s3 == s4</code> 是 true。</li>
<li>再看 s 和 s2 对象。 <code>String s = new String(&quot;1&quot;);</code> 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。<code>s.intern();</code> 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</li>
<li>接下来<code>String s2 = &quot;1&quot;;</code> 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。图中画的很清晰。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200317125502968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="jdk7图2"></p>
<h3><span id="小结">小结</span></h3><p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
<ul>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ul>
<h1><span id="3intern-正确使用例子">3.intern 正确使用例子</span></h1><p>接下来我们来看一下一个比较常见的使用<code>String#intern</code>方法的例子。</p>
<p>代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static final <span class="built_in">int</span> MAX = <span class="number">1000</span><span class="operator"> * </span><span class="number">10000</span>;</span><br><span class="line">static final String<span class="literal">[]</span> arr = <span class="keyword">new</span> String<span class="literal">[MAX]</span>;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">    Integer<span class="literal">[]</span> DB_DATA = <span class="keyword">new</span> Integer<span class="literal">[<span class="number">10</span>]</span>;</span><br><span class="line">    Random random = <span class="keyword">new</span> <span class="constructor">Random(10 <span class="operator">*</span> 10000)</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="module-access"><span class="module"><span class="identifier">DB_DATA</span>.</span></span>length; i++) &#123;</span><br><span class="line">        DB_DATA<span class="literal">[<span class="identifier">i</span>]</span> = random.next<span class="constructor">Int()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	long t = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        <span class="comment">//arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span></span><br><span class="line">         arr<span class="literal">[<span class="identifier">i</span>]</span> = <span class="keyword">new</span> <span class="constructor">String(String.<span class="params">valueOf</span>(DB_DATA[<span class="params">i</span> % DB_DATA.<span class="params">length</span>])</span>).intern<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println((<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span> - t) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>gc<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的参数是：<code>-Xmx2g -Xms2g -Xmn1500M</code> 上述代码是一个演示代码，其中有两条语句不一样，一条是使用 intern，一条是未使用 intern。结果如下图</p>
<p>2160ms</p>
<p><img src="https://img-blog.csdnimg.cn/20200317125338436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="使用 intern"></p>
<p>826ms<img src="https://img-blog.csdnimg.cn/2020031712540094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="未使用 intern"></p>
<p>通过上述结果，我们发现不使用 intern 的代码生成了1000w 个字符串，占用了大约640m 空间。 使用了 intern 的代码生成了1345个字符串，占用总空间 133k 左右。其实通过观察程序中只是用到了10个字符串，所以准确计算后应该是正好相差100w 倍。虽然例子有些极端，但确实能准确反应出 intern 使用后产生的巨大空间节省。</p>
<p>细心的同学会发现使用了 intern 方法后时间上有了一些增长。这是因为程序中每次都是用了 <code>new String</code> 后，然后又进行 intern 操作的耗时时间，这一点如果在内存空间充足的情况下确实是无法避免的，但我们平时使用时，内存空间肯定不是无限大的，不使用 intern 占用空间导致 jvm 垃圾回收的时间是要远远大于这点时间的。 毕竟这里使用了1000w次intern 才多出来1秒钟多的时间。</p>
<h1><span id="4intern-不当使用">4.intern 不当使用</span></h1><p>看过了 intern 的使用和 intern 的原理等，我们来看一个不当使用 intern 操作导致的问题。</p>
<p>在使用 fastjson 进行接口读取的时候，我们发现在读取了近70w条数据后，我们的日志打印变的非常缓慢，每打印一次日志用时30ms左右，如果在一个请求中打印2到3条日志以上会发现请求有一倍以上的耗时。在重新启动 jvm 后问题消失。继续读取接口后，问题又重现。接下来我们看一下出现问题的过程</p>
<h2><span id="41根据-log4j-打印日志查找问题原因">4.1.根据 log4j 打印日志查找问题原因</span></h2><p>在使用<code>log4j#info</code>打印日志的时候时间非常长。所以使用 housemd 软件跟踪 info 方法的耗时堆栈。</p>
<ul>
<li>trace SLF4JLogger.</li>
<li>trace AbstractLoggerWrapper:</li>
<li>trace AsyncLogger</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">org/apache/logging/log4j/core/async/AsyncLogger.actualAsyncLog(RingBufferLogEvent)                sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">109</span>aca82            <span class="number">1</span>            <span class="number">1ms</span>    org<span class="selector-class">.apache</span><span class="selector-class">.logging</span><span class="selector-class">.log4j</span><span class="selector-class">.core</span><span class="selector-class">.async</span>.AsyncLogger@<span class="number">19</span>de86bb  </span><br><span class="line">org/apache/logging/log4j/core/async/AsyncLogger.location(String)                                  sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">30ms</span>    org<span class="selector-class">.apache</span><span class="selector-class">.logging</span><span class="selector-class">.log4j</span><span class="selector-class">.core</span><span class="selector-class">.async</span>.AsyncLogger@<span class="number">19</span>de86bb  </span><br><span class="line">org/apache/logging/log4j/core/async/AsyncLogger.log(Marker, String, Level, Message, Throwable)    sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">61ms</span>    org<span class="selector-class">.apache</span><span class="selector-class">.logging</span><span class="selector-class">.log4j</span><span class="selector-class">.core</span><span class="selector-class">.async</span>.AsyncLogger@<span class="number">19</span>de86bb</span><br></pre></td></tr></table></figure>

<p>代码出在 <code>AsyncLogger.location</code> 这个方法上. 里边主要是调用了 <code>return Log4jLogEvent.calcLocation(fqcnOfLogger);</code>和<code>Log4jLogEvent.calcLocation()</code></p>
<p><code>Log4jLogEvent.calcLocation()</code>的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StackTraceElement <span class="title">calcLocation</span><span class="params">(<span class="keyword">final</span> String fqcnOfLogger)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (fqcnOfLogger == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();  </span><br><span class="line">    <span class="keyword">boolean</span> next = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> StackTraceElement element : stackTrace) &#123;  </span><br><span class="line">        <span class="keyword">final</span> String className = element.getClassName();  </span><br><span class="line">        <span class="keyword">if</span> (next) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> element;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </span><br><span class="line">            next = <span class="keyword">true</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NOT_AVAIL.equals(className)) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过跟踪发现是 <code>Thread.currentThread().getStackTrace();</code> 的问题。</p>
<h2><span id="42跟踪threadcurrentthreadgetstacktrace的-native-代码验证stringintern">4.2.跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern</span></h2><p><code>Thread.currentThread().getStackTrace();</code>native的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> StackTraceElement[] getStackTrace() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;  </span><br><span class="line">        <span class="comment">// check for getStackTrace permission  </span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();  </span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            security.checkPermission(  </span><br><span class="line">                SecurityConstants.GET_STACK_TRACE_PERMISSION);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// optimization so we do not call into the vm for threads that  </span></span><br><span class="line">        <span class="comment">// have not yet started or have terminated  </span></span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;  </span><br><span class="line">            <span class="keyword">return</span> EMPTY_STACK_TRACE;  </span><br><span class="line">        &#125;        StackTraceElement[][] stackTraceArray = dumpThreads(<span class="keyword">new</span> Thread[] &#123;<span class="keyword">this</span>&#125;);  </span><br><span class="line">        StackTraceElement[] stackTrace = stackTraceArray[<span class="number">0</span>];  </span><br><span class="line">        <span class="comment">// a thread that was alive during the previous isAlive call may have  </span></span><br><span class="line">        <span class="comment">// since terminated, therefore not having a stacktrace.  </span></span><br><span class="line">        <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            stackTrace = EMPTY_STACK_TRACE;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stackTrace;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// Don't need JVM help for current thread  </span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Exception()).getStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> StackTraceElement[][] dumpThreads(Thread[] threads);</span><br></pre></td></tr></table></figure>

<p>下载 openJdk7的源码查询 jdk 的 native 实现代码，列表如下【这里因为篇幅问题，不详细罗列涉及到的代码，有兴趣的可以根据文件名称和行号查找相关代码】：</p>
<p>\openjdk7\jdk\src\share\native\java\lang\Thread.c<br>\openjdk7\hotspot\src\share\vm\prims\jvm.h line:294: \openjdk7\hotspot\src\share\vm\prims\jvm.cpp line:4382-4414:<br>\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:235-267: \openjdk7\hotspot\src\share\vm\services\threadService.cpp line:566-577:<br>\openjdk7\hotspot\src\share\vm\classfile\javaClasses.cpp line:1635-[1651,1654,1658]:</p>
<p>完成跟踪了底层的 jvm 源码后发现，是下边的三条代码引发了整个程序的变慢问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oop classname = StringTable::intern((<span class="keyword">char</span>*) str, CHECK_0);  </span><br><span class="line">oop methodname = StringTable::intern(method-&gt;name(), CHECK_0);  </span><br><span class="line">oop filename = StringTable::intern(source, CHECK_0);</span><br></pre></td></tr></table></figure>

<p>这三段代码是获取类名、方法名、和文件名。因为类名、方法名、文件名都是存储在字符串常量池中的，所以每次获取它们都是通过<code>String#intern</code>方法。但没有考虑到的是默认的 StringPool 的长度是1009且不可变的。因此一旦常量池中的字符串达到的一定的规模后，性能会急剧下降。</p>
<h2><span id="43fastjson-不当使用-stringintern">4.3.fastjson 不当使用 String#intern</span></h2><p>导致这个 intern 变慢的原因是因为 fastjson 对<code>String#intern</code>方法的使用不当造成的。跟踪 fastjson 中的实现代码发现，</p>
<p><code>com.alibaba.fastjson.parser.JSONScanner#scanFieldSymbol()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == <span class="string">'\"'</span>) &#123;</span><br><span class="line">    bp = index;</span><br><span class="line">    <span class="keyword">this</span>.ch = ch = buf[bp];</span><br><span class="line">    strVal = symbolTable.addSymbol(buf, start, index - start - <span class="number">1</span>, hash);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alibaba.fastjson.parser.SymbolTable#addSymbol()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new entry from the specified symbol information and next entry reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> hash, Entry next)</span></span>&#123;</span><br><span class="line">    characters = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">    System.arraycopy(ch, offset, characters, <span class="number">0</span>, length);</span><br><span class="line">    symbol = <span class="keyword">new</span> String(characters).intern();</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.hashCode = hash;</span><br><span class="line">    <span class="keyword">this</span>.bytes = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fastjson 中对所有的 json 的 key 使用了 intern 方法，缓存到了字符串常量池中，这样每次读取的时候就会非常快，大大减少时间和空间。而且 json 的 key 通常都是不变的。这个地方没有考虑到大量的 json key 如果是变化的，那就会给字符串常量池带来很大的负担。</p>
<p>这个问题 fastjson 在1.1.24版本中已经将这个漏洞修复了。程序加入了一个最大的缓存大小，超过这个大小后就不会再往字符串常量池中放了。</p>
<p>[1.1.24版本的<code>com.alibaba.fastjson.parser.SymbolTable#addSymbol()</code> Line:113]代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt;= MAX_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer, offset, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题是70w 数据量时候的引发的，如果是几百万的数据量的话可能就不只是30ms 的问题了。因此在使用系统级提供的<code>String#intern</code>方式一定要慎重！</p>
<p>本文大体的描述了 <code>String#intern</code>和字符串常量池的日常使用，jdk 版本的变化和<code>String#intern</code>方法的区别，以及不恰当使用导致的危险等内容，让大家对系统级别的 <code>String#intern</code>有一个比较深入的认识。让我们在使用和接触它的时候能避免出现一些 bug，增强系统的健壮性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>常量池</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架Thrift</title>
    <url>/2020/03/16/RPC%E6%A1%86%E6%9E%B6Thrift/</url>
    <content><![CDATA[<p><code>Thrift</code>是一个<strong>轻量级</strong>、<strong>跨语言</strong>的<strong>远程服务调用</strong>框架，它通过自身的<code>IDL</code><strong>中间语言</strong>, 并借助<strong>代码生成引擎</strong>生成各种主流语言的<code>RPC</code><strong>服务端</strong>/<strong>客户端</strong>模板代码。</p>
<p><strong>如何实现多语言之间的通信？</strong></p>
<a id="more"></a>

<p>数据传输使用 socket(多种语言均支持)，数据再以特定的格式 (String 等) 发送，接收方语言进行解析。</p>
<p>定义 thrift 的文件，由 thrift 文件(IDL) 生成双方语言的接口，model，在生成的 model 以及接口中会有解码编码的代码</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvMjkzODFmMzBlOTI0Yjg5OTkzNjZhYzEyNmMwNjFkOTUwYTdiZjY0Ng?x-oss-process=image/format,png" alt="img"></p>
<p><strong>Thrift 传输格式</strong></p>
<ul>
<li>TBinaryProtocol: 二进制格式</li>
<li>TCompactProtocol: 压缩格式</li>
<li>TJSONProtocol： JSON格式</li>
<li>TSimpleJSONProtocol： 提供 JSON 只写协议，生成的文件很容易通过脚本语言解析</li>
<li>TDebugProtocol：使用易懂的可读的文本格式，以便于debug</li>
</ul>
<p><strong>Thrift数据传输方式</strong></p>
<ul>
<li>TSocket：阻塞式socket</li>
<li>TFramedTransport：以frame为单位进行传输，以非阻塞式服务中使用</li>
<li>TFileTransport：以文件形式进行传输</li>
<li>TMemoryTransport：将内存用于 I/O, Java 实现内部实际使用了简单的 ByteArrayOutputStream</li>
<li>TZlibTransport：使用 zlib 进行压缩，与其他传输方式联合使用。当前无 Java 实现</li>
</ul>
<p>Thrift支持的服务模型</p>
<ul>
<li>TSimpleServer：简单的单线程服务模型，常用于测试</li>
<li>TThreadPoolServer：多线程服务模型，使用标准的阻塞式 IO</li>
<li>TNonblockingServer：多线程服务模型，使用非阻塞式 IO(需使用TFramedTransport数据传输方式)</li>
<li>THsHaServer：THsHa 引入了线程池去处理，其模型把读写任务放到线程池去处理；Half-sync/Half-async 的处理模式，Half-async 是在处理 IO 事件上(accept/read/write io),Half-sync 用于 handler 对 rpc 的同步处理</li>
</ul>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT7.7.x版本添加访问量和访客数</title>
    <url>/2020/03/15/NexT7.7.x%E7%89%88%E6%9C%AC%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E8%AE%BF%E5%AE%A2%E6%95%B0/</url>
    <content><![CDATA[<p>最近看多了别人的个人博客网站弄得挺精致的，居然有<strong>访客数</strong>和<strong>访问量</strong>，不行我也不能落后，所以自己也准备升级下自己简陋的博客网站哈哈。</p>
<p>由于我的 Hexo 的版本(7.7.2) 在目前来说是最新的，所以通过百度和google查询到的资料不多，所以耗费了好几个小时在搜查相关的资料，终于功夫不负有心人，最终升级成功。</p>
<p>据<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官网</a>说, 他们在第三方服务中提供了 <strong>不蒜子统计</strong> 的功能，看来多看看官网还是有好处的哈哈。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200315223305251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200315222038516"></p>
<p>1.参照了相关的资料，需要修改将 <strong>主题配置文件</strong> 中的<code>busuanzi_count</code>的配置项。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>给 <strong>footer.swig</strong> 添加以下内容，该文件在径<code>&quot;\themes\next\layout\_partials\</code> 下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">	&lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">		&lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">	&lt;&#x2F;span&gt;</span><br><span class="line">	访问量：&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt; 次数</span><br><span class="line">&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">	&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">	访客数：&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt; 人次</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 以上内容放错位置可就显示的不好看哦</p>
</blockquote>
<p>把这段内容添加 <code>&lt;div div class=&quot;copyright&quot;&gt;</code> 模块的末尾添加，示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;copyright&quot;&gt;</span><br><span class="line">  &#123;% set copyright_year &#x3D; date(null, &#39;YYYY&#39;) %&#125;</span><br><span class="line">  &amp;copy; &#123;% if theme.footer.since and theme.footer.since !&#x3D; copyright_year %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;</span><br><span class="line">  &lt;span itemprop&#x3D;&quot;copyrightYear&quot;&gt;&#123;&#123; copyright_year &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;with-love&quot;&gt;</span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.footer.icon.name &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;author&quot; itemprop&#x3D;&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright or author &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">  &#123;%- if config.symbols_count_time.total_symbols %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-area-chart&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#39;symbols_count_time.count_total&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title&#x3D;&quot;&#123;&#123; __(&#39;symbols_count_time.count_total&#39;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsCountTotal(site) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if config.symbols_count_time.total_time %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-coffee&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#39;symbols_count_time.time_total&#39;) &#125;&#125; &amp;asymp;&lt;&#x2F;span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title&#x3D;&quot;&#123;&#123; __(&#39;symbols_count_time.time_total&#39;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsTimeTotal(site, theme.symbols_count_time.awl, theme.symbols_count_time.wpm, __(&#39;symbols_count_time.time_minutes&#39;)) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;添加的位置从这里开始</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    访问量：&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt; 次数</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">    访客数：&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt; 人次</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">  &#x2F;&#x2F;这里结束</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>重新部署一下，需要的内容就出来啦！</p>
<p>效果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200315223249814.png" alt="image-20200315223107231"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中基本类型存储方式</title>
    <url>/2020/03/15/Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>java 把内存分为两种：</p>
<p>一种是 <strong>栈内存</strong>，另一种是 <strong>堆内存</strong></p>
<ol>
<li>在函数中定义的基本类型变量(即基本类型的局部变量) 和 对象的引用变量(即对象的变量名) 都在函数的栈内存中分配</li>
<li>堆内存用来存放由 new 创建的对象和数组以及对象的实例变量(即全局变量)</li>
</ol>
<p>方法区中主要存储所有对象数据共享区域，存储静态变量和普通方法、静态方法、常量、字符串常量（严格说存放在常量池，堆和栈都有）等类信息，、说白了就是保存类的模板</p>
<a id="more"></a>

<p>其实基本类型的数据并不都是存储在栈上的，例如：类的成员变量如果是基本类型(int,float,double等)，它就存储在堆内存中。</p>
<p><strong><em>反证</em></strong>：如果类的成员变量(基本数据类型)存储在栈上，众所周知，栈<strong>不是线程共享</strong>的且它的生命周期随着相关方法的结束就结束，可这时只是执行完了一个方法，而整个类的生命周期还未结束，难道这个类的成员变量也就无法调用了？这不就矛盾了吗？</p>
<p>所以说基本类型的数据并不都是存储在栈上的。而且堆是<strong>线程共享的</strong>，类的成员变量应该是属于这个类的，而不是属于某个方法的，具有共享的性质，所以也应该存储在堆上。</p>
<p>总结：</p>
<ol>
<li>方法内定义的基本数据类型放在栈帧中，栈里面的数据都是线程私有的，不共享。</li>
<li>方法外定义的类成员变量，存放在 JVM 的堆中</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Protobuf协议缓冲区</title>
    <url>/2020/03/15/Google-Protobuf%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<p><a href="https://developers.google.cn/protocol-buffers/" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://juejin.im/post/5938f1785c497d006b613b0d" target="_blank" rel="noopener">更小、更快、更简单Google ProtoBuf 跨语言通信协议</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1146352" target="_blank" rel="noopener">通讯协议序列化解读（一） Protobuf详解教程</a></p>
<blockquote>
<p>协议缓冲区是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。</p>
</blockquote>
<a id="more"></a>]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之装饰器模式</title>
    <url>/2020/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">装饰器模式</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319302594594" target="_blank" rel="noopener">装饰器</a></p>
<blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来讲，相比生成子类更为灵活</p>
</blockquote>
<p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200313164100749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200215214741558"></p>
<ul>
<li><p><strong>Component(组件)：</strong>组件接口定义了全部组件实现类以及所有 <em>装饰器实现的行为。</em></p>
</li>
<li><p><strong>ConcreteComponent(具体组件实现类)：</strong>具体组件实现类实现了Component接口。通常情况下，具体组件实现类就是被装饰器装饰的原始对象，该类提供了 Component 接口中定义的最基本的功能，其它高级功能或后续添加的新功能，都是通过装饰器的方式添加到该类的对象之上。</p>
</li>
<li><p><strong>Decorator(装饰器)：</strong>所有装饰器的父类，它是一个实现了 Component 接口的<em>抽象类</em>，并在<em>其中封装了一个 Component 对象</em>，也就是被装饰的对象。而这个被装饰的对象只要是 Component 类型即可，这就实现了装饰器的组合和复用。</p>
</li>
<li><p><strong>ConcreteDecorator：</strong>具体的装饰器实现类，该实现类要向被装饰对象添加某些功能。</p>
</li>
</ul>
<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>

<p>Decorator模式有什么好处？<strong>它实际上把 <em>核心功能</em> 和 <em>附加功能</em> 给分开了</strong>。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造者模式</title>
    <url>/2020/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://juejin.im/post/5a23bdd36fb9a045272568a6" target="_blank" rel="noopener">人人都会设计模式—建造者模式–Builder</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319155793953#0" target="_blank" rel="noopener">生成器</a></p>
<blockquote>
<p>将一个复杂对象的构建过程与它的表示分离，从而使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>建造者模式将一个复杂对象的创建过程分成了一步步简单的步骤，用户只需要了解复杂对象的类型和内容，而无须关注复杂对象的具体构造过程，帮助用户屏蔽掉了复杂对象内部的具体构建细节。</p>
<a id="more"></a>

<p><img src="http://q6s1x2hw2.bkt.clouddn.com/10.png" alt="image-20200219114359493"></p>
<p>主要角色如下所述：</p>
<ul>
<li><strong>建造者(Builder)接口：</strong>Builder接口用于定义建造者构建产品对象的各部分行为</li>
<li><strong>具体建造者(ConcreteBuilder)角色：</strong>在建造者模式中，直接创建产品对象的是具体建造者。具体建造者类必须实现建造者接口所要求的两类方法：<ul>
<li>建造方法</li>
<li>获取构建好的产品对象方法</li>
</ul>
</li>
<li><strong>导演(Direct)角色：</strong>该角色会通过调用具体建造者，创建需要的产品对象</li>
<li><strong>产品(Product)角色：</strong>产品对象就是用户需要使用的复杂对象</li>
</ul>
<h2><span id="一什么是建造者模式">一.什么是建造者模式</span></h2><h3><span id="1生活中的建造者模式">1.生活中的建造者模式</span></h3><blockquote>
<p>1.盖房子</p>
</blockquote>
<p>我们在生活中盖房子，一般就是打地基，盖框架「用砖头或钢筋混凝土」，然后是粉刷。基本上就是这个路子。当然我们这些工作全部可以自己做，可也以找几个工人去干，当然还可以可以直接找一个设计师，直接说我就要这样的房子，然后就不管了，最后问设计师「设计师给一张纸给工人，工人就啪啪的干了」验收房子即可「至于你是如何建的过程我不关心，我只要结果」—这就是建造者模式</p>
<blockquote>
<p>2.组装电脑</p>
</blockquote>
<p>我们买的电脑都是由主板、内存、cpu、显卡等组成，如何把这些东西组装起来给用户这就是建造者模式的作用，不同的人对电脑的配置需求不一样的「打游戏的对显卡要求高」，但是电脑构成部件是固定的，我们找电脑城的装机人员把电脑装起来这一过程就是建造模式</p>
<blockquote>
<p>3.软件开发</p>
</blockquote>
<p>我们开发一款产品，需要技术主管、产品经理、苦逼的程序员。在这里，产品经理就是指挥者「Director」和客户沟通，了解产品需求，技术主管是抽象的建造者[Builder]，让猿们杂做就杂做，而程序员就是体力劳动者「即具体的建造者，按照技术主管下发的任务去做」</p>
<h3><span id="2程序中的建造者模式">2.程序中的建造者模式</span></h3><blockquote>
<p>建造者模式的特点</p>
</blockquote>
<p>建造者模式是一种创建型模式，适用于那些流程固定【顺序不一定固定】，建造的目标对象会有所改变这种场景【比如画一条狗，这个目标不变，但是不同的是有黄狗，胖狗，瘦狗等】</p>
<p>还有一种场景就是替代 <strong>多参数构造器</strong></p>
<blockquote>
<p>建造者模式的作用</p>
</blockquote>
<ul>
<li>1、用户不知道对象的建造过程和细节就可以创建出复杂的对象「屏蔽了建造的具体细节」</li>
<li>2、用户只需给出复杂对象的内容和类型可以创建出对象</li>
<li>3、建造者模工按流程一步步的创建出复杂对象</li>
</ul>
<blockquote>
<p>建造者模式的结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>角色</th>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Builder</td>
<td>接口或抽象类</td>
<td>抽象的建造者，不是必须的</td>
</tr>
<tr>
<td>ConcreateBuilder</td>
<td>具体的建造者</td>
<td>可以有多个「因为每个建造风格可能不一样」</td>
</tr>
<tr>
<td>Product</td>
<td>普通的类</td>
<td>具体的产品「即被建造的对象」</td>
</tr>
<tr>
<td>Director</td>
<td>导演也叫指挥者</td>
<td>统一指挥建造者去建造目标，导演不是必须的</td>
</tr>
</tbody></table>
<h2><span id="二-建造者模式的举例">二 建造者模式的举例</span></h2><blockquote>
<p>1.组装电脑</p>
</blockquote>
<p>小明想组装一个台式电脑，小明对电脑配置一窍不通，就直接跑到电脑城给装机老板说我要一台打游戏非常爽的电脑，麻烦你给装一下「配置什么的你给我推荐一下吧」，于是老板就让它的员工「小美」按小明的要求装了一个性能灰常牛 B 的电脑，1 个小时后电脑装好了，小明交钱拿电脑走人。不一会儿小张又来了，要一个满足平时写文章就可以的电脑，老板针对小张的要求给不同的装机配置。不同的人有不同的配置方案「但是装机流程是一样的」，这就是一个典型的建造者模式</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/11.png" alt="组装电脑简单的 UML"></p>
<ul>
<li>创建被建造的对象电脑(产品类) — Computer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 产品类--被建造的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu ; <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hardDisk ; <span class="comment">//硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String mainBoard ; <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String memory ; <span class="comment">// 内存</span></span><br><span class="line">    ... 省略 getter 和 setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象的建造者 — Builder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 抽象的建造者，即装电脑的步骤</span></span><br><span class="line"><span class="comment"> * 至于安装什么型号的主板，不是我关心，而是具体的建造者关心的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 安装主板</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装 cpu</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createCpu</span><span class="params">(String cpu)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装硬盘</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createhardDisk</span><span class="params">(String hardDisk)</span> </span>;</span><br><span class="line">    <span class="comment">// 安装内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span> </span>;</span><br><span class="line">    <span class="comment">// 组成电脑</span></span><br><span class="line">    <span class="function">Computer <span class="title">createComputer</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体建造者，也就是装机工人小美 — AssemblerBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 具体的建造者，这里是商场的一个装机人员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssemblerBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer = <span class="keyword">new</span> Computer() ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createhardDisk</span><span class="params">(String hardDisk)</span> </span>&#123;</span><br><span class="line">        computer.setHardDisk(hardDisk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">        computer.setMainBoard(mainBoard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMemory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还有老板「”指手画脚的人”」安排装机工工作 — Direcror.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 声明一个导演类「指挥者，这里可以装电脑的老板」，用来指挥组装过程，也就是组装电脑的流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder ;</span><br><span class="line">	<span class="comment">// 使用多态，装机工非常多，我管你小美，小兰，小猪，我统统收了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Direcror</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 老板最后只想看到装成的成品---要交到客户手中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">(String cpu,String hardDisk,String mainBoard,String memory)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 具体的工作是装机工去做</span></span><br><span class="line">        <span class="keyword">this</span>.builder.createMainBoard(mainBoard);</span><br><span class="line">        <span class="keyword">this</span>.builder.createCpu(cpu) ;</span><br><span class="line">        <span class="keyword">this</span>.builder.createMemory(memory);</span><br><span class="line">        <span class="keyword">this</span>.builder.createhardDisk(hardDisk);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.builder.createComputer() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">// 装机员小美</span></span><br><span class="line">        Builder builder = <span class="keyword">new</span> AssemblerBuilder() ;</span><br><span class="line">        <span class="comment">// 老板把小明的需求转给小美</span></span><br><span class="line">        Direcror direcror = <span class="keyword">new</span> Direcror(builder) ;</span><br><span class="line">        <span class="comment">// 老板最后拿到成品机子，工作全由小美去做</span></span><br><span class="line">        Computer computer = direcror.createComputer(<span class="string">"Intel 酷睿i9 7900X"</span>,<span class="string">"三星M9T 2TB （HN-M201RAD）"</span>,<span class="string">"技嘉AORUS Z270X-Gaming 7"</span>,<span class="string">"科赋Cras II 红灯 16GB DDR4 3000"</span>) ;</span><br><span class="line">        System.out.println(<span class="string">"小明这台电脑使用的是：\n"</span>+computer.getMainBoard()+<span class="string">" 主板\n"</span>+computer.getCpu()+<span class="string">" CPU\n"</span>+computer.getHardDisk()+<span class="string">"硬盘\n"</span>+computer.getMainBoard()+<span class="string">" 内存\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.盖房子</p>
</blockquote>
<p>盖房子的基本步骤和流程是固定的无非就是打地基、盖框架、然后浇筑「至于盖平房、还是楼房那是每个客户的具体需求」。总体来说盖房子以有以三种方式：</p>
<ul>
<li>1、自己盖房子「没有办法有的人就是牛 B ,自己设计，自己动手，当然这属于小房子，你让一个人盖个32 层让我看看」</li>
<li>2、想盖房子的人是一个包工头，自己找一帮工人自己就把房子搞定了</li>
<li>3、想盖房子的人就是一个普通人，啥也不会，找一个设计师说“我就要盖个房子，南北通透，四秀常春”，设计师说没有问题，设计师把设计出来的图纸扔给包工头说：“就照这个样子盖”，包工头拿着图纸给工人们分工派活，最后完工</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/12.png" alt="盖房子建造者模式简单的 UML"></p>
<ul>
<li>房子对象 House.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 最终的产品---房子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="keyword">private</span> String foundation ;</span><br><span class="line">    <span class="comment">// 盖框架</span></span><br><span class="line">    <span class="keyword">private</span> String frame ;</span><br><span class="line">    <span class="comment">// 浇筑</span></span><br><span class="line">    <span class="keyword">private</span> String pouring ;</span><br><span class="line">    ... 省略 setter 和 getter </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象建造者「包工头」 HouseBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 盖框架</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 浇灌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="comment">// 房子建成 </span></span><br><span class="line">    <span class="function">House <span class="title">getHouse</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体建造者「工人」–盖平房 PingFangBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 盖平房</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingFangBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> House house = <span class="keyword">new</span> House() ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFoundation(<span class="string">"盖平房的地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFrame(<span class="string">"盖平房的框架"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setPouring(<span class="string">"盖平房不用浇灌，直接人工手刷就可以"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体建造者「工人」–盖楼房 LouFangBuilder.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 盖楼房</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LouFangBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> House house = <span class="keyword">new</span> House() ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFoundation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFoundation(<span class="string">"盖楼房的地基就打十米深"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setFrame(<span class="string">"楼房的框架要使用非常坚固钢筋混凝土"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpPouring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setPouring(<span class="string">"楼房拿个罐车把框架拿混凝土灌满即可"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">getHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指挥者「设计师」 HouseDirector.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 设计师</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指挥包工头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHouse</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        houseBuilder.doFoundation();</span><br><span class="line">        houseBuilder.doFrame();</span><br><span class="line">        houseBuilder.dpPouring();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试一下 Test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式一、客户自己盖房子，亲力亲为</span></span><br><span class="line">        System.out.println(<span class="string">"========客户自己建房子，必须知道盖房的细节========"</span>);</span><br><span class="line">        House house = <span class="keyword">new</span> House() ;</span><br><span class="line">        house.setFoundation(<span class="string">"用户自己建造房子：打地基"</span>);</span><br><span class="line">        house.setFrame(<span class="string">"用户自己建造房子：盖框架"</span>);</span><br><span class="line">        house.setPouring(<span class="string">"用户自己建造房子：浇筑"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(house.getFoundation());</span><br><span class="line">        System.out.println(house.getFrame());</span><br><span class="line">        System.out.println(house.getPouring());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二、客户找一个建造者盖房子「充当包工头角色」，但是要知道如何盖房子「调用建造者盖房子的顺序」</span></span><br><span class="line">        System.out.println(<span class="string">"========客户直接找盖房子的工人「建造者」，客户要调用建造者方法去盖房子，客户必须得知道房子如何造========"</span>);</span><br><span class="line"></span><br><span class="line">        HouseBuilder houseBuilder = <span class="keyword">new</span> PingFangBuilder() ;</span><br><span class="line">        houseBuilder.doFoundation();</span><br><span class="line">        houseBuilder.doFrame();</span><br><span class="line">        houseBuilder.dpPouring();</span><br><span class="line">        House house1 = houseBuilder.getHouse() ;</span><br><span class="line">        System.out.println(house1.getFoundation());</span><br><span class="line">        System.out.println(house1.getFrame());</span><br><span class="line">        System.out.println(house1.getPouring());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三、使用建造者模式，找一个设计师「设计师拉一帮建造者去干活」，告诉他我想要什么样的房子，最后客户只问设计师要房子即可</span></span><br><span class="line">        System.out.println(<span class="string">"========客户直接找一个设计师，设计师统一指挥建造者盖房子，房子杂盖，客户不关心，最后只是找设计师要房子即可========"</span>);</span><br><span class="line"></span><br><span class="line">        HouseBuilder pingFangBuilder = <span class="keyword">new</span> PingFangBuilder() ;</span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector() ;</span><br><span class="line">        houseDirector.buildHouse(pingFangBuilder);</span><br><span class="line">        House houseCreateByBuilder = pingFangBuilder.getHouse() ;</span><br><span class="line"></span><br><span class="line">        System.out.println(houseCreateByBuilder.getFoundation());</span><br><span class="line">        System.out.println(houseCreateByBuilder.getFrame());</span><br><span class="line">        System.out.println(houseCreateByBuilder.getPouring());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.替代多参数构造函数的建造者模式，以组装电脑为例</p>
</blockquote>
<p>前面我们说了<strong>在建造者模式中 Director 不是必须的</strong>，Director 的作用不是构造产品「建造产品是建造者的事情」而是指挥协调建造的步骤「当有一个新的建造者的时候直接实现抽象建造者，而不用关心具体的执行步骤，这就是 Director 干的事情」</p>
<ul>
<li>原始的 Computer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些可选配置</span></span><br><span class="line">    <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">    <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">    <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">    <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String graphicsCard,String mouse,String computerCase,String mousePad,String other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = mousePad ;</span><br><span class="line">        <span class="keyword">this</span>.other = other ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                    String graphicsCard,String mouse,String computerCase,String mousePad)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = mousePad ;</span><br><span class="line">    &#125;</span><br><span class="line">    ... 省略其它的构造方法和 setter 和 getter 方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要调用这个类就得在构参数方法中传递“无数个参数”「如果有的参是一些可选项，我们还得重写构造方法」，要么就要调用多个 setter 方法，才能给一个对象赋值，方法虽然可行，但是也太扯淡了「谁能记住那些参数呀」，那么建造者模式可以解决多参数构造方法来建造对象</p>
<ul>
<li>使用建造者建立 ComputerB.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TigerChain</span></span><br><span class="line"><span class="comment"> * 替代多参构造方法--建造者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">    <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些可选配置</span></span><br><span class="line">    <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">    <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">    <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">    <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ComputerB 自己充当 Director </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ComputerB</span><span class="params">(ComputerBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = builder.mainBoard ;</span><br><span class="line">        <span class="keyword">this</span>.cpu = builder.cpu ;</span><br><span class="line">        <span class="keyword">this</span>.hd = builder.hd ;</span><br><span class="line">        <span class="keyword">this</span>.powerSupplier = builder.powerSupplier ;</span><br><span class="line">        <span class="keyword">this</span>.graphicsCard = builder.graphicsCard ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mouse = builder.mouse ;</span><br><span class="line">        <span class="keyword">this</span>.computerCase = builder.computerCase ;</span><br><span class="line">        <span class="keyword">this</span>.mousePad = builder.mousePad ;</span><br><span class="line">        <span class="keyword">this</span>.other = builder.other ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 声明一个静态内存类 Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一个电脑的必须配置</span></span><br><span class="line">        <span class="keyword">private</span> String mainBoard ;     <span class="comment">// 主板</span></span><br><span class="line">        <span class="keyword">private</span> String cpu ;           <span class="comment">// cpu</span></span><br><span class="line">        <span class="keyword">private</span> String hd ;            <span class="comment">// 硬盘</span></span><br><span class="line">        <span class="keyword">private</span> String powerSupplier ; <span class="comment">// 电源</span></span><br><span class="line">        <span class="keyword">private</span> String graphicsCard;   <span class="comment">// 显卡</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其它一些可选配置</span></span><br><span class="line">        <span class="keyword">private</span> String mouse ; <span class="comment">// 鼠标</span></span><br><span class="line">        <span class="keyword">private</span> String computerCase ; <span class="comment">//机箱</span></span><br><span class="line">        <span class="keyword">private</span> String mousePad ;   <span class="comment">//鼠标垫</span></span><br><span class="line">        <span class="keyword">private</span> String other ;  <span class="comment">//其它配件</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里声明一些必须要传的参数「规定这些参数是必须传的，这里只是举例，再实中可能参数都是可选的」</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ComputerBuilder</span><span class="params">(String mainBoard,String cpu,String hd,String powerSupplier,String graphicsCard)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard ;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu ;</span><br><span class="line">            <span class="keyword">this</span>.hd = hd ;</span><br><span class="line">            <span class="keyword">this</span>.powerSupplier = powerSupplier ;</span><br><span class="line">            <span class="keyword">this</span>.graphicsCard = graphicsCard ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setMainBoard</span><span class="params">(String mainBoard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	... 其它的一些 setXXX() 方法</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 生成最终的产品</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerB <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComputerB(<span class="keyword">this</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码注释非常详细，乍一看好像和建造者模式没有毛关系，但是我们细细一分析这个确实是一个建造者模式，我们看一看：产品是–&gt;ComputerB,具体的建造者是一个静态内存类–&gt;ComputerBuilder,但是没有抽象的建造者和指挥者「其实 ComputerB 充当的就是指挥者的角色」，我们说过建造者模式中 <strong>指挥者</strong> 和 <strong>抽象建造者</strong> 都不是必须的，所以这是一个典型的建造者模式</p>
<ul>
<li>测试类 Test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用建造者模式</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(<span class="string">"主板"</span>,<span class="string">"cpu"</span>,<span class="string">"hd"</span>,<span class="string">"电源"</span>,<span class="string">"显卡"</span></span><br><span class="line">        ,<span class="string">"鼠标"</span>,<span class="string">"机箱"</span>,<span class="string">"鼠标垫"</span>) ;</span><br><span class="line">        System.out.println(<span class="string">"使用普通的构造方法组装电脑："</span>+computer.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用建造者模式</span></span><br><span class="line">        ComputerB computerB = <span class="keyword">new</span> ComputerB.ComputerBuilder(<span class="string">"主板"</span>,<span class="string">"cpu"</span>,<span class="string">"hd"</span>,<span class="string">"电源"</span>,<span class="string">"显卡"</span>)</span><br><span class="line">                .setMouse(<span class="string">"鼠标"</span>).setMousePad(<span class="string">"垫子"</span>).build() ;</span><br><span class="line">        System.out.println(<span class="string">"使用建造者模式组装电脑："</span>+computerB.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="三建造者模式的优缺点">三.建造者模式的优缺点</span></h2><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>1、使创建产品的步骤「把创建产品步骤放在不同的方法中，更加清晰直观」和产品本身分离，即使用相同的创建过程要吧创建出不同的产品</li>
<li>2、每个建造者都是独立的互不影响，这样就达到解耦的目的，所以如果想要替换现有的建造者那非常方便，添加一个实现即可。</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>1、只适用于产品具有相同的特点「过程和步骤」，如果产品之间差异非常大，则不适用「使用范围受限」</li>
<li>2、万一那天产品内部发生改变，那多个建造者都要修改，成本太大</li>
</ul>
<h2><span id="四建造者模式-vs-简单工厂模式">四.建造者模式 VS 简单工厂模式</span></h2><blockquote>
<p>相似点</p>
</blockquote>
<p>它们都属于创建型模式【都是创建产品的】</p>
<blockquote>
<p>区别</p>
</blockquote>
<ul>
<li>1、创建对象的粒度不同</li>
</ul>
<p>工厂模式创建的对象都是一个鸟样子，而建造者模式创建的是一个复合产品，由各个复杂的部件组成，部件不同所构成的产品也不同</p>
<ul>
<li>2、关注点不同：</li>
</ul>
<p>工厂模式注重只要把这个对象创建出来就 o 了「不关心这个产品的组成部分」，而建造者模式不似要创造出这个产品，还有知道这个产品的组成部分</p>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>
<p>JavaMail的<code>MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code>MimeMessage</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">textpart.setContent(body, <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> ByteArrayDataSource(input, <span class="string">"application/octet-stream"</span>)));</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br><span class="line"></span><br><span class="line">MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">"me@example.com"</span>));</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(<span class="string">"xiaoming@somewhere.com"</span>));</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.setSubject(<span class="string">"Hello"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.setContent(multipart);</span><br></pre></td></tr></table></figure>

<p>很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(secure ? <span class="string">"https://"</span> : <span class="string">"http://"</span>)</span><br><span class="line">       .append(<span class="string">"www.liaoxuefeng.com"</span>)</span><br><span class="line">       .append(<span class="string">"/"</span>)</span><br><span class="line">       .append(<span class="string">"?t=0"</span>);</span><br><span class="line">String url = builder.toString();</span><br></pre></td></tr></table></figure>

<p>由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = URLBuilder.builder() <span class="comment">// 创建Builder</span></span><br><span class="line">        .setDomain(<span class="string">"www.liaoxuefeng.com"</span>) <span class="comment">// 设置domain</span></span><br><span class="line">        .setScheme(<span class="string">"https"</span>) <span class="comment">// 设置scheme</span></span><br><span class="line">        .setPath(<span class="string">"/"</span>) <span class="comment">// 设置路径</span></span><br><span class="line">        .setQuery(Map.of(<span class="string">"a"</span>, <span class="string">"123"</span>, <span class="string">"q"</span>, <span class="string">"K&amp;R"</span>)) <span class="comment">// 设置query</span></span><br><span class="line">        .build(); <span class="comment">// 完成build</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常量池</title>
    <url>/2020/03/13/Java%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/1450501" target="_blank" rel="noopener">Java常量池</a></p>
<p><a href="https://blog.csdn.net/zm13007310400/article/details/77534349" target="_blank" rel="noopener">Java中的常量池(字符串常量池、class常量池和运行时常量池)</a></p>
<p><a href="https://www.jianshu.com/p/c7f47de2ee80" target="_blank" rel="noopener">Java常量池理解与总结</a></p>
<p>Java 中的常量池主要分为 <strong>Class文件常量池</strong>，<strong>运行时常量池</strong>，<strong>全局字符串常量池</strong></p>
<h1><span id="class-文件常量池">Class 文件常量池</span></h1><p>class 文件是一组以字节为单位的二进制数据流，在 java 在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 class文件中存在常量池（非运行时常量池），其在编译阶段就已经确定。</p>
<a id="more"></a>

<p>通过一个简单的例子说明情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0x101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> temp = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = temp + v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 javac 命令编译之后，用 javap -v 命令查看编译后的文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">developer</span>.<span class="title">es</span>.<span class="title">test</span>.<span class="title">demo</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#30         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #5.#31         // org/developer/es/test/demo.value:I</span><br><span class="line">   #3 = String             #32            // abc</span><br><span class="line">   #4 = Fieldref           #5.#33         // org/developer/es/test/demo.s:Ljava/lang/String;</span><br><span class="line">   #5 = Class              #34            // org/developer/es/test/demo</span><br><span class="line">   #6 = Class              #35            // java/lang/Object</span><br><span class="line">   #7 = Utf8               value</span><br><span class="line">   #8 = Utf8               I</span><br><span class="line">   #9 = Utf8               s</span><br><span class="line">  #10 = Utf8               Ljava/lang/String;</span><br><span class="line">  #11 = Utf8               f</span><br><span class="line">  #12 = Utf8               ConstantValue</span><br><span class="line">  #13 = Integer            257</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lorg/developer/es/test/demo;</span><br><span class="line">  #21 = Utf8               setValue</span><br><span class="line">  #22 = Utf8               (I)V</span><br><span class="line">  #23 = Utf8               v</span><br><span class="line">  #24 = Utf8               temp</span><br><span class="line">  #25 = Utf8               MethodParameters</span><br><span class="line">  #26 = Utf8               getValue</span><br><span class="line">  #27 = Utf8               ()I</span><br><span class="line">  #28 = Utf8               SourceFile</span><br><span class="line">  #29 = Utf8               demo.java</span><br><span class="line">  #30 = NameAndType        #14:#15        // "&lt;init&gt;":()V</span><br><span class="line">  #31 = NameAndType        #7:#8          // value:I</span><br><span class="line">  #32 = Utf8               abc</span><br><span class="line">  #33 = NameAndType        #9:#10         // s:Ljava/lang/String;</span><br><span class="line">  #34 = Utf8               org/developer/es/test/demo</span><br><span class="line">  #35 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>

<p>class 文件常量池主要存放两大常量：<strong>字面量和符号引用</strong></p>
<p>1) 字面量：字面量接近java语言层面的常量概念，主要包括：</p>
<ul>
<li><strong>文本字符串</strong>，也就是我们经常申明的： public String s = “abc”;中的”abc”</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#9 = Utf8               s</span><br><span class="line">#3 = String             #31            // abc</span><br><span class="line">#31 = Utf8              abc</span><br></pre></td></tr></table></figure>

<ul>
<li>用final修饰的成员变量，包括静态变量、实例变量和局部变量</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#11 = Utf8               f</span><br><span class="line"> #12 = Utf8               ConstantValue</span><br><span class="line"> #13 = Integer            257</span><br></pre></td></tr></table></figure>

<p>2) 符号引用 符号引用主要设涉及编译原理方面的概念，包括下面三类常量:</p>
<ul>
<li>类和接口的全限定名，也就是java/lang/String;这样，将类名中原来的”.”替换为”/“得到的，主要用于在运行时解析得到类的直接引用，像上面</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#5 = Class              #33            // JavaBasicKnowledge/JavaBean</span><br><span class="line"> #33 = Utf8               JavaBasicKnowledge/JavaBean</span><br></pre></td></tr></table></figure>

<ul>
<li>字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量和实例级的变量</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I</span><br><span class="line"> #5 = Class              #33            // JavaBasicKnowledge/JavaBean</span><br><span class="line"> #32 = NameAndType       #7:#8          // value:I</span><br><span class="line"></span><br><span class="line"> #7 = Utf8               value</span><br><span class="line"> #8 = Utf8               I</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这两个是局部变量，值保留字段名称</span></span><br><span class="line"> #23 = Utf8               v</span><br><span class="line"> #24 = Utf8               temp</span><br></pre></td></tr></table></figure>

<p>可以看到，对于方法中的局部变量名，class文件的常量池仅仅保存字段名。</p>
<ul>
<li>方法中的名称和描述符，也即参数类型+返回值</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#21 = Utf8               setValue</span><br><span class="line"> #22 = Utf8               (I)V</span><br><span class="line"></span><br><span class="line"> #25 = Utf8               getValue</span><br><span class="line"> #26 = Utf8               ()I</span><br></pre></td></tr></table></figure>

<p><strong><em>什么时字面量和符号引用</em></strong></p>
<ul>
<li>字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量</li>
<li>符号引用：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符</li>
</ul>
<h1><span id="运行时常量池">运行时常量池</span></h1><p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过<strong>加载、链接（验证、准备、解析）、初始化</strong>，在第一步加载的时候需要完成：</p>
<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class，它作为方法区这个类的各种数据访问的入口。</li>
</ul>
<p>类对象和普通对象是不同的，类对象是在类加载的时候完成的，是jvm创建的并且是单例的，作为这个类和外界交互的入口， 而普通的对象一般是在调用new之后创建。</p>
<p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下<strong>不同的类共用一个运行时常量池</strong>，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。</p>
<p>运行时常量池的作用是存储java class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p>
<p>运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。</p>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>常量池</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题汇总</title>
    <url>/2020/03/12/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1><span id="1如果一条sql执行时间过长如何优化">1.如果一条sql执行时间过长，如何优化…</span></h1><p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312230201.png" alt="img"></p>
<a id="more"></a>

<p>1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）</p>
<p>2、涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合</p>
<p>3、如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度</p>
<p>4、针对数量大的表进行历史表分离（如交易流水表）</p>
<p>5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</p>
<p>6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等</p>
<p>7、查看mysql执行日志，看看是否有其他方面的问题</p>
<h1><span id="2前端通过http请求后端的详细过程">2.前端通过http请求后端的详细过程</span></h1><p>参考：</p>
<p><a href="https://juejin.im/post/5c3b21e4e51d455231347349#heading-6" target="_blank" rel="noopener">浅析一次HTTP请求</a></p>
<p><a href="https://www.jianshu.com/p/c1d6a294d3c0" target="_blank" rel="noopener">一次完整的HTTP请求与响应涉及了哪些知识？真的讲得好很细</a></p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232201.png" alt="img"></p>
<ul>
<li>Http 请求是依托于 TCP/IP 连接的，第一次连接的时候会进行 TCP 的三次握手</li>
<li>HTTP 通过 Keep-Alive 来进行持久连接，通过定时发送一个心跳包，来告诉服务端自己还活跃</li>
<li>HTTP 连接的断开也会导致TCP的四次挥手，但是如果服务器判断满足条件，会合并 ACK 和 FIN 信号，进而转化为三次挥手。</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232501.png" alt="img"></p>
<p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）</p>
<p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。</p>
<p>通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/20200312232701.png" alt="img"></p>
<h2><span id="http协议">HTTP协议</span></h2><h3><span id="http是什么">Http是什么？</span></h3><p>通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p>
<p><strong>四个基于：</strong></p>
<p><strong>请求与响应：</strong>客户端发送请求，服务器端响应数据</p>
<p><strong>无状态的：</strong>协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</p>
<p><strong>应用层：</strong>Http是属于应用层的协议，配合TCP/IP使用。</p>
<p><strong>TCP/IP：</strong>Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</p>
<p><strong>针对无状态的一些解决策略：</strong></p>
<p>有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。</p>
<p>HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。<br> 等等还有很多。。。。。。</p>
<p>下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。</p>
<p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p>
<h2><span id="http请求报文">HTTP请求报文</span></h2><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/1.png" alt="img"></p>
<h3><span id="1请求行">1.请求行</span></h3><p>请求行分为三个部分：请求方法、请求地址和协议版本</p>
<p><strong>请求方法</strong></p>
<p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p>
<p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p>
<p><strong>请求地址</strong></p>
<p>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</p>
<p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</p>
<p><strong>端口和路径有时可以省略（HTTP默认端口号是80）</strong></p>
<p>如下例：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/2.png" alt="img"></p>
<p>有时会带参数，GET请求</p>
<p><strong>协议版本</strong></p>
<p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<h3><span id="2请求头部">2.请求头部</span></h3><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p>
<p>常见请求头如下：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/3.png" alt="img"></p>
<p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p>
<h3><span id="3请求数据">3.请求数据</span></h3><p>可选部分，比如GET请求就没有请求数据。</p>
<p>下面是一个POST方法的请求报文：</p>
<blockquote>
<p>POST 　/index.php　HTTP/1.1                                                                　　 请求行<br> Host: localhost<br> User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头<br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br> Accept-Language: zh-cn,zh;q=0.5<br> Accept-Encoding: gzip, deflate<br> Connection: keep-alive<br> Referer: <a href="https://link.jianshu.com?t=http://localhost/" target="_blank" rel="noopener">http://localhost/</a><br> Content-Length：25<br> Content-Type：application/x-www-form-urlencoded<br> 　空行<br> username=aa&amp;password=1234　　请求数据</p>
</blockquote>
<h2><span id="http响应报文">HTTP响应报文</span></h2><p><img src="http://q6s1x2hw2.bkt.clouddn.com/4.png" alt="img"></p>
<p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p>
<h3><span id="1状态行">1.状态行</span></h3><p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p>
<p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p>
<p><strong>状态码</strong></p>
<p>状态代码为3位数字。<br> 1xx：指示信息–表示请求已接收，继续处理。<br> 2xx：成功–表示请求已被成功接收、理解、接受。<br> 3xx：重定向–要完成请求必须进行更进一步的操作。<br> 4xx：客户端错误–请求有语法错误或请求无法实现。<br> 5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>下面列举几个常见的：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/5.png" alt="img"></p>
<h3><span id="2响应头部">2.响应头部</span></h3><p>与请求头部类似，为响应报文添加了一些附加信息</p>
<p>常见响应头部如下：</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/6.png" alt="img"></p>
<h3><span id="3响应数据">3.响应数据</span></h3><p>用于存放需要返回给客户端的数据信息。</p>
<p>下面是一个响应报文的实例：</p>
<blockquote>
<p>HTTP/1.1 200 OK　　状态行</p>
</blockquote>
<p>Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部<br> Server: Apache/2.2.8 (Win32) PHP/5.2.5<br> X-Powered-By: PHP/5.2.5<br> Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/<br> Expires: Thu, 19 Nov 1981 08:52:00 GMT<br> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br> Pragma: no-cache<br> Content-Length: 4393<br> Keep-Alive: timeout=5, max=100<br> Connection: Keep-Alive<br> Content-Type: text/html; charset=utf-8</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">空行</span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span>&gt;</span>　　响应数据</span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP响应示例<span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> Hello HTTP!</span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于请求头部和响应头部的知识点很多，这里只是简单介绍。</p>
<p>通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接</p>
<h1><span id="3递归算-n-的阶乘">3.递归算 n 的阶乘</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Sytem.out.print(rec(m) + <span class="string">" "</span>);</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">rec</span><span class="params">(Integer m)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        m = m * rec( m - <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="4list-和-set-的区别">4.List 和 Set 的区别</span></h1><p><strong><em>List</em></strong> 和 <strong><em>Set</em></strong> 都继承自 Collection，用来存放数据项集合</p>
<p>区别：</p>
<ol>
<li>List 和 Set 之间有个很重要的区别就是是否允许重复元素的存在，List 中允许插入重复元素，而 Set 不允许重复元素存在，List 中允许插入重复元素，而 Set 不允许重复元素存在</li>
<li>与元素先后存放顺序有关，List 是有序集合，保留元素插入顺序；Set 是无序集合</li>
<li>List 可通过下标访问，而 Set 不能</li>
</ol>
<h1><span id="5什么是-restful-api">5.什么是 RESTful API</span></h1><p>参考：</p>
<p><a href="https://www.jianshu.com/p/84568e364ee8" target="_blank" rel="noopener">深入理解什么是RESTful API ？</a></p>
<p>REST 全称是 Representational State Transfer (表现层状态转移)</p>
<p>微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。</p>
<p>RESTful 风格的一个最重要的规范就是：<strong><em>服务的无状态性</em></strong></p>
<ul>
<li><input checked disabled type="checkbox"> 服务端不保存任何客户端请求者信息</li>
<li><input checked disabled type="checkbox"> 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li>
</ul>
<blockquote>
<p>URL 定位资源，用 HTTP 动词 (GET,POST,DELETE,PUT) 描述操作</p>
</blockquote>
<ul>
<li><strong>Resource：</strong>资源，即数据。</li>
</ul>
<blockquote>
<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
</blockquote>
<blockquote>
<p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源标识符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
</blockquote>
<ul>
<li><strong>Representational：</strong>某种表现形式，比如用 JSON, XML, JPEG 等</li>
</ul>
<blockquote>
<p>资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p>
</blockquote>
<blockquote>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
</blockquote>
<blockquote>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
</blockquote>
<ul>
<li><strong>State Transfer：</strong>状态变化。通过 HTTP 动词实现</li>
</ul>
<blockquote>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
</blockquote>
<blockquote>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p>
</blockquote>
<blockquote>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>
</blockquote>
<h2><span id="无状态有哪些好处">无状态有哪些好处</span></h2><ul>
<li><input checked disabled type="checkbox"> 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li>
<li><input checked disabled type="checkbox"> 服务端的集群和状态对客户端透明</li>
<li><input checked disabled type="checkbox"> 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li>
<li><input checked disabled type="checkbox"> 减小服务端存储压力</li>
</ul>
<h2><span id="总结">总结：</span></h2><ul>
<li>每个 URI 代表一个资源</li>
<li>客户端和服务段之间，传递这种资源的某种<strong><em>表现层</em></strong></li>
<li>客户端通过4个HTTP动词，对服务端资源进行操作，实现”表现层状态转化”</li>
</ul>
<h2><span id="误区">误区</span></h2><blockquote>
<p><strong>最常见的一种设计错误，就是URI包含动词。</strong>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>
</blockquote>
<blockquote>
<p><strong>另一个设计误区，就是在URI中加入版本号</strong></p>
</blockquote>
<h1><span id="6接口和抽象类的区别">6.接口和抽象类的区别</span></h1><p><a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a></p>
<p><a href="https://www.nowcoder.com/questionTerminal/bdb310cc6e384e78b2564dfd3ba4197c" target="_blank" rel="noopener">抽象类</a></p>
<blockquote>
<p>从设计层面上来说，</p>
<p>抽象是对类的抽象，是一种模板设计；</p>
<p>接口是行为的抽象，是一种行为的规范；</p>
</blockquote>
<h2><span id="抽象类">抽象类</span></h2><p>抽象类和普通类的区别：</p>
<p>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
<p>抽象类不能创建对象</p>
<p>果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</p>
<h2><span id="接口">接口</span></h2><p>接口可以有 <strong><em>变量</em></strong> 和 <strong><em>方法</em></strong>。</p>
<p>变量 会被隐式指定为 public static final 并且只能是 public static final，<strong>用 private 修饰会报编译错误</strong></p>
<p>方法会被隐式地指定为public abstract方法且只能是public abstract方法<strong>，用其他关键字，比如private、protected、static、 final等修饰会报编译错误</strong></p>
<p>接口中不能含有 <strong>静态代码块和静态方法</strong></p>
<p><strong>jdk8 以后，接口也可以有方法体 ，</strong>用 <strong><em>default</em></strong> 修饰的方法体</p>
<h3><span id="区别">区别：</span></h3><blockquote>
<p>抽象类是对整个类整体进行抽象，包括属性、行为;</p>
<p>但是接口却是对类局部（行为）进行抽象。</p>
</blockquote>
<p>一个类只能继承一个抽象类，而一个类却可以实现多个接口</p>
<h1><span id="7final修饰符的理解">7.final修饰符的理解</span></h1><p>参考：</p>
<p><a href="http://www.51gjie.com/java/569.html" target="_blank" rel="noopener">Java final关键字</a></p>
<h2><span id="final修饰类">final修饰类</span></h2><p>final修饰类即表示此类已经是“最后的、最终的”含义。因此，用final修饰的类<strong>不能被继承</strong>，即<strong>不能拥有自己的子类</strong>。如果试图对一个已经用final修饰的类进行继承，在编译期间或发生错误。</p>
<h2><span id="final修饰方法">final修饰方法</span></h2><p>final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即<strong>此方法不能被重写</strong>（可以重载多个final修饰的方法）。</p>
<p>此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。</p>
<h2><span id="final修饰变量">final修饰变量</span></h2><p>final修饰的变量表示此变量是“最后的、最终的”含义。一旦定义了final变量并在首次为其显示初始化后，<strong>final修饰的变量值不可被改变</strong>(即不能再赋值)。</p>
<p>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</p>
<h1><span id="8java创建对象的方式">8.Java创建对象的方式</span></h1><ol>
<li><strong>使用 new 关键字</strong></li>
<li><strong>使用反射的 Class 类的 newInstance() 方法</strong>：ObjectName obj = ObjectName.class.newInstance(); </li>
<li><strong>使用反射的 Constructor 类的 newInstance() 方法</strong>：ObjectName obj = ObjectName.class.getConstructor.newInstance();</li>
<li><strong>使用对象的克隆 clone() 方法</strong>：ObjectName obj = obj.clone();</li>
<li><strong>使用反序列化（ObjectInputStream）的readObject()方法</strong>： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</li>
</ol>
<h1><span id="9重写和重载区别高频">9.重写和重载区别(高频)</span></h1><ul>
<li>重写</li>
</ul>
<blockquote>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变</p>
</blockquote>
<p><strong>外壳不变，核心重写</strong></p>
<ul>
<li>重载</li>
</ul>
<blockquote>
<p>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表</p>
</blockquote>
<h1><span id="10collection-和-collections的区别">10.collection 和 collections的区别</span></h1><ul>
<li>Collection</li>
</ul>
<blockquote>
<p>java.util.Collection 是一个 <strong>集合接口</strong>。它提供了对集合对象进行基本操作的通用接口方法</p>
</blockquote>
<ul>
<li>Collections</li>
</ul>
<blockquote>
<p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的<strong>静态多态方法</strong></p>
<p>此类 <strong>不能实例化</strong>，就像一个 <strong>工具类</strong>, 服务于 Java 的 Collection 类</p>
</blockquote>
<h1><span id="11thread的-join">11.Thread的 join()</span></h1><p>转载自：</p>
<p><a href="https://www.cnblogs.com/huangzejun/p/7908898.html" target="_blank" rel="noopener">Java 浅析 Thread.join()</a></p>
<blockquote>
<p>当一个线程必须等待另一个线程执行完毕才能执行时，Thread 类提供了 join 这个方法来完成这个功能</p>
</blockquote>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建child对象，此时child表示的线程处于NEW状态</span></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        <span class="comment">// child表示的线程转换为RUNNABLE状态</span></span><br><span class="line">        child.start();</span><br><span class="line">        <span class="comment">// 等待child线程运行完再继续运行</span></span><br><span class="line">        child.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码展示了两个类：Parent（父线程类），Child（子线程类）。</p>
<p>Parent.main()方法是程序的入口，通过 Child child = new Child(); 新建child子线程（此时 child子线程处于NEW状态）；</p>
<p>然后调用child.start()（child子线程状态转换为RUNNABLE）；</p>
<p>再调用child.join()，此时，Parent父线程会等待child子线程运行完再继续运行。</p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/33.png" alt="Java-thread-state-transition"></p>
<h1><span id="12mybatis-动态标签">12.mybatis 动态标签</span></h1><ul>
<li><strong>if</strong></li>
<li><strong>where</strong></li>
<li><strong>choose</strong></li>
<li><strong>when</strong></li>
<li><strong>otherwise</strong></li>
<li><strong>trim</strong></li>
<li><strong>set</strong></li>
<li><strong>foreach</strong></li>
</ul>
<h1><span id="13jdbc-控制事务">13.JDBC 控制事务</span></h1><p>参考：<a href="https://www.yiibai.com/jdbc/jdbc-transactions.html" target="_blank" rel="noopener">JDBC事务</a></p>
<p>事务能够控制何时更改提交并应用于数据库。它将单个 SQL 语句或一组 SQL 语句视为一个逻辑单元，如果任何语句失败，整个事务将失败。</p>
<p>要启用手动事务支持，而不是使用 JDBC 驱动程序默认使用的自动提交模式，请调用 <code>Connection</code> 对象的<code>setAutoCommit()</code>方法。 如果将布尔的<code>false</code>传递给<code>setAutoCommit()</code>，则关闭自动提交。 也可以传递一个布尔值<code>true</code>来重新打开它。</p>
<p>例如，如果有一个名为<code>conn</code>的<code>Connection</code>对象，请将以下代码关闭自动提交 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="提交和回滚">提交和回滚</span></h2><p>如果JDBC连接处于自动提交模式，默认情况下，则每个SQL语句在完成后都会提交到数据库。</p>
<p>对于简单的应用程序可能没有问题，但是有三个原因需要考虑是否关闭自动提交并管理自己的事务 -</p>
<ul>
<li>提高性能</li>
<li>保持业务流程的完整性</li>
<li>使用分布式事务</li>
</ul>
<p>事务能够控制何时更改提交并应用于数据库。 它将单个SQL语句或一组SQL语句视为一个逻辑单元，如果任何语句失败，整个事务将失败。</p>
<p>要启用手动事务支持，而不是使用JDBC驱动程序默认使用的自动提交模式，请调用<code>Connection</code>对象的<code>setAutoCommit()</code>方法。 如果将布尔的<code>false</code>传递给<code>setAutoCommit()</code>，则关闭自动提交。 也可以传递一个布尔值<code>true</code>来重新打开它。</p>
<p>例如，如果有一个名为<code>conn</code>的<code>Connection</code>对象，请将以下代码关闭自动提交 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>完成更改后，若要提交更改，那么可在连接对象上调用<code>commit()</code>方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.commit( );</span><br></pre></td></tr></table></figure>

<p>否则，要使用连接名为<code>conn</code>的数据库回滚更新，请使用以下代码 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.rollback( );</span><br></pre></td></tr></table></figure>

<p>以下示例说明了如何使用提交和回滚对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Assume a valid connection object conn</span></span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    String SQL = <span class="string">"INSERT INTO Employees  "</span> +</span><br><span class="line">        <span class="string">"VALUES (106, 20, 'Rita', 'Tez')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);  </span><br><span class="line">    <span class="comment">//Submit a malformed SQL statement that breaks</span></span><br><span class="line">    String SQL = <span class="string">"INSERTED IN Employees  "</span> +</span><br><span class="line">        <span class="string">"VALUES (107, 22, 'Sita', 'Singh')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);</span><br><span class="line">    <span class="comment">// If there is no error.</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">    <span class="comment">// If there is any error.</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，上述<code>INSERT</code>语句不会成功执行，因为所有操作都被回滚了。</p>
<h2><span id="使用保存点">使用保存点</span></h2><p>新的 JDBC3.0 新添加了 <code>Savepoint</code> 接口提供了额外的事务控制能力。大多数现代 DBMS 支持其环境中的保存点，如 Oracle 的 PL/SQL。</p>
<p>设置保存点(<code>Savepoint</code>)时，可以在事务中定义逻辑回滚点。 如果通过保存点(<code>Savepoint</code>)发生错误时，则可以使用回滚方法来撤消所有更改或仅保存保存点之后所做的更改。</p>
<p><strong>Connection</strong> 对象有两种新的方法可用来管理保存点</p>
<ul>
<li><strong>setSavepoint(String savepointName)：</strong>定义新的保存点，它还返回一个 <code>Savepoint</code> 对象</li>
<li><strong>releaseSavepoint(Savepoint savepointName)：</strong>删除保存点。要注意，他需要一个 <code>Savepoint</code>对象作为参数。 该对象通常是由<code>setSavepoint()</code>方法生成的保存点。</li>
</ul>
<p>有一个<em>rollback (String savepointName)</em>方法，它将使用事务回滚到指定的保存点。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Assume a valid connection object conn</span></span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set a Savepoint</span></span><br><span class="line">    Savepoint savepoint1 = conn.setSavepoint(<span class="string">"Savepoint1"</span>);</span><br><span class="line">    String SQL = <span class="string">"INSERT INTO Employees "</span> +</span><br><span class="line">        <span class="string">"VALUES (106, 24, 'Curry', 'Stephen')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);  </span><br><span class="line">    <span class="comment">//Submit a malformed SQL statement that breaks</span></span><br><span class="line">    String SQL = <span class="string">"INSERTED IN Employees "</span> +</span><br><span class="line">        <span class="string">"VALUES (107, 32, 'Kobe', 'Bryant')"</span>;</span><br><span class="line">    stmt.executeUpdate(SQL);</span><br><span class="line">    <span class="comment">// If there is no error, commit the changes.</span></span><br><span class="line">    conn.commit();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">    <span class="comment">// If there is any error.</span></span><br><span class="line">    conn.rollback(savepoint1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="14finalize">14.finalize()</span></h1><p><strong><em>finalize() 已经在 Java9 中不被推荐使用，明确在 Object.finalize() 标记为 deprecated</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment">     * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment">     * A subclass overrides the &#123;<span class="doctag">@code</span> finalize&#125; method to dispose of</span></span><br><span class="line"><span class="comment">     * system resources or to perform other cleanup.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of &#123;<span class="doctag">@code</span> finalize&#125; is that it is invoked</span></span><br><span class="line"><span class="comment">     * if and when the Java&amp;trade; virtual</span></span><br><span class="line"><span class="comment">     * machine has determined that there is no longer any</span></span><br><span class="line"><span class="comment">     * means by which this object can be accessed by any thread that has</span></span><br><span class="line"><span class="comment">     * not yet died, except as a result of an action taken by the</span></span><br><span class="line"><span class="comment">     * finalization of some other object or class which is ready to be</span></span><br><span class="line"><span class="comment">     * finalized. The &#123;<span class="doctag">@code</span> finalize&#125; method may take any action, including</span></span><br><span class="line"><span class="comment">     * making this object available again to other threads; the usual purpose</span></span><br><span class="line"><span class="comment">     * of &#123;<span class="doctag">@code</span> finalize&#125;, however, is to perform cleanup actions before</span></span><br><span class="line"><span class="comment">     * the object is irrevocably discarded. For example, the finalize method</span></span><br><span class="line"><span class="comment">     * for an object that represents an input/output connection might perform</span></span><br><span class="line"><span class="comment">     * explicit I/O transactions to break the connection before the object is</span></span><br><span class="line"><span class="comment">     * permanently discarded.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> finalize&#125; method of class &#123;<span class="doctag">@code</span> Object&#125; performs no</span></span><br><span class="line"><span class="comment">     * special action; it simply returns normally. Subclasses of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Object&#125; may override this definition.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The Java programming language does not guarantee which thread will</span></span><br><span class="line"><span class="comment">     * invoke the &#123;<span class="doctag">@code</span> finalize&#125; method for any given object. It is</span></span><br><span class="line"><span class="comment">     * guaranteed, however, that the thread that invokes finalize will not</span></span><br><span class="line"><span class="comment">     * be holding any user-visible synchronization locks when finalize is</span></span><br><span class="line"><span class="comment">     * invoked. If an uncaught exception is thrown by the finalize method,</span></span><br><span class="line"><span class="comment">     * the exception is ignored and finalization of that object terminates.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * After the &#123;<span class="doctag">@code</span> finalize&#125; method has been invoked for an object, no</span></span><br><span class="line"><span class="comment">     * further action is taken until the Java virtual machine has again</span></span><br><span class="line"><span class="comment">     * determined that there is no longer any means by which this object can</span></span><br><span class="line"><span class="comment">     * be accessed by any thread that has not yet died, including possible</span></span><br><span class="line"><span class="comment">     * actions by other objects or classes which are ready to be finalized,</span></span><br><span class="line"><span class="comment">     * at which point the object may be discarded.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> finalize&#125; method is never invoked more than once by a Java</span></span><br><span class="line"><span class="comment">     * virtual machine for any given object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Any exception thrown by the &#123;<span class="doctag">@code</span> finalize&#125; method causes</span></span><br><span class="line"><span class="comment">     * the finalization of this object to be halted, but is otherwise</span></span><br><span class="line"><span class="comment">     * ignored.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable the &#123;<span class="doctag">@code</span> Exception&#125; raised by this method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.ref.WeakReference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.ref.PhantomReference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 12.6 Finalization of Class Instances</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>由以下这段可知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.A subclass overrides the &#123;<span class="meta">@code</span> finalize&#125; method to dispose of system resources or to perform other cleanup.</span><br><span class="line">    </span><br><span class="line"><span class="comment">//当垃圾回收确定不再存在对对象的引用时，垃圾回收器对对象调用。子类重写&#123;@code finalize&#125;方法以释放系统资源或执行其他清理。</span></span><br></pre></td></tr></table></figure>

<p>该方法会被垃圾回收器处理没有任何引用指向的对象的时候所调用，并且该方法由子类去重写回收对象的实现</p>
<h1><span id="15crontab-命令">15.crontab 命令</span></h1><blockquote>
<p>Linux crontab 是用来定期执行程序的命令</p>
</blockquote>
<p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<h2><span id="命令格式">命令格式</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>

<ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示</li>
</ul>
<h1><span id="16sleep-和-wait-区别">16.sleep() 和 wait() 区别</span></h1><p>参考：</p>
<p><a href="https://www.cnblogs.com/diegodu/p/7866073.html" target="_blank" rel="noopener">JAVA线程sleep和wait方法区别</a></p>
<p><strong>sleep</strong> 是线程类 (<strong><em>Thread</em></strong>) 的方法，导致此线程暂停执行指定时间，给执行机会给其它线程，但是监控状态依然保持，到时后会自动恢复，<strong>调用 sleep 不会释放对象锁</strong>。由于没有释放对象锁，所以不能调用里面的同步方法</p>
<p><strong>wait</strong> 方法是 (<strong><em>Object</em></strong>) 类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；可以调用里面的同步方法，其他线程可以访问；wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。<br>wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</p>
<h1><span id="17类初始化顺序">17.类初始化顺序</span></h1><p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C118.png" alt="118.png"></p>
<p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C138.png" alt="138.png"></p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已HotSpot为基准。</p>
<h2><span id="加载">加载</span></h2><p>在加载阶段(可以参考 java.lang.class.ClassLoader 的 loadClass() 方法),虚拟机需要完成以下3件事情:</p>
<ul>
<li><input checked disabled type="checkbox"> <strong><em>通过一个类的全限定名来获取定义此类的二进制字节流</em></strong>（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）</li>
<li><input checked disabled type="checkbox"> 将这个字节流所代表的静态存储结构转化未方法区的运行时数据结构</li>
<li><input checked disabled type="checkbox"> 在内存中生成一个代表这个类的 java.lang.Class 对象,作为方法区这个类各种数据访问入口</li>
</ul>
<p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h2><span id="验证">验证</span></h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li><u>文件格式验证</u>：验证字节流是否符合 Class 文件格式的规范；例如：是否以魔数 <strong>0xCAFEBABE</strong> 开头，主次版本号是否在当前虚拟机的处理范围之内，常量池中的常量是否有不被支持的类型</li>
<li><u>元数据验证</u>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li>
<li><u>字节码验证</u>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><u>号引用验证</u>：确保解析动作能正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2><span id="准备">准备</span></h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。<br>至于“特殊情况”是指：<code>public static final int value=123</code>，即当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为 123 而非 0.</p>
<h2><span id="解析">解析</span></h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号引用进行</p>
<h2><span id="初始化">初始化</span></h2><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的 java 程序代码。在准备阶段，变量已经赋值归一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序指定的计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器&lt;clinit&gt;() 方法的过程。</p>
<p><strong>&lt;clinit&gt;()</strong> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 static{} 中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</p>
<h2><span id="例题">例题</span></h2><h3><span id="1">1.</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    C() &#123;</span><br><span class="line">        System.out.print(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"A"</span>);</span><br><span class="line">        System.out.print(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(String s) &#123;</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    Test() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"B"</span>);</span><br><span class="line">        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化过程是这样的：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化</span><br><span class="line"><span class="number">2.</span> 然后，初始化子类的静态成员变量和静态代码块，按照在程序中出现的顺序初始化</span><br><span class="line"><span class="number">3.</span> 其次，初始化父类的普通成员变量和代码块，再执行父类的构造方法</span><br><span class="line"><span class="number">4.</span> 最后，初始化子类的普通成员变量和代码块，再执行子类的构造方法</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<ol>
<li>初始化父类的普通成员变量和代码块，执行 C c = new C(); 输出 C</li>
<li>super(“B”)，表示调用父类的构造方法，不调用父类的无参构造函数，输出 B</li>
<li>System.out.print(“B”)</li>
</ol>
<h3><span id="2">2.</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baseName = <span class="string">"base"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System. out. println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String baseName = <span class="string">"sub"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System. out. println (baseName) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base b = <span class="keyword">new</span> Sub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>new Sub(); 在创造派生类的过程中首先创建基类对象，然后才能创建派生类。</p>
<p>创建基类即默认调用 Base() 方法，在方法中调用 callName() 方法，由于派生类中存在此方法，则被调用的 callName() 方法是派生类中的方法，此时派生类还未构造，所以变量 baseName 的值为 null</p>
<h1><span id="18多态问题">18.多态问题</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Wangyi;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SonB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Son();</span><br><span class="line">        base.method();</span><br><span class="line">        base.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问这个程序的输出结果。<strong>编译不通过</strong></p>
<p>解析：</p>
<p>这句new 了一个派生类，赋值给基类，所以下面的操作编译器认为base对象就是Base类型的。Base类中不存在methodB()方法，所以编译不通过。</p>
<p>这类多态问题中，无论向上或向下转型，都记住一句话就可以了。</p>
<p><strong>编译看左边，运行看右边。</strong>意思编译时候，看左边有没有该方法，运行的时候结果看 <strong>new</strong> 的对象是谁，就调用的谁。</p>
<h1><span id="19如何保证缓存与数据库双写一致性">19.如何保证缓存与数据库双写一致性？</span></h1><p>转载自：<a href="https://mp.weixin.qq.com/s/kTtL74zfoK43GRQkhFVAmQ" target="_blank" rel="noopener">高频面试题：如何保证缓存与数据库的双写一致性？</a></p>
<p>分布式缓存是现在很多分布式应用中必不可少的组件，但是用到了分布式缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性的问题，那么该如何解决一致性问题？</p>
<h2><span id="cache-aside-pattern">Cache Aside Pattern</span></h2><p>最经典的缓存+数据库读写模式，就是 <strong><em>Cache Aside Pattern</em></strong>。</p>
<p><strong>读</strong> 的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</p>
<p><strong>更新</strong> 的时候，先更新数据库，然后再删除缓存。</p>
<h3><span id="为什么是删除缓存而不是更新缓存">为什么是删除缓存，而不是更新缓存？</span></h3><p>原因很简单，很多时候，在复杂的缓存场景，缓存不单单是数据库中直接取出来的值。</p>
<p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行计算，才能计算出缓存最新的值的。</p>
<p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？</p>
<p>也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。</p>
<p>如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？</p>
<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。</p>
<p>实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低，用到缓存才去算缓存。</p>
<p>其实删除缓存，而不是更新缓存，就是一个 <strong><em>lazy(懒加载)</em></strong> 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p>
<p>像 mybatis，hibernate，都有<u>懒加载</u>思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来。</p>
<p>80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p>
<h2><span id="最初级的缓存不一致问题及解决方案">最初级的缓存不一致问题及解决方案</span></h2><p><strong>问题：</strong>先修改数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfeoyd3H8CCETFgcdAU1AWvN9Zoz5cFzMJEfD36zwfXteNoC1CYC68bFicI1RpwcwicmjAl9GwgLLuWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><strong>解决思路：</strong>先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p>
<h1><span id="20restcontroller-vs-controller">20.@RestController vs @Controller</span></h1><p>参考：</p>
<p><a href="https://github.com/Snailclimb/springboot-guide/blob/master/docs/basis/RestControllerVSController.md" target="_blank" rel="noopener">https://github.com/Snailclimb/springboot-guide/blob/master/docs/basis/RestControllerVSController.md</a></p>
<p><strong><em>@Controller 返回一个页面</em></strong></p>
<p>单独是用 <code>@Controller</code> 不加 <code>@ResponseBody</code> 的话一般使用在要返回一个视图的情况，这种情况属于比较传统的 SpringMVC 的应用，对应于前后端不分离的情况</p>
<p><strong><em>@RestController 返回 JSON 或 XML 形式数据</em></strong></p>
<p>但<code>@RestController</code>只返回对象，对象数据直接以 <strong>JSON</strong> 或 <strong>XML</strong> 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<h1><span id="21通过sql删除重复的数据货拉拉">21.通过sql删除重复的数据(货拉拉)</span></h1><p><a href="https://blog.csdn.net/anya/article/details/6407280" target="_blank" rel="noopener">https://blog.csdn.net/anya/article/details/6407280</a></p>
<p>查出多于1条的重复数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> T <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">id</span>)&gt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>删除表中多余的重复记录，重复记录是根据单个字段(id) 来判断的，只保留有 rowid 最小的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> T <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">name</span>) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">id</span>) <span class="keyword">from</span> T <span class="keyword">group</span> <span class="keyword">name</span> <span class="keyword">having</span>(<span class="keyword">name</span>) &gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>查找表中多余的重复记录(多个字段)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T</span><br><span class="line"><span class="keyword">where</span> (T.a,T.b) <span class="keyword">in</span> (<span class="keyword">select</span> a,b <span class="keyword">from</span> T <span class="keyword">group</span> <span class="keyword">by</span> a,b <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>删除表中多余的重复记录（多个字段），只留有rowid最小的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> T</span><br><span class="line"><span class="keyword">where</span> (T.a,T.b) <span class="keyword">in</span> (<span class="keyword">select</span> a,b <span class="keyword">from</span> T <span class="keyword">group</span> <span class="keyword">by</span> a,b <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">rowid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">rowid</span>) <span class="keyword">from</span> T <span class="keyword">group</span> <span class="keyword">by</span> a,b <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1><span id="22http响应结构货拉拉">22.Http响应结构(货拉拉)</span></h1><p><a href="https://www.runoob.com/http/http-messages.html" target="_blank" rel="noopener">https://www.runoob.com/http/http-messages.html</a></p>
<p><a href="https://www.nowcoder.com/questionTerminal/5459a06bdccd421cb9f8afe7a9662e15" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/5459a06bdccd421cb9f8afe7a9662e15</a></p>
<p><a href="https://www.cnblogs.com/yonyong/p/9229297.html" target="_blank" rel="noopener">https://www.cnblogs.com/yonyong/p/9229297.html</a></p>
<p>HTTP响应也由四个部分组成，分别是：<strong>状态行</strong>、<strong>消息报头</strong>、<strong>空行</strong>和<strong>响应正文</strong>。</p>
<h1><span id="23克隆对象的方法">23.克隆对象的方法</span></h1>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂模式</title>
    <url>/2020/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1><span id="工厂模式">工厂模式</span></h1><p>参考：<a href="https://juejin.im/entry/58f5e080b123db2fa2b3c4c6" target="_blank" rel="noopener">工厂模式</a></p>
<p>工厂模式分为三种：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<blockquote>
<p>设计模式只是思想，没有固定的代码</p>
</blockquote>
<a id="more"></a>

<h2><span id="简单工厂模式">简单工厂模式</span></h2><p>简单工厂模式其实并不是一种设计模式，更多的是一种编程习惯</p>
<blockquote>
<p>定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或者接口</p>
</blockquote>
<p><strong>适用场景</strong></p>
<p>其实由定义也大概能推测出其使用场景，首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。</p>
<h3><span id="实例">实例</span></h3><p>shape.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圆形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"CircleShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"draw: CircleShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正方形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RectShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(  <span class="string">"RectShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(  <span class="string">"draw: RectShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriangleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"TriangleShape: created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(  <span class="string">"draw: TriangleShape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是工厂类的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ShapeFactory"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Shape shape = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"circle"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> CircleShape();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"rect"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> RectShape();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"triangle"</span>)) &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> TriangleShape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在这个工厂类中通过传入不同的type可以new不同的形状，<strong>返回结果为Shape 类型</strong>，这个就是简单工厂核心的地方了。</p>
<p>客户端调用</p>
<p>画圆形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"circle"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>

<p>画正方形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"rect"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>

<p>画三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape shape= ShapeFactory.getShape(<span class="string">"triangle"</span>);</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>

<h2><span id="工厂方法模式">工厂方法模式</span></h2><p>工厂方法模式是简单工厂的进一步深化，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说<strong>每个对象都有一个与之对应的工厂</strong>。</p>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
</blockquote>
<h3><span id="实例">实例</span></h3><p>现在需要设计一个这样的图片加载类，它具有多个图片加载器，用来加载jpg，png，gif格式的图片，每个加载器都有一个 read() 方法，用于读取图片。下面我们完成这个图片加载类。</p>
<p>首先完成图片加载器的设计，编写一个加载器的公共接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reader 里面只有一个read（）方法，然后完成各个图片加载器的代码。</p>
<p>Jpg图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read jpg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Png图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PngReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read png"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gif图片加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GifReader</span> <span class="keyword">implements</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"read gif"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们按照定义所说定义一个抽象的工厂接口ReaderFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Reader <span class="title">getReader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面有一个getReader（）方法返回我们的Reader 类，接下来我们把上面定义好的每个图片加载器都提供一个工厂类，这些工厂类实现了ReaderFactory 。</p>
<p>Jpg加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpgReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Png加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PngReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PngReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gif加载器工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GifReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GifReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个工厂类中我们都通过复写的getReader（）方法返回各自的图片加载器对象。</p>
<p>客户端使用</p>
<p>读取Jpg</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> JpgReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>

<p>读取Png</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> PngReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>

<p>读取Gif</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReaderFactory factory=<span class="keyword">new</span> GifReaderFactory();</span><br><span class="line">Reader  reader=factory.getReader();</span><br><span class="line">reader.read();</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<p>（1）客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了创建过程。<br>（2）客户端可以通过子类来指定创建对应的对象。</p>
<h2><span id="抽象工厂模式">抽象工厂模式</span></h2><p>抽象工厂模式是一个比较复杂的创建型模式</p>
<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应多个实际工厂，每个实际工厂负责创建多个实际产品。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                ┌────────┐</span><br><span class="line">                             ─ &gt;│ProductA│</span><br><span class="line">┌────────┐    ┌─────────┐   │   └────────┘</span><br><span class="line">│ Client │─ ─&gt;│ Factory │─ ─</span><br><span class="line">└────────┘    └─────────┘   │   ┌────────┐</span><br><span class="line">                   ▲         ─ &gt;│ProductB│</span><br><span class="line">           ┌───────┴───────┐    └────────┘</span><br><span class="line">           │               │</span><br><span class="line">      ┌─────────┐     ┌─────────┐</span><br><span class="line">      │Factory1 │     │Factory2 │</span><br><span class="line">      └─────────┘     └─────────┘</span><br><span class="line">           │   ┌─────────┐ │   ┌─────────┐</span><br><span class="line">            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│</span><br><span class="line">           │   └─────────┘ │   └─────────┘</span><br><span class="line">               ┌─────────┐     ┌─────────┐</span><br><span class="line">           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│</span><br><span class="line">               └─────────┘     └─────────┘</span><br></pre></td></tr></table></figure>

<p>为形状创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实现接口的实体类。</p>
<p><em>Rectangle.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为颜色创建一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Red::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Green::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Blue::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"RED"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"GREEN"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"BLUE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"COLOR"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状工厂</span></span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色工厂</span></span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      Color color1 = colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      Color color2 = colorFactory.getColor(<span class="string">"Green"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">      Color color3 = colorFactory.getColor(<span class="string">"BLUE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合AOP记录接口访问日志</title>
    <url>/2020/03/12/SpringBoot%E6%95%B4%E5%90%88AOP%E8%AE%B0%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/technology/aop_log" target="_blank" rel="noopener">SpringBoot整合AOP</a></p>
<h1><span id="aop">AOP</span></h1><blockquote>
<p>AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程，通过 <strong>预编译</strong> 方式和 <strong>运行期动态代理</strong> 实现程序功能的统一维护的一种技术。利用 AOP 可以对业务逻辑的个部分进行隔离，从而从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
</blockquote>
<a id="more"></a>

<h2><span id="aop的相关术语">AOP的相关术语</span></h2><h3><span id="通知advice">通知(Advice)</span></h3><p>通知描述了切面要完成的工作以及何时执行。比如我们的日志切面需要记录每个接口调用时长，就需要在接口调用前后分别记录当前时间，再取差值。</p>
<ul>
<li>前置通知（Before）：在目标方法调用前调用通知功能；</li>
<li>后置通知（After）：在目标方法调用之后调用通知功能，不关心方法的返回结果；</li>
<li>返回通知（AfterReturning）：在目标方法成功执行之后调用通知功能；</li>
<li>异常通知（AfterThrowing）：在目标方法抛出异常后调用通知功能；</li>
<li>环绕通知（Around）：通知包裹了目标方法，在目标方法调用之前和之后执行自定义的行为。</li>
</ul>
<h3><span id="连接点joinpoint">连接点(JoinPoint)</span></h3><p>通知功能被应用的时机，比如接口方法被调用的时候就是日志切面的连接点</p>
<h3><span id="切点pointcut">切点(Pointcut)</span></h3><p>切点定义了通知功能被应用的范围。比如日志切面的应用范围就是所有接口，即所有controller层的接口方法。</p>
<h3><span id="切面aspect">切面(Aspect)</span></h3><p>切面是通知和切点的结合，定义了何时，何地应用通知功能</p>
<h3><span id="引入introduction">引入(Introduction)</span></h3><p>在无需修改现有类的情况下，向现有的类添加新方法或属性。</p>
<h3><span id="织入weaving">织入(Weaving)</span></h3><p>把切面应用到目标对象并创建新的代理对象的过程。</p>
<h2><span id="spring中使用注解创建切面">Spring中使用注解创建切面</span></h2><h3><span id="相关注解"></span></h3><ul>
<li>@Aspect：用于定义切面</li>
<li>@Before：通知方法会在目标方法调用之前执行</li>
<li>@After：通知方法会在目标方法返回或抛出异常后执行</li>
<li>@AfterReturning：通知方法会在目标方法返回后执行</li>
<li>@AfterThrowing：通知方法会在目标方法抛出异常后执行</li>
<li>@Around：通知方法会将目标方法封装起来</li>
<li>@Pointcut：定义切点表达式</li>
</ul>
<h3><span id="切点表达式"></span></h3><p>指定了通知被应用的范围，表达式格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(方法修饰符 返回类型 方法所属的包.类名.方法名称(方法参数)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.macro.mall.tiny.controller包中所有类的public方法都应用切面里的通知</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.macro.mall.tiny.controller.*.*(..))</span><br><span class="line"><span class="comment">//com.macro.mall.tiny.service包及其子包下所有类中的所有方法都应用切面里的通知</span></span><br><span class="line">execution(* com.macro.mall.tiny.service..*.*(..))</span><br><span class="line"><span class="comment">//com.macro.mall.tiny.service.PmsBrandService类中的所有方法都应用切面里的通知</span></span><br><span class="line">execution(* com.macro.mall.tiny.service.PmsBrandService.*(..))</span><br></pre></td></tr></table></figure>

<h2><span id="实例">实例</span></h2><p>添加日志信息封装类 WebLog</p>
<blockquote>
<p>用于封装需要记录的日志信息，包括操作的描述、时间、消耗时间、url、请求参数和返回结果等信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.dto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller层的日志封装类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLog</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消耗时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer spendTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IP地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求返回的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了getter,setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加切面类 WebLogAspect</p>
<blockquote>
<p>定义了一个日志切面，在环绕通知中获取日志需要的信息，并应用到controller层中所有的public方法中去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 统一日志处理切面</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/12 17:22</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WebLogAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * org.developer.es.api.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"webLog()"</span>, returning = <span class="string">"ret"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知=前置 + 目标方法执行 + 后置通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取当前请求对象</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        <span class="comment">//记录请求信息</span></span><br><span class="line">        WebLog webLog = <span class="keyword">new</span> WebLog();</span><br><span class="line">        <span class="comment">//proceed 方法就是用于启动目标方法执行</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="comment">//获取被调用的签名</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="comment">//转换为方法签名</span></span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        <span class="comment">//获取 controller 的方法</span></span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        <span class="comment">//如果存在 ApiOperation 注解，获取描述的值</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(ApiOperation<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">            ApiOperation apiOperation = method.getAnnotation(ApiOperation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            webLog.setDescription(apiOperation.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        String urlStr = request.getRequestURL().toString();</span><br><span class="line">        webLog.setBasePath(StrUtil.removeSuffix(urlStr, URLUtil.url(urlStr).getPath()));</span><br><span class="line">        webLog.setIp(request.getRemoteUser());</span><br><span class="line">        webLog.setMethod(request.getMethod());</span><br><span class="line">        webLog.setParameter(getParameter(method, joinPoint.getArgs()));</span><br><span class="line">        webLog.setResult(result);</span><br><span class="line">        webLog.setSpendTime((<span class="keyword">int</span>) (endTime - startTime));</span><br><span class="line">        webLog.setStartTime(startTime);</span><br><span class="line">        webLog.setUri(request.getRequestURI());</span><br><span class="line">        webLog.setUrl(request.getRequestURL().toString());</span><br><span class="line">        logger.info(<span class="string">"&#123;&#125; \n"</span>, JSONUtil.parse(webLog));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据方法和传入的参数获取请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getParameter</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; argList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取方法的参数</span></span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将 RequestBody 注解修饰的参数作为请求参数</span></span><br><span class="line">            RequestBody requestBody = parameters[i].getAnnotation(RequestBody<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(requestBody != <span class="keyword">null</span>)&#123;</span><br><span class="line">                argList.add(args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 RequestParam 注解修饰的参数作为请求参数</span></span><br><span class="line">            RequestParam requestParam = parameters[i].getAnnotation(RequestParam<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (requestParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                String key = parameters[i].getName();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(requestParam.value())) &#123;</span><br><span class="line">                    key = requestParam.value();</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(key, args[i]);</span><br><span class="line">                argList.add(map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> argList.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> argList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200313101900106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313101627277"></p>
<p><img src="https://img-blog.csdnimg.cn/2020031310191371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313101704157"></p>
<p>当执行遇到错误的时候，就会有以下信息</p>
<p><img src="https://img-blog.csdnimg.cn/20200313102657103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="image-20200313102544808"></p>
<h2><span id="拓展">拓展</span></h2><p><strong>SpringBoot 官方建议使用 logback-spring.xml</strong></p>
<p>logback.xml：应用启动时会直接被日志框架 logback 识别而被使用，不经过 SpringBoot</p>
<p>logback-spring.xml：logback日志框架就不能直接识别到，而会由 Spring Boot 解析此日志配置文件</p>
<h3><span id="springboot-加载-logback-springxml">SpringBoot 加载 logback-spring.xml</span></h3><p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/27874182" target="_blank" rel="noopener">Spring Boot中logback配置文件加载过程</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.logging.logback.LogbackLoggingSystem</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getStandardConfigLocations() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"logback-test.groovy"</span>, <span class="string">"logback-test.xml"</span>, <span class="string">"logback.groovy"</span>,</span><br><span class="line">                         <span class="string">"logback.xml"</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这里可以看到spring boot中支持的logback配置文件格式，就是在logback自配置文件（logback-test.xml, logback.xml等）基础上文件名后面加了“-spring”，如logback-test-spring, logback-spring等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the spring config locations for this system. By default this method returns</span></span><br><span class="line"><span class="comment"> * a set of locations based on &#123;<span class="doctag">@link</span> #getStandardConfigLocations()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the spring config locations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getSpringInitializationConfig()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String[] getSpringConfigLocations() &#123;</span><br><span class="line">    String[] locations = getStandardConfigLocations();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">        String extension = StringUtils.getFilenameExtension(locations[i]);</span><br><span class="line">        locations[i] = locations[i].substring(<span class="number">0</span>,</span><br><span class="line">                                              locations[i].length() - extension.length() - <span class="number">1</span>) + <span class="string">"-spring."</span></span><br><span class="line">            + extension;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> locations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>重点关注org.springframework.boot.logging.logback.LogbackLoggingSystem</em></strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020Java技术栈</title>
    <url>/2020/03/12/2020Java%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<p>回想飞逝而去的2019，在学生和职场人身份之间的转换，一切匆匆。好像自己的技术栈也没有提升和丰富多少，最近也不断在思考，到底哪里出了问题…..</p>
<p>所以先暂时参考下尚硅谷的2020的学习路线吧！</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200330132139667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="123.png"></p>
<p>大数据的路线</p>
<p><img src="https://img-blog.csdnimg.cn/20200330132238152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70#pic_center" alt="124.png"></p>
<p>目前就暂时以这个标准作为学习的方向吧！奥利给，加油！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像加速地址</title>
    <url>/2020/03/11/Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>由于最近想入门 ELK 框架，所以找到一篇<a href="[http://www.macrozheng.com/#/technology/mall_tiny_elk?id=%e5%88%9b%e5%bb%ba%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%ad%98%e6%94%be%e7%9b%ae%e5%bd%95%e5%b9%b6%e4%b8%8a%e4%bc%a0%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%88%b0%e8%af%a5%e7%9b%ae%e5%bd%95](http://www.macrozheng.com/#/technology/mall_tiny_elk?id=创建配置文件存放目录并上传配置文件到该目录)">大神的文章</a>来练练手。</p>
<p>可是 Docker 的 pull 镜像的速度差点让我吐血了 orz；</p>
<p>后面通过神奇的谷歌搜索，找到了<a href="http://einverne.github.io/post/2018/03/docker-mirror.html" target="_blank" rel="noopener">一篇很不错的文章</a></p>
<a id="more"></a>

<blockquote>
<h2><span id="使用-registry-mirrors">使用 registry mirrors</span></h2></blockquote>
<p>手动修改 Docker 配置 <code>/etc/docker/daemon.json</code> 文件增加 docker registry 镜像：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"加速地址"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"insecure-registries"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改其中的 <code>加速地址</code>，不同的服务提供的镜像加速地址不一样。</p>
<p>记得修改配置之后 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p> 重启 docker。下面就总结一下国内的 Docker 镜像站点。</p>
<p>修改后使用 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>

<p> 来检查配置是否生效。</p>
<p>如果下方公开的镜像速度不佳的话，尝试阿里云的镜像，需要开发者账号。</p>
<h3><span id="docker-cn">Docker cn</span></h3><p>Docker 官方提供的镜像：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>

<h3><span id="azure">Azure</span></h3><p>Azure <a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">中国镜像</a> 包括 Docker Hub、GCR、Quay。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//dockerhub.azk8s.cn</span></span><br></pre></td></tr></table></figure>

<h3><span id="网易亲测真的非常有效">网易(亲测真的非常有效)</span></h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//hub-mirror.c.163.com</span></span><br></pre></td></tr></table></figure>

<h3><span id="腾讯">腾讯</span></h3><p>腾讯只能在腾讯云上使用：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//mirror.ccs.tencentyun.com</span></span><br></pre></td></tr></table></figure>

<h3><span id="科大镜像-ustc">科大镜像 ustc</span></h3><p><a href="https://mirrors.ustc.edu.cn/help/dockerhub.html" target="_blank" rel="noopener">科大</a> 包括 Docker Hub、GCR、Quay。<a href="http://einverne.github.io/post/2018/03/docker-mirror.html#fn:ustc" target="_blank" rel="noopener">1</a></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//docker.mirrors.ustc.edu.cn</span></span><br></pre></td></tr></table></figure>

<h3><span id="七牛">七牛</span></h3><p><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//<span class="keyword">reg</span>-mirror.qiniu.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>

<h3><span id="daocloud">DaoCloud</span></h3><p>DaoCloud <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">提供</a> 的加速地址：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//6ce28dce.m.daocloud.io</span></span><br></pre></td></tr></table></figure>

<p>这个地址不同用户看起开不一样，可以使用我的，也可以自己注册。</p>
<p>这个地址不知道是不是长久地址，不过失效，可以到他的官方<a href="http://6ce28dce.m.daocloud.io/" target="_blank" rel="noopener">网站</a> 查看。</p>
<h3><span id="docker-cn">Docker cn</span></h3><p>也可以使用 Docker 官方提供的镜像</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>

<p>官网<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">地址</a></p>
<h3><span id="个人维护的镜像">个人维护的镜像</span></h3><p><a href="https://mritd.me/2017/03/21/private-maintenance-docker-mirror-registry/" target="_blank" rel="noopener">mritd</a> 反向代理了主流的三大仓库（Docker Hub，gcr.io，quay.io）。</p>
<h2><span id="docker-registries">docker registries</span></h2><p>不得不说的 hub.docker.com，官方提供</p>
<h3><span id="daocloud-hub">daocloud hub</span></h3><p>这是国内 DaoCloud 公司提供的</p>
<ul>
<li><a href="https://hub.daocloud.io/" target="_blank" rel="noopener">https://hub.daocloud.io/</a></li>
</ul>
<h3><span id="gcrio">gcr.io</span></h3><p>可以通过下面的链接查看 gcr.io 中存在镜像，类似于直接在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 中搜索查看。</p>
<ul>
<li><a href="https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers" target="_blank" rel="noopener">https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers</a></li>
</ul>
<h3><span id="阿里云">阿里云</span></h3><p>这里是阿里云提供的镜像托管服务</p>
<ul>
<li><a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></li>
</ul>
<p>然后<a href="http://dockone.io/question/1216" target="_blank" rel="noopener">有人</a> 把 <code>gcr.io/google-containers</code> 下所有的 Docker 镜像都同步到了中央库</p>
<ul>
<li><a href="https://hub.docker.com/u/googlecontainer/" target="_blank" rel="noopener">https://hub.docker.com/u/googlecontainer/</a></li>
</ul>
<p>更多的 registry 可以参考<a href="https://github.com/veggiemonk/awesome-docker#registry" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Velocity总结</title>
    <url>/2020/03/11/Velocity%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1><span id="入门示例">入门示例</span></h1><p>参考：<a href="https://blog.csdn.net/fyyyr/article/details/84839595" target="_blank" rel="noopener">https://blog.csdn.net/fyyyr/article/details/84839595</a></p>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--velocity模板引擎依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写一个模板代码</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package $&#123;package&#125;.controller</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class $&#123;className&#125;Controller&#123;</span><br><span class="line"></span><br><span class="line">    public void get$&#123;Object&#125;()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set$&#123;Object&#125;()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VelocityEngine ve = <span class="keyword">new</span> VelocityEngine();</span><br><span class="line"><span class="comment">//设置资源路径</span></span><br><span class="line">ve.setProperty(RuntimeConstants.RESOURCE_LOADER,<span class="string">"classpath"</span>);</span><br><span class="line">ve.setProperty(<span class="string">"classpath.resource.loader.class"</span>, ClasspathResourceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">ve.init();</span><br><span class="line"></span><br><span class="line"><span class="comment">//载入模板</span></span><br><span class="line">Template t = ve.getTemplate(<span class="string">"templates/controller.java.vm"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义替换规则</span></span><br><span class="line">VelocityContext context = <span class="keyword">new</span> VelocityContext();</span><br><span class="line">context.put(<span class="string">"package"</span>,<span class="string">"org.developer.velocity.api"</span>);</span><br><span class="line">context.put(<span class="string">"className"</span>,<span class="string">"velocityDemo"</span>);</span><br><span class="line">context.put(<span class="string">"Object"</span>,<span class="string">"Value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储合并后的结果</span></span><br><span class="line">StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">t.merge(context,sw);</span><br><span class="line">String r = sw.toString();</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"##r:   \n"</span> +r);</span><br></pre></td></tr></table></figure>

<p>生成结果：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package org.developer.velocity.api.controller</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.<span class="keyword">annotation</span>.<span class="title">RestController</span>;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">velocityDemoController</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    public void getValue()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/130.png" alt="130.png"></p>
]]></content>
      <categories>
        <category>Velocity</category>
      </categories>
      <tags>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title>h-g源码解析</title>
    <url>/2020/03/10/h-g%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<ol>
<li><p>capitalizeFully 通过指定的符号将所有分隔的字母的首字母大写</p>
</li>
<li><p>java.util.Properties 继承自hashtable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>IOUtils.closeQuietly(out)</p>
<p>参考：<a href="https://www.jianshu.com/p/4edd1775b983" target="_blank" rel="noopener">commons.io-2.6 closeQuietly()</a></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Closeable closeable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeable.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>简化了流的关闭操作</em></strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>疫情下的影响</title>
    <url>/2020/03/10/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<p>2020 年伊始，新冠肺炎的汹涌来袭，我相信对于很多人来说的都是触不及防。</p>
<p>不出意外，我也成了这次疫情的 “受害者”。</p>
<p>2020农历新年才过几天，我就收到了前公司的主管的电话，当时兴奋的以为是转正的事宜，没想到的是解聘的通知…,在电话里，公司以 “莫须有” 的罪名把我裁了。很不幸，刚出社会就体验到了生活的冷暖，还记得那天是艳阳高照，春天还未到来，寒风依然猖獗，温暖的阳光照在身上，可是我却感受不到任何温度。</p>
<p>同样的我对几个朋友和同事也进行了交流，以下是他们对这次疫情的反映。</p>
<a id="more"></a>

<ul>
<li>朋友A</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192432.jpg" alt="image"></p>
<ul>
<li>朋友B</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192445.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192445.jpg"></p>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192449.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192449.jpg"></p>
<ul>
<li>朋友C</li>
</ul>
<p><img src="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192453.jpg" alt="http://q6s1x2hw2.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310192453.jpg"></p>
<p>其实每个人的境遇差不多，在疫情面前，大家都是平等的，只有严守才能最终战胜疫情。</p>
<p>希望等到夏日炎炎的时候，大家都可以约好一起吃雪糕！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎ElasticSearch</title>
    <url>/2020/03/09/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticSearch/</url>
    <content><![CDATA[<h1><span id="elasticsearch">ElasticSearch</span></h1><h2><span id="知识点">知识点</span></h2><p>参考：<a href="https://mp.weixin.qq.com/s/stC_xMP1n3aQ-0ZNAc3eQA" target="_blank" rel="noopener">elasticsearch基础</a></p>
<blockquote>
<p>Elasticsearch 为开源的、分布式、基于 Restful API、支持 PB 甚至更高数量级的搜索引擎工具。</p>
</blockquote>
<p>文档主要还是参考 es 的官方文档，已经解释说明的非常详尽。<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html</a></p>
<p>Elasticsearch 使用 JavaScript Object Notation（或者 <a href="http://en.wikipedia.org/wiki/Json" target="_blank" rel="noopener"><em>JSON</em></a>）作为文档的序列化格式。JSON 序列化为大多数编程语言所支持，并且已经成为 NoSQL 领域的标准格式。 它简单、简洁、易于阅读。</p>
<table>
<thead>
<tr>
<th>ElasticSearch</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>index 索引</td>
<td>database 数据库</td>
</tr>
<tr>
<td>type 类型</td>
<td>table 表</td>
</tr>
<tr>
<td>document 文档</td>
<td>Row 行</td>
</tr>
<tr>
<td>field 属性</td>
<td>Column 字段</td>
</tr>
</tbody></table>
<a id="more"></a>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjXcNvIDv32BMwkVKqicrC8Tk3iciaUjfVTJtYAM9x1CSH2mwBEtlGPmh1L1icpOCbO46RTSqDj4Owjmzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>从上表中可以看出：</p>
<ol>
<li>MySQL 中的数据库（DataBase），等价于 ES 中的索引（Index）。</li>
<li>MySQL 中一个数据库下面有 N 张表（Table），等价于1个索引 Index 下面有 N 多类型（Type）。</li>
<li>MySQL 中一个数据库表（Table）下的数据由多行（Row）多列（column，属性）组成，等价于1个 Type 由多个文档（Document）和多 Field 组成。</li>
<li>MySQL 中定义表结构、设定字段类型等价于 ES 中的 Mapping。举例说明，在一个关系型数据库里面，Schema 定义了表、每个表的字段，还有表和字段之间的关系。与之对应的，在 ES 中，Mapping 定义索引下的 Type 的字段处理规则，即索引如何建立、索引类型、是否保存原始索引 JSON 文档、是否压缩原始 JSON 文档、是否需要分词处理、如何进行分词处理等。</li>
<li>MySQL 中的增 insert、删 delete、改 update、查 search 操作等价于 ES 中的增 PUT/POST、删 Delete、改 _update、查 GET。其中的修改指定条件的更新 update 等价于 ES 中的 update_by_query，指定条件的删除等价于 ES 中的 delete_by_query。</li>
<li>MySQL 中的 group by、avg、sum 等函数类似于 ES 中的 Aggregations 的部分特性。</li>
<li>MySQL 中的去重 distinct 类似 ES 中的 cardinality 操作。</li>
<li>MySQL 中的数据迁移等价于 ES 中的 reindex 操作。</li>
</ol>
<p>如下是传统的关系型数据库（如Oracle、MySQL）、非关系型的数据库（如 Mongo）所做不到的：</p>
<p>1.传统的关系型数据库虽然能支持类型“like 待检索词”模糊语句匹配，但无法进行全文检索（分词检索）。</p>
<p>这里的全文检索，举例如下。</p>
<p>“text”：”公路局正在治理解放大道路面积水问题”，对于这段待检索的文字，经过细粒度分词后能得出如下的分词结果：</p>
<blockquote>
<p>公路局、公路、路局、路、局正、正在、正、治理、治、理解、理、解放、解、放大、大道、大、道路、道、路面、路、面积、面、积水、积、水、问题</p>
</blockquote>
<p>如果进行全文检索，是针对以上分词后的结果逐个进行匹配，并由得分的高低快速的返回匹配结果。</p>
<p>这点，传统数据库几乎不可能做到。</p>
<p>2.非关系型数据库 Mongo 虽能进行简单的全文检索，但对中文支持的不好、数据量大性能会有问题，这点是在实际应用中总结出的。</p>
<p>查询最简单的语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/1</span><br></pre></td></tr></table></figure>

<p>语法：GET /index/type/id</p>
<p>其实还有许多更复杂的搜索，例如：轻量搜索，高亮搜索，全文搜索等等。</p>
<h3><span id="bulk增删改操作">bulk增删改操作</span></h3><blockquote>
<p>bulk api 对 json 的语法，有严格的要求，每个 json 串不能换行，只能放一行，同时一个 json 串和一个 json 串之间，必须有一个换行</p>
</blockquote>
<p>语法如下：</p>
<p>bulk每一个操作要两个json串(delete语法除外)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"action"</span>:<span class="string">"&#123;metadata&#125;"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"data"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"index"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"jluzh"</span>,<span class="attr">"_type"</span>:<span class="string">"person"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"张三"</span>,<span class="attr">"age"</span>:<span class="number">20</span>,<span class="attr">"mail"</span>:<span class="string">"111@qq.com"</span>,<span class="attr">"hobby"</span>:<span class="string">"羽毛球，兵乓球，足球"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="组合查询">组合查询</span></h3><p>如果查询的结果中有 should 字段，则得分会更加高，也就是相似度更高。</p>
<blockquote>
<p>bool 查询会为每个文档计算相关度评分 _score, 再将所有匹配的 must 和 should 语句的分数 _score 求和，最后除以 must 和 should 语句的总数</p>
<p>must_not 语句不会影响评分；它的作用只是将不相关的文档排除</p>
</blockquote>
<h2><span id="入门示例">入门示例</span></h2><p>参考：<a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=mall整合elasticsearch实现商品搜索" target="_blank" rel="noopener">mall整合Elasticsearch实现商品搜索</a></p>
<p>示例出自上面这位大神</p>
<h3><span id="知识点铺垫">知识点铺垫</span></h3><p>由于SpringBoot 与 elasticsearch 需进行整合，所以不得不提到 Spring Data Elasticsearch</p>
<blockquote>
<p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，它可以避免编写大量的样板代码。</p>
</blockquote>
<p>常用的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标示映射到Elasticsearch文档上的领域对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Document &#123;</span><br><span class="line">    <span class="comment">//索引库名次，mysql中数据库的概念</span></span><br><span class="line">    <span class="function">String <span class="title">indexName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//文档类型，mysql中表的概念</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//默认分片数</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">shards</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line">    <span class="comment">//默认副本数量</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">replicas</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=id" target="_blank" rel="noopener">@Id</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示是文档的id，文档可以认为是mysql中表行的概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=field" target="_blank" rel="noopener">@Field</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Field &#123;</span><br><span class="line">  <span class="comment">//文档中字段的类型</span></span><br><span class="line">    <span class="function">FieldType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FieldType.Auto</span>;</span><br><span class="line">  <span class="comment">//是否建立倒排索引</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">index</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  <span class="comment">//是否进行存储</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">store</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  <span class="comment">//分词器名次</span></span><br><span class="line">    <span class="function">String <span class="title">analyzer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="comment">//为文档自动指定元数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FieldType &#123;</span><br><span class="line">    Text,<span class="comment">//会进行分词并建了索引的字符类型</span></span><br><span class="line">    Integer,</span><br><span class="line">    Long,</span><br><span class="line">    Date,</span><br><span class="line">    Float,</span><br><span class="line">    Double,</span><br><span class="line">    Boolean,</span><br><span class="line">    Object,</span><br><span class="line">    Auto,<span class="comment">//自动判断字段类型</span></span><br><span class="line">    Nested,<span class="comment">//嵌套对象类型</span></span><br><span class="line">    Ip,</span><br><span class="line">    Attachment,</span><br><span class="line">    Keyword<span class="comment">//不会进行分词建立索引的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=sping-data方式的数据操作" target="_blank" rel="noopener">Sping Data方式的数据操作</a></p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=继承elasticsearchrepository接口可以获得常用的数据操作方法" target="_blank" rel="noopener">继承ElasticsearchRepository接口可以获得常用的数据操作方法</a></p>
<p><img src="http://www.macrozheng.com/images/arch_screen_31.png" alt="img"></p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=可以使用衍生查询" target="_blank" rel="noopener">可以使用衍生查询</a></p>
<blockquote>
<p>在接口中直接指定查询方法名称便可查询，无需进行实现，如商品表中有商品名称、标题和关键字，直接定义以下查询，就可以对这三个字段进行全文搜索。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索查询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name              商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subTitle          商品标题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keywords          商品关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page              分页信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;EsProduct&gt; <span class="title">findByNameOrSubTitleOrKeywords</span><span class="params">(String name, String subTitle, String keywords, Pageable page)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在idea中直接会提示对应字段</p>
</blockquote>
<p><img src="http://www.macrozheng.com/images/arch_screen_32.png" alt="img"></p>
<h3><span id="开始">开始</span></h3><p>引入相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Elasticsearch相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!--Swagger-UI API文档生产工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">repositories:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">elasticsearch</span> <span class="comment"># es集群的名称</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure>

<p><strong><em>添加商品文档对象 EsProduct</em></strong></p>
<blockquote>
<p>不需要中文分词的字段设置成@Field(type = FieldType.Keyword)类型，需要中文分词的设置成@Field(analyzer = “ik_max_word”,type = FieldType.Text)类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.nosql.elasticsearch.document;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索中的商品信息</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/6/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"pms"</span>, type = <span class="string">"product"</span>,shards = <span class="number">1</span>,replicas = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsProduct</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String productSn;</span><br><span class="line">    <span class="keyword">private</span> Long brandId;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line">    <span class="keyword">private</span> Long productCategoryId;</span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Keyword)</span><br><span class="line">    <span class="keyword">private</span> String productCategoryName;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String subTitle;</span><br><span class="line">    <span class="meta">@Field</span>(analyzer = <span class="string">"ik_max_word"</span>,type = FieldType.Text)</span><br><span class="line">    <span class="keyword">private</span> String keywords;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer sale;</span><br><span class="line">    <span class="keyword">private</span> Integer newStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer recommandStatus;</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="keyword">private</span> Integer promotionType;</span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line">    <span class="meta">@Field</span>(type =FieldType.Nested)</span><br><span class="line">    <span class="keyword">private</span> List&lt;EsProductAttributeValue&gt; attrValueList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了所有getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.macrozheng.com/#/architect/mall_arch_07?id=添加esproductrepository接口用于操作elasticsearch" target="_blank" rel="noopener">添加EsProductRepository接口用于操作Elasticsearch</a></p>
<blockquote>
<p>继承ElasticsearchRepository接口，这样就拥有了一些基本的Elasticsearch数据操作方法，同时定义了一个衍生查询方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.nosql.elasticsearch.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.nosql.elasticsearch.document.EsProduct;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品ES操作类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/6/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EsProductRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">EsProduct</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name              商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subTitle          商品标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keywords          商品关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page              分页信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Page&lt;EsProduct&gt; <span class="title">findByNameOrSubTitleOrKeywords</span><span class="params">(String name, String subTitle, String keywords, Pageable page)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它请参照大神的项目：<a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-06" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-06</a></p>
<p>具体流程：</p>
<p>模拟搜索商品的业务流程，先将数据库中所有的商品信息导入到es中，再通过es的分词方法，通过keyword 快速找到商品的相应的信息。</p>
<h1><span id="logstash">Logstash</span></h1><p>可以把 Logstash 理解成流入，流出 Elasticsearch 的传送带</p>
<p>支持：不同类型的数据或实施数据流经过 Logstash 写入 ES 或者从 ES 中读出写入文件或对应的实施数据流。</p>
<p>包括但不限于：</p>
<ul>
<li>本地或远程文件；</li>
<li>Kafka 实时数据流——核心插件有 logstashinputkafka/logstashoutputkafka；</li>
<li>MySQL、Oracle 等关系型数据库——核心插件有 logstashinputjdbc/logstashouputjdbc；</li>
<li>Mongo 非关系型数据库——核心插件有 logstashinputmongo/logstashoutputmongo；</li>
<li>Redis 数据流；</li>
<li>……</li>
</ul>
<h1><span id="kibana-认知">Kibana 认知</span></h1><blockquote>
<p>Kibana 是 ES 大数据的图形化展示工具。集成了 DSL 命令行查看、数据处理插件、继承了 x-pack（收费）安全管理插件等。</p>
</blockquote>
<h1><span id="beats轻量型数据采集器">Beats(轻量型数据采集器)</span></h1><blockquote>
<p>Beats 平台集合了多种单一用途采集器，它们从成百上千台机器和系统向 Logstash 或 Elasticsearch 发送数据</p>
</blockquote>
<p>数据流程图</p>
<p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C229.png" alt="229"></p>
<p>Beats 的组件</p>
<p><img src="C:%5CUsers%5CmikeLv%5CPictures%5C%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%5C230.png" alt="230"></p>
<h2><span id="filebeat">FileBeat</span></h2><p>轻量型日志采集器</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>LongStream实现Fibonacci数列</title>
    <url>/2020/03/09/LongStream%E5%AE%9E%E7%8E%B0Fibonacci%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322655160467490" target="_blank" rel="noopener">创建Stream</a></p>
<p>在学习 Java8 的 Stream 的时候，发现廖雪峰的网站上有一道题挺有意思，顺便可以练练手。</p>
<ul>
<li>编写一个能输出斐波拉契数列（Fibonacci）的<code>LongStream</code>：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, ...</span><br></pre></td></tr></table></figure>

<p>最后捣鼓出来的答案：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Learn Java from https://www.liaoxuefeng.com/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mikelv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		LongStream fib = LongStream.generate(<span class="keyword">new</span> FibSupplier());</span><br><span class="line">		<span class="comment">// 打印Fibonacci数列：1，1，2，3，5，8，13，21...</span></span><br><span class="line">		fib.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibSupplier</span> <span class="keyword">implements</span> <span class="title">LongSupplier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAsLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sum = x + y;</span><br><span class="line">		x = y;</span><br><span class="line">		y = sum;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比之前网上的常用的实现方法确实简洁了不少，而且更易于理解。代码地址：<a href="https://gitee.com/mikeLv01/stream-fibonacci-demo" target="_blank" rel="noopener">https://gitee.com/mikeLv01/stream-fibonacci-demo</a></p>
<p>转载：<a href="https://blog.csdn.net/blue_hh/article/details/75453603" target="_blank" rel="noopener">大龙湖畔</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.homework.lhh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"斐波那契数列前20项的值如下："</span>);</span><br><span class="line">        System.out.print(num[<span class="number">0</span>]+<span class="string">" "</span>+num[<span class="number">1</span>]+<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            num[i] = num[i - <span class="number">1</span>] + num[i - <span class="number">2</span>];</span><br><span class="line">            System.out.print(num[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="知识点">知识点</span></h2><blockquote>
<h3><span id="基于-supplier">基于 Supplier</span></h3></blockquote>
<p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>

<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> NatualSupplier());</span><br><span class="line">        <span class="comment">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class="line">        natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NatualSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>如果用<code>List</code>表示，即便在<code>int</code>范围内，也会占用巨大的内存，而<code>Stream</code>几乎不占用空间，<strong><em>因为每个元素都是实时计算出来的，用的时候再算</em></strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8-Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性</title>
    <url>/2020/03/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2><span id="函数式接口">函数式接口</span></h2><p>函数式接口(Functional Interface)就是一个<strong><em>有且仅有一个抽象方法</em></strong>，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为 lambda 表达式。方法引用是 lambda 表达式的另一种表现形式</p>
<h2><span id="lambda">Lambda</span></h2><p>参考：</p>
<p><a href="https://www.jianshu.com/p/8b4e578ecf58" target="_blank" rel="noopener">Lambda表达式学习（一）为什么使用Lambda表达式？</a></p>
<p><a href="https://www.cnblogs.com/WJ5888/p/4667086.html" target="_blank" rel="noopener">Java 8 Lambda实现原理分析</a></p>
<p>代码简介程度：外部类 &gt; 内部类 &gt; 匿名内部类 &gt; lambda &gt; 方法引用</p>
<p>这里不得不提及下 <strong><em>匿名内部类</em></strong></p>
<p>参考自：<a href="https://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="noopener">java提高篇(十)—–详解匿名内部类</a></p>
<blockquote>
<p>省去了实现类，直接<strong>new 接口名(){…}</strong> 没有实现类名，实际就是实现且创建了一个接口对象。</p>
<p>匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类</p>
<p>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。</p>
</blockquote>
<p>Lambad 表达式首先会被编译为一个 <strong>私有的静态函数</strong></p>
<p>其后，会生成一个 <strong>内部类</strong></p>
<a id="more"></a>

<h2><span id="stream">Stream</span></h2><p>转载：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889" target="_blank" rel="noopener">使用Stream</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">Java 8 中的 Streams API 详解</a></p>
<p>Java8 开始，不但引入 Lambada 表达式，还引入了一个全新的流式 API：<strong>Stream API</strong>。它位于 <code>java.util.stream</code> 包中。</p>
<p><em>划重点</em>：这个<code>Stream</code>不同于<code>java.io</code>的<code>InputStream</code>和<code>OutputStream</code>，它代表的是<strong><em>任意Java对象的序列</em></strong>。两者对比如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">java.io</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储</td>
<td align="left">顺序读写的<code>byte</code>或<code>char</code></td>
<td>顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">序列化至文件或网络</td>
<td>内存计算／业务逻辑</td>
</tr>
</tbody></table>
<p><em>再次划重点</em>：这个<code>Stream</code>和<code>List</code>也不一样，<code>List</code>存储的每个元素都是已经存储在内存中的某个Java对象，而<code>Stream</code>输出的元素可能并没有预先存储在内存中，而是实时计算出来的。</p>
<p>换句话说，<code>List</code>的用途是操作一组已存在的Java对象，而<code>Stream</code>实现的是惰性计算，两者对比如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">java.util.List</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">元素</td>
<td align="left">已分配并存储在内存</td>
<td>可能未分配，实时计算</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">操作一组已存在的Java对象</td>
<td>惰性计算</td>
</tr>
</tbody></table>
<p><code>Stream</code>看上去有点不好理解，但我们举个例子就明白了。</p>
<p>如果我们要表示一个全体自然数的集合，显然，用<code>List</code>是不可能写出来的，因为自然数是无限的，内存再大也没法放到<code>List</code>中：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;BigInteger&gt; <span class="built_in">list</span> = ??? <span class="comment">// 全体自然数?</span></span><br></pre></td></tr></table></figure>

<p>但是，用<code>Stream</code>可以做到。写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br></pre></td></tr></table></figure>

<p>我们先不考虑<code>createNaturalStream()</code>这个方法是如何实现的，我们看看如何使用这个<code>Stream</code>。</p>
<p>首先，我们可以对每个自然数做一个平方，这样我们就把这个<code>Stream</code>转换成了另一个<code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br><span class="line">Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); <span class="comment">// 全体自然数的平方</span></span><br></pre></td></tr></table></figure>

<p>因为这个<code>streamNxN</code>也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用<code>limit()</code>方法截取前100个元素，最后用<code>forEach()</code>处理每个元素，这样，我们就打印出了前100个自然数的平方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream();</span><br><span class="line">naturals.map(n -&gt; n.multiply(n)) <span class="comment">// 1, 4, 9, 16, 25...</span></span><br><span class="line">        .limit(<span class="number">100</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>我们总结一下<code>Stream</code>的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>
<p><code>Stream</code>的另一个特点是，一个<code>Stream</code>可以轻易地转换为另一个<code>Stream</code>，而不是修改原<code>Stream</code>本身。</p>
<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s3 = s2.limit(<span class="number">100</span>); <span class="comment">// 不计算</span></span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure>

<p>惰性计算的特点是：一个<code>Stream</code>转换为另一个<code>Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</p>
<p>例如，创建一个全体自然数的<code>Stream</code>，不会进行计算，把它转换为上述<code>s2</code>这个<code>Stream</code>，也不会进行计算。再把<code>s2</code>这个无限<code>Stream</code>转换为<code>s3</code>这个有限的<code>Stream</code>，也不会进行计算。只有最后，调用<code>forEach</code>确实需要<code>Stream</code>输出的元素时，才进行计算。我们通常把<code>Stream</code>的操作写成链式操作，代码更简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">createNaturalStream()</span><br><span class="line">    .map(BigInteger::multiply)</span><br><span class="line">    .limit(<span class="number">100</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>因此，Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result = createNaturalStream() <span class="comment">// 创建Stream</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure>

<h3><span id="小结">小结</span></h3><p>Stream API的特点是：</p>
<ul>
<li>Stream API提供了一套新的流式处理的抽象序列；</li>
<li>Stream API支持函数式编程和链式操作；</li>
<li>Stream可以表示无限序列，并且大多数情况下是惰性求值的。</li>
</ul>
<h3><span id="创建stream">创建Stream</span></h3><p>要使用<code>Stream</code>，就必须现创建它。创建<code>Stream</code>有很多种方法，我们来一一介绍。</p>
<h4><span id="streamof">Stream.of()</span></h4><p>创建<code>Stream</code>最简单的方式是直接用<code>Stream.of()</code>静态方法，传入可变参数即创建了一个能输出确定元素的<code>Stream</code>：</p>
<p><code>import java.util.stream.Stream;</code> Run</p>
<p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p>
<h4><span id="基于数组或collection">基于数组或Collection</span></h4><p>第二种创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者<code>Collection</code>持有的元素：</p>
<p><code>import java.util.*; import java.util.stream.*;</code> Run</p>
<p>把数组变成<code>Stream</code>使用<code>Arrays.strem()</code>方法。对于<code>Collection</code>（<code>List</code>、<code>Set</code>、<code>Queue</code>等），直接调用<code>stream()</code>方法就可以获得<code>Stream</code>。</p>
<p>上述创建<code>Stream</code>的方法都是把一个现有的序列变为<code>Stream</code>，它的元素是固定的。</p>
<h4><span id="基于supplier">基于Supplier</span></h4><p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; s = <span class="built_in">Stream</span>.generate(Supplier&lt;<span class="keyword">String</span>&gt; sp);</span><br></pre></td></tr></table></figure>

<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>
<p><code>import java.util.function.*; import java.util.stream.*;</code> Run</p>
<p>上述代码我们用一个<code>Supplier</code>模拟了一个无限序列（当然受<code>int</code>范围限制不是真的无限大）。如果用<code>List</code>表示，即便在<code>int</code>范围内，也会占用巨大的内存，而<code>Stream</code>几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>
<p>对于无限序列，如果直接调用<code>forEach()</code>或者<code>count()</code>这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用<code>limit()</code>方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用<code>forEach()</code>或者<code>count()</code>操作就没有问题。</p>
<h4><span id="其他方法">其他方法</span></h4><p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p>
<p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"/path/to/file.txt"</span>))) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法对于按行遍历文本文件十分有用。</p>
<p>另外，正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"\\s+"</span>);</span><br><span class="line">Stream&lt;String&gt; s = p.splitAsStream(<span class="string">"The quick brown fox jumps over the lazy dog"</span>);</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4><span id="基本类型">基本类型</span></h4><p>因为Java的范型不支持基本类型，所以我们无法用<code>Stream</code>这样的类型，会发生编译错误。为了保存<code>int</code>，只能使用<code>String</code>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>，它们的使用方法和范型<code>Stream</code>没有大的区别，设计这三个<code>Stream</code>的目的是提高运行效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int[]数组变为IntStream:</span></span><br><span class="line">IntStream is = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class="line">LongStream ls = List.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure>

<p>创建<code>Stream</code>的方法有 ：</p>
<ul>
<li>通过指定元素、指定数组、指定<code>Collection</code>创建<code>Stream</code>；</li>
<li>通过<code>Supplier</code>创建<code>Stream</code>，可以是无限序列；</li>
<li>通过其他类的相关方法创建。</li>
</ul>
<p>基本类型的<code>Stream</code>有<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code></p>
<h2><span id="方法引用">方法引用</span></h2><p>转载：</p>
<p><a href="https://www.runoob.com/java/java8-method-references.html" target="_blank" rel="noopener">Java 8 方法引用</a></p>
<p>方法引用通过方法的名字来指向一个方法</p>
<p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>方法引用使用一对冒号 <strong>::</strong> 。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collided "</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Following the "</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>构造器引用：</strong>它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"> cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>方法引用一般都是调用静态方法，如果是类对象调用的话，就需要进行传参处理，将该对象传递过去</p>
<h2><span id="默认方法">默认方法</span></h2><p>Java 8 新增了接口的默认方法。</p>
<p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>
<p>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件RabbitMQ</title>
    <url>/2020/03/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><ol>
<li><p>大多应用中，可通过消息服务中间件来提升系统异步通信，扩展解耦能力</p>
</li>
<li><p>消息服务中两个重要概念：</p>
<p>​    <strong>消息代理(message broker) 和 目的地(destination)</strong>,当消息发送者发送消息以后，将有消息代理接管，消息代理保证消息传递到指定目的地</p>
</li>
<li><p>消息队列主要有两种形式的目的地</p>
<ol>
<li>队列(queue): 点对点消息通信</li>
<li>主题(topic): 发布(publish)/订阅(subscribe) 消息通信</li>
</ol>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200309155537186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h2><span id="rabbitmq">RabbitMQ</span></h2><p>RabbitMQ 是一个由 erlang 开发的 AMQP(Advanced Message Queue Protocol) 的开源实现</p>
<h3><span id="核心概念">核心概念</span></h3><blockquote>
<h4><span id="message">Message</span></h4></blockquote>
<p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key(路由键) , priority，delivery-mode</p>
<blockquote>
<h4><span id="publisher">Publisher</span></h4></blockquote>
<p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
<blockquote>
<h4><span id="exchange">Exchange</span></h4></blockquote>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<p>Exchange 有4种类型：</p>
<ul>
<li>direct(默认)</li>
<li>fanout</li>
<li>topic</li>
<li>headers</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155601426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Direct 模型</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155616695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>fanout模型(广播模型)</li>
<li>topic(模式匹配模式)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200309155629666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<h4><span id="routekey">routeKey</span></h4></blockquote>
<p>路由Key键，交换器根据这个 key 键将 message 转发到对应的队列中</p>
<h2><span id="rabbitlistener-和-rabbithandler">@RabbitListener 和 @RabbitHandler</span></h2><p>转载：<a href="https://www.jianshu.com/p/911d987b5f11" target="_blank" rel="noopener">RabbitMQ：@RabbitListener 与 @RabbitHandler 及 消息序列化</a></p>
<ul>
<li>RabbitMQ 的序列化是指 Message 的 body 属性，即我们真正需要传输的内容，<strong>RabbitMQ 抽象出一个 MessageConvert 接口处理消息的序列化</strong>，其实现有 SimpleMessageConverter（默认）、Jackson2JsonMessageConverter 等</li>
<li>当调用了 convertAndSend 方法时会使用 MessageConvert 进行消息的序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"consumer_queue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(<span class="keyword">byte</span>[] message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 @RabbitListener 注解标记方法，当监听到队列中有消息时则会进行接收并处理</p>
</li>
<li><p>@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用</p>
</li>
<li><p>@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型</p>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>消息处理方法参数是由 MessageConverter 转化，若使用自定义 MessageConverter 则需要在 RabbitListenerContainerFactory 实例中去设置（默认 Spring 使用的实现是 SimpleRabbitListenerContainerFactory）</li>
<li>消息的 content_type 属性表示消息 body 数据以什么数据格式存储，接收消息除了使用 Message 对象接收消息（包含消息属性等信息）之外，还可直接使用对应类型接收消息 body 内容，但若方法参数类型不正确会抛异常：<ul>
<li><strong>application/octet-stream</strong>：二进制字节数组存储，使用 byte[]</li>
<li><strong>application/x-java-serialized-object</strong>：java 对象序列化格式存储，使用 Object、相应类型（反序列化时类型应该同包同名，否者会抛出找不到类异常）</li>
<li><strong>text/plain</strong>：文本数据类型存储，使用 String</li>
<li><strong>application/json</strong>：JSON 格式，使用 Object、相应类型</li>
</ul>
</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/9434708-77b9d3222ae376cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2><span id="死信队列dead-message-queue">死信队列(dead-message-queue)</span></h2><p>转载自: <a href="https://blog.csdn.net/zhangcongyi420/article/details/100126666" target="_blank" rel="noopener">rabbitmq死信队列详解与使用</a></p>
<p>死信,顾名思义就是无法被消费的消息。</p>
<p>一般来说，producer 将消息投递到 broker 或者直接到 queue 里，consumer 从queue 取出消息进行消费，但某些时候由于特定的原因无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列；</p>
<p><strong><em>产生的原因</em></strong></p>
<ul>
<li>消息被拒绝<strong>(basic.reject或basic.nack)并且requeue=false.</strong></li>
<li>消息 TTL 过期</li>
<li>队列达到最大长度（队列满了，无法再添加数据到mq中）</li>
</ul>
<p><strong><em>处理方式</em></strong></p>
<ol>
<li>丢弃，如果不是很重要，可以选择丢弃</li>
<li>记录死信入库，然后做后续的业务分析或处理</li>
<li>通过死信队列，由负责监听死信的应用程序进行处理</li>
</ol>
<h2><span id="入门示例">入门示例</span></h2><p>参考：</p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_09" target="_blank" rel="noopener">http://www.macrozheng.com/#/architect/mall_arch_09</a></p>
<p>1.添加关键依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息队列相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.application.yml 关键配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># rabbitmq的连接地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># rabbitmq的连接端口号</span></span><br><span class="line">        <span class="attr">virtual-host:</span> <span class="string">/mall</span> <span class="comment"># rabbitmq的虚拟host</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的用户名</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的密码</span></span><br><span class="line">        <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#如果对异步消息需要回调必须设置为true</span></span><br></pre></td></tr></table></figure>

<p>3.配置消息队列基本信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消息队列枚举配置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:35</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> QueueEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_ORDER_CANCEL(<span class="string">"mall.order.direct"</span>, <span class="string">"mall.order.cancel"</span>, <span class="string">"mall.order.cancel"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知ttl队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_TTL_ORDER_CANCEL(<span class="string">"mall.order.direct.ttl"</span>, <span class="string">"mall.order.cancel.ttl"</span>, <span class="string">"mall.order.cancel.ttl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey;</span><br><span class="line"></span><br><span class="line">    QueueEnum(String exchange, String name, String routeKey) &#123;</span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.routeKey = routeKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.消息队列的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消息队列配置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:38</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单消息实际消费队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">orderDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">orderTtlDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单实际消费队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QueueEnum.QUEUE_ORDER_CANCEL.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列(死信队列)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderTtlQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getName())</span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-exchange"</span>,QueueEnum.QUEUE_ORDER_CANCEL.getExchange())<span class="comment">//到期后转发的交换机</span></span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-routing-key"</span>, QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey())<span class="comment">//到期后转发的路由键</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">orderBinding</span><span class="params">(DirectExchange orderDirect, Queue orderQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderQueue)</span><br><span class="line">                .to(orderDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单延迟队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">orderTtlBinding</span><span class="params">(DirectExchange orderTtlDirect,Queue orderTtlQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderTtlQueue)</span><br><span class="line">                .to(orderTtlDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.取消订单消息的发出者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取消订单消息的发出者</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 12:06</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(CancelOrderSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Long orderId,<span class="keyword">final</span> <span class="keyword">long</span> delayTimes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//给延迟队列发送消息,配置交换器和路由key和队列，自动序列化发送的消息</span></span><br><span class="line">        amqpTemplate.convertAndSend(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange(), QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey(), orderId, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">                <span class="comment">//给消息设置延迟毫秒值</span></span><br><span class="line">                message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LOGGER.info(<span class="string">"send delay message orderId:&#123;&#125;"</span>,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.取消订单消息的处理者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取消订单消息的处理者</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> yisheng.mikelv@foxmail.com 2020/3/8 11:56</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//RabbitListener 监听队列 mall.order.cancel</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"mall.order.cancel"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CancelOrderReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OmsPortalOrderService portalOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当该类有消息需要处理时，即交给该方法处理</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Long orderId)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"receive delay message orderId:&#123;&#125;"</span>,orderId);</span><br><span class="line">        portalOrderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它可参考大神的项目：<a href="https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-08" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-08</a></p>
<ul>
<li>具体流程</li>
</ul>
<p>是模拟订单下单，下单完成后开启一个延迟消息(<em>sendDelayMessageCancelOrder()</em>)，用于当用户没有付款时取消订单(orderId应该在下单后生成)。 CancelOrderSender 给延迟队列发送消息,配置交换器和路由key和队列(<em>sendMessage()</em>)，自动序列化发送的消息。CancelOrderReceiver 监听消息队列(<u>mall.order.cancel</u>),当有消息的时候接收并消费该消息(<em>cancelOrder()</em>)。</p>
<ul>
<li>运行截图如下所示</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020030915571585.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Swagger</title>
    <url>/2020/03/07/SpringBoot%E6%95%B4%E5%90%88Swagger/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="http://www.macrozheng.com/#/architect/mall_arch_02" target="_blank" rel="noopener">SpringBoot整合Swagger</a></p>
<h2><span id="添加项目依赖">添加项目依赖</span></h2><blockquote>
<p>在pom.xml中新增Swagger-UI相关依</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Swagger-UI API文档生产工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1><span id="添加swagger-ui的配置"></span></h1><blockquote>
<p>添加Swagger-UI的Java配置文件</p>
</blockquote>
<p>注意：Swagger对生成API文档的范围有三种不同的选择</p>
<ul>
<li>生成指定包下面的类的API文档</li>
<li>生成有指定注解的类的API文档</li>
<li>生成有指定注解的方法的API文档</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger2API文档的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            <span class="comment">//为当前包下controller生成API文档</span></span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">"org.developer.es.api.controller"</span>))</span><br><span class="line">            <span class="comment">//为有@Api注解的Controller生成API文档</span></span><br><span class="line">            <span class="comment">//                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span></span><br><span class="line">            <span class="comment">//为有@ApiOperation注解的方法生成API文档</span></span><br><span class="line">            <span class="comment">//                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span></span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            .title(<span class="string">"SwaggerUI演示"</span>)</span><br><span class="line">            .description(<span class="string">"es-demo"</span>)</span><br><span class="line">            .contact(<span class="string">"mikelv"</span>)</span><br><span class="line">            .version(<span class="string">"1.0"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="controller模板">Controller模板</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span>(tags = SwaggerApiConfig.GENERATOR_CONTROLLER)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DDD 模型生成代码, 前端为swagger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"DDD模型生成"</span>,produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/ddd/code"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; generateByDDD(</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"表名"</span>,required = <span class="keyword">true</span>,defaultValue = <span class="string">"a,b"</span>)<span class="meta">@RequestParam</span> String[] tables,</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"表前缀"</span>,required = <span class="keyword">true</span>)<span class="meta">@RequestParam</span> String tablePrefix,</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"包名"</span>,required = <span class="keyword">true</span>)<span class="meta">@RequestParam</span> String pkg,</span><br><span class="line">            <span class="meta">@ApiParam</span>(value = <span class="string">"作者"</span>,required = <span class="keyword">true</span>)<span class="meta">@RequestParam</span> String author,</span><br><span class="line">            HttpServletResponse response) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="swagger接口配置类">Swagger接口配置类</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerApiConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERATOR_CONTROLLER = <span class="string">"generator controller"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwaggerApiConfig</span><span class="params">(Docket docket)</span></span>&#123;</span><br><span class="line">        docket.tags(<span class="keyword">new</span> Tag(GENERATOR_CONTROLLER,<span class="string">"代码自动生成服务"</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot多数据源切换学习总结</title>
    <url>/2020/03/05/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>主要参考：<a href="https://www.cnblogs.com/shihaiming/p/11067623.html" target="_blank" rel="noopener">SpringBoot之多数据源动态切换数据源</a></p>
<p>其它参考：</p>
<p><a href="https://blog.csdn.net/catoop/article/details/50575038" target="_blank" rel="noopener">Spring Boot 动态数据源(多数据源自动切换)</a></p>
<p><a href="https://blog.csdn.net/qq_37502106/article/details/91044952" target="_blank" rel="noopener">spring boot使用AbstractRoutingDataSource实现动态数据源切换</a></p>
<p><a href="https://www.jianshu.com/p/b158476dd33c" target="_blank" rel="noopener">AbstractRoutingDataSource – Spring提供的轻量级数据源切换方式</a></p>
<p><a href="https://www.jianshu.com/p/a042ff2ee2ae" target="_blank" rel="noopener">【Spring】使用Spring的AbstractRoutingDataSource实现多数据源切换</a></p>
<p><a href="https://www.jianshu.com/p/3c5d7f09dfbd" target="_blank" rel="noopener">ThreadLocal</a></p>
<p><a href="https://juejin.im/post/5ac2eb52518825555e5e06ee" target="_blank" rel="noopener">ThreadLocal就是这么简单</a></p>
<p><a href="https://blog.csdn.net/rainbow702/article/details/52185827" target="_blank" rel="noopener">Spring AOP @Before @Around @After 等 advice 的执行顺序</a></p>
<p><a href="https://blog.csdn.net/u010502101/article/details/78823056" target="_blank" rel="noopener">AspectJ 切面注解中五种通知注解：@Before、@After、@AfterRunning、@AfterThrowing、@Around</a></p>
<p><a href="https://www.xiefayang.com/2019/04/01/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Spring Boot 2.0源码解析-配置绑定</a></p>
<p><a href="http://blog.didispace.com/Spring-Boot-2-0-feature-1-relaxed-binding-2/" target="_blank" rel="noopener">Spring Boot 2.0 新特性（一）：配置绑定 2.0 全解析</a></p>
<p><a href="https://www.cnblogs.com/aheizi/p/7071181.html" target="_blank" rel="noopener">Java注解–实现动态数据源切换</a></p>
<p><a href="https://webfuse.cn/2017/08/10/%E5%88%A9%E7%94%A8Spring%E7%9A%84AbstractRoutingDataSource%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">利用Spring的AbstractRoutingDataSource解决多数据源的问题</a></p>
<a id="more"></a>

<blockquote>
<h3><span id="数据源定义">数据源定义</span></h3></blockquote>
<p>Java中的数据源就是连接到数据库的一条路径，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接。DataSource的创建可以有不同的实现。DataSource通常被称为数据源，它包含连接池 和连接池管理 两部分，习惯上也经常把DataSource称为连接池</p>
<blockquote>
<h3><span id="springboot-读取配置文件方式">SpringBoot 读取配置文件方式</span></h3></blockquote>
<p>SpringBoot2.x 开始推荐读取配置文件的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Binder binder = Binder.get(environment);<span class="comment">//简单绑定</span></span><br><span class="line"><span class="keyword">this</span>.defaultDataSourceProperties = binder.bind(<span class="string">"spring.datasource.master"</span>,Map<span class="class">.<span class="keyword">class</span>).<span class="title">get</span>()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>推荐使用 Binder 读取配置文件</strong></p>
<h2><span id="abstractroutingdatasource">AbstractRoutingDataSource</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object defaultTargetDataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lenientFallback = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> DataSourceLookup dataSourceLookup = <span class="keyword">new</span> JndiDataSourceLookup();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRoutingDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetDataSources</span><span class="params">(Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDataSources = targetDataSources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTargetDataSource</span><span class="params">(Object defaultTargetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultTargetDataSource = defaultTargetDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLenientFallback</span><span class="params">(<span class="keyword">boolean</span> lenientFallback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lenientFallback = lenientFallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceLookup</span><span class="params">(@Nullable DataSourceLookup dataSourceLookup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSourceLookup = (DataSourceLookup)(dataSourceLookup != <span class="keyword">null</span> ? dataSourceLookup : <span class="keyword">new</span> JndiDataSourceLookup());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.targetDataSources == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'targetDataSources' is required"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resolvedDataSources = <span class="keyword">new</span> HashMap(<span class="keyword">this</span>.targetDataSources.size());</span><br><span class="line">            <span class="keyword">this</span>.targetDataSources.forEach((key, value) -&gt; &#123;</span><br><span class="line">                Object lookupKey = <span class="keyword">this</span>.resolveSpecifiedLookupKey(key);</span><br><span class="line">                DataSource dataSource = <span class="keyword">this</span>.resolveSpecifiedDataSource(value);</span><br><span class="line">                <span class="keyword">this</span>.resolvedDataSources.put(lookupKey, dataSource);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultTargetDataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resolvedDefaultDataSource = <span class="keyword">this</span>.resolveSpecifiedDataSource(<span class="keyword">this</span>.defaultTargetDataSource);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">resolveSpecifiedLookupKey</span><span class="params">(Object lookupKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookupKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">resolveSpecifiedDataSource</span><span class="params">(Object dataSource)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> DataSource) &#123;</span><br><span class="line">            <span class="keyword">return</span> (DataSource)dataSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.dataSourceLookup.getDataSource((String)dataSource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal data source value - only [javax.sql.DataSource] and String supported: "</span> + dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>) ? <span class="keyword">this</span> : <span class="keyword">this</span>.determineTargetDataSource().unwrap(iface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>) || <span class="keyword">this</span>.determineTargetDataSource().isWrapperFor(iface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">        Object lookupKey = <span class="keyword">this</span>.determineCurrentLookupKey();</span><br><span class="line">        DataSource dataSource = (DataSource)<span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractRoutingDataSource是spring-jdbc包提供的一个了AbstractDataSource的抽象类，它<strong>实现了DataSource接口</strong>的用于获取数据库连接的方法。</p>
<p>可以看到源码中也是通过 determineTargetDataSource() 获取到 datasource 对象，再从这个配置好的 datasource 获取到数据库连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.determineTargetDataSource().getConnection(username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看 <strong>determineTargetDataSource()方法代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">    Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">    DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法的返回值就是项目中所要用的DataSource的key值，拿到该key后就可以在resolvedDataSource中取出对应的DataSource，如果key找不到对应的DataSource就使用默认的数据源。</span></span><br></pre></td></tr></table></figure>

<p><strong>determineCurrentLookupKey 用于在获得数据库连接之前执行，以便在出现多数据源的情况下，由该方法确定调用哪个数据源key。且每切换一次数据源就会被调用一次</strong></p>
<p>总结：</p>
<p>SpringBoot 提供了 AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样在执行查询之前，设置使用的数据源。实现可动态路由的数据源，在每次数据库查询操作前执行。通过它的抽象方法 <strong><em>determineCurrentLookupKey()</em></strong> 获取到数据源对应的key，<strong><em>determineTargetDataSource()</em></strong> 拿到该key后就可以在resolvedDataSource中取出对应的DataSource。</p>
<h2><span id="mutablepropertyvalues">MutablePropertyValues</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title">PropertyValues</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>用过类的实现关系可知 <strong>MutablePropertyValues</strong> 实现了 <strong><em>PropertyValues接口</em></strong> </p>
<ul>
<li>PropertyValues 源码</li>
</ul>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/131.png" alt="131.png"></p>
<p>由图可知，PropertyValues接口类 包含了许多对属性的基本操作：迭代，分割，获取，等</p>
<ul>
<li>MutablePropertyValues源码</li>
</ul>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/132.png" alt="132.png"></p>
<p>可见 MutablePropertyValues 丰富了 PropertyValues 对属性值的操作</p>
<p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/133.png" alt="133.png"></p>
<p>且通过类的继承关系可以发现，PropertyValues 只有一个实现类：*<em>MutablePropertyValues *</em></p>
<h2><span id="threadlocal">ThreadLocal</span></h2><p><img src="https://hexo-images-mikelv.oss-cn-shenzhen.aliyuncs.com/129.png" alt="129.png"></p>
<p>Threadlocal 是一个线程内部的 <strong>存储类</strong>，可以在指定内存存储数据，数据存储以后，<strong>只有指定的线程可以得到存储数据</strong></p>
<p>ThreadLocal 提供了线程的局部变量，每个线程都可以通过 <code>set()</code> 和 <code>get()</code> 来对这个局部变量进行操作，但不会和其它线程的局部变量进行冲突，<strong>实现了线程的数据隔离</strong></p>
<h3><span id="threadlocalmap">ThreadLocalMap</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....很长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码可知，ThreadLocalMap 是 ThreadLocal 的一个内部类。用 Entry 类来进行存储。</p>
<p>先来看 set()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的<strong>值都是存储到这个 Map 上的，key 是当前 ThreadLocal 对象</strong></p>
<p><strong>Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象</strong></p>
<p>有了上面的基础，我们看get()方法就一点都不难理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3><span id="总结">总结</span></h3></blockquote>
<ol>
<li>每个Thread维护着一个ThreadLocalMap的引用</li>
<li>ThreadLocalMap是ThreadLocal的内部类，用<strong>Entry</strong>来进行存储</li>
<li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li>
<li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li>
<li><strong>ThreadLocal本身并不存储值</strong>，它只是<strong>作为一个key来让线程从ThreadLocalMap获取value</strong>。</li>
</ol>
<blockquote>
<h3><span id="避免内存泄漏">避免内存泄漏</span></h3></blockquote>
<p>我们来看一下ThreadLocal的对象关系引用图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC80LzMvMTYyODk2YWIxYTFkMWUyZQ?x-oss-process=image/format,png" alt="img"></p>
<p>ThreadLocal内存泄漏的根源是：<strong>由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用</strong>。</p>
<p>想要避免内存泄露就要<strong>手动remove()掉</strong>！</p>
<h2><span id="aop">AOP</span></h2><p>要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面<strong>相匹配的 Bean 创建代理</strong>。</p>
<p>在切面类中需要定义切面方法用于响应响应的目标方法，切面方法即为通知方法，通知方法需要用注解标识，AspectJ 支持 5 种类型的通知注解:</p>
<ul>
<li><strong>@Before</strong>: 前置通知, 在方法执行之前执行</li>
<li><strong>@After</strong>: 后置通知, 在方法执行之后执行 。</li>
<li><strong>@AfterRunning</strong>: 返回通知, 在方法返回结果之后执行</li>
<li><strong>@AfterThrowing</strong>: 异常通知, 在方法抛出异常之后</li>
<li><strong>@Around</strong>: 环绕通知, 围绕着方法执行</li>
</ul>
<p>以上5种类型的通知注解的值可以为 <strong><em>@annotation</em></strong>表示标注了某个注解的所有方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span></span><br></pre></td></tr></table></figure>

<p>执行的顺序如下：</p>
<p><strong>正常情况：</strong><br><img src="https://img-blog.csdn.net/20160811192425854" alt="one-ok"></p>
<hr>
<p><strong>异常情况：</strong><br><img src="https://img-blog.csdn.net/20160811192446479" alt="one-exception"></p>
<h3><span id="joinpoint">JoinPoint</span></h3><p>JoinPoint 对象封装了 SpringAop 中<strong>切面方法的信息</strong>，在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    String dsId = ds.value();</span><br><span class="line">    <span class="keyword">if</span>(DynamicDataSourceContextHolder.dataSourceIds.contains(dsId))&#123;</span><br><span class="line">        <span class="comment">//当日志级别为 debug 时输出</span></span><br><span class="line">        <span class="comment">//point.getSignature() 获取切入点的方法名</span></span><br><span class="line">        logger.debug(<span class="string">"Use DataSourceKey :&#123;&#125; &gt;"</span>, dsId, point.getSignature());</span><br><span class="line">        <span class="comment">//设置数据源的 key</span></span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceRouterKey(dsId);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//point.getSignature() 获取切入点的方法名</span></span><br><span class="line">        logger.info(<span class="string">"数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&#123;&#125;"</span>, dsId, point.getSignature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="logger">Logger</span></h2><p>在编程中尽量用 Logger(org.slf4j.Logger) 来输出信息，避免使用 sout</p>
<p>因为 Logger 提供了 5 种日志级别的输出：</p>
<ol>
<li><strong>error</strong></li>
<li><strong>warn</strong></li>
<li><strong>info</strong></li>
<li><strong>debug</strong></li>
<li><strong>trace</strong></li>
</ol>
<p>可在 application.yml 等配置日志输出级别，实现输出不同级别的日志信息按照需求输出，不像 sout 无法控制</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    String dsId = ds.value();</span><br><span class="line">    <span class="keyword">if</span>(DynamicDataSourceContextHolder.dataSourceIds.contains(dsId))&#123;</span><br><span class="line">        logger.debug(<span class="string">"Use DataSourceKey :&#123;&#125; &gt;"</span>, dsId, point.getSignature());</span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceRouterKey(dsId);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&#123;&#125;"</span>, dsId, point.getSignature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"@annotation(ds)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreDataSource</span><span class="params">(JoinPoint point, DataSourceKey ds)</span></span>&#123;</span><br><span class="line">    logger.debug(<span class="string">"Revert DataSourceKey : "</span> + ds.value() + <span class="string">" &gt; "</span> + point.getSignature());</span><br><span class="line">    <span class="comment">//移除 ThreadLocalMap 中存储的 ThreadLocal对象和值，避免内存溢出</span></span><br><span class="line">    DynamicDataSourceContextHolder.removeDataSourceRouterKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个输出级别：debug 和 info</p>
<p>当在 application.yml 中配置 logging.level.root=info 时，info级别的日志得到输出，debug同理</p>
<p><img src="https://img-blog.csdnimg.cn/20200306232559114.png" alt="image-20200306154105726"></p>
<h2><span id="datasourcebuilder">DataSourceBuilder</span></h2><p>示例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">customize.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/blue?serverTimezone=UTC</span></span><br><span class="line"><span class="meta">customize.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">customize.datasource.password</span>=<span class="string">wan4380797</span></span><br><span class="line"><span class="meta">customize.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp2.BasicDataSource;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2DataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"myDbcp2DataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"customize.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().type(BasicDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="binder">Binder</span></h2><p>对于 Binder，只要会用就差不多了，等功力达到以后再深入源码</p>
<blockquote>
<h3><span id="示例1-简单类型">示例1 简单类型</span></h3></blockquote>
<p>假设在propertes配置中有这样一个配置：<code>com.didispace.foo=bar</code></p>
<p>我们为它创建对应的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"com.didispace"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String foo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，通过最新的<code>Binder</code>就可以这样来拿配置信息了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Binder binder = Binder.get(context.getEnvironment());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定简单配置</span></span><br><span class="line">        FooProperties foo = binder.bind(<span class="string">"com.didispace"</span>, Bindable.of(FooProperties<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">        System.out.println(foo.getFoo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3><span id="示例2-list类型">示例2 List类型</span></h3></blockquote>
<p>如果配置内容是List类型呢？比如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">com.didispace.post[0]</span>=<span class="string">Why Spring Boot</span></span><br><span class="line"><span class="meta">com.didispace.post[1]</span>=<span class="string">Why Spring Cloud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">com.didispace.posts[0].title</span>=<span class="string">Why Spring Boot</span></span><br><span class="line"><span class="meta">com.didispace.posts[0].content</span>=<span class="string">It is perfect!</span></span><br><span class="line"><span class="meta">com.didispace.posts[1].title</span>=<span class="string">Why Spring Cloud</span></span><br><span class="line"><span class="meta">com.didispace.posts[1].content</span>=<span class="string">It is perfect too!</span></span><br></pre></td></tr></table></figure>

<p>要获取这些配置依然很简单，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">Binder binder = Binder.get(context.getEnvironment());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定List配置</span></span><br><span class="line">List&lt;String&gt; post = binder.bind(<span class="string">"com.didispace.post"</span>, Bindable.listOf(String<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">System.out.println(post);</span><br><span class="line"></span><br><span class="line">List&lt;PostInfo&gt; posts = binder.bind(<span class="string">"com.didispace.posts"</span>, Bindable.listOf(PostInfo<span class="class">.<span class="keyword">class</span>)).<span class="title">get</span>()</span>;</span><br><span class="line">System.out.println(posts)</span><br></pre></td></tr></table></figure>

<h3><span id="源码">源码</span></h3><p>里面 bind() 方法有许多重载，重点关注这个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">    Assert.notNull(target, <span class="string">"Target must not be null"</span>);</span><br><span class="line">    handler = handler != <span class="keyword">null</span> ? handler : <span class="keyword">this</span>.defaultBindHandler;</span><br><span class="line">    Binder.Context context = <span class="keyword">new</span> Binder.Context();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bind(name, target, handler, context, <span class="keyword">false</span>, create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还不是真正的绑定阶段，但有两个点需要说明：</p>
<ul>
<li>参数<strong>ConfigurationPropertyName</strong>：是对前面传入的配置前缀 prefix 进行一些基本校验和处理</li>
<li>返回值<strong>BindResult</strong>：里面有<code>of()</code>, <code>get()</code>, <code>isBound()</code>, <code>orElse()</code>等</li>
<li><strong>Context</strong>：在这里是绑定上下文, 由前面说过的<code>BindHandler</code>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BindContext</span> </span>&#123;</span><br><span class="line">    <span class="function">Binder <span class="title">getBinder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterable&lt;ConfigurationPropertySource&gt; <span class="title">getSources</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConfigurationProperty <span class="title">getConfigurationProperty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着代码往下，看 Binder 中的下一个bind() 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">    context.clearConfigurationProperty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bindable&lt;T&gt; replacementTarget = handler.onStart(name, target, context);</span><br><span class="line">        <span class="keyword">if</span> (replacementTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleBindResult(name, target, handler, context, (Object)<span class="keyword">null</span>, create);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object bound = <span class="keyword">this</span>.bindObject(name, replacementTarget, handler, context, allowRecursiveBinding);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleBindResult(name, replacementTarget, handler, context, bound, create);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handleBindError(name, target, handler, context, var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>留意 onStart ，这里就有一个 BindHandler 回调接口中的一个方法，也就是绑定的开始但还未完成阶段</p>
<p>接下来在<code>Binder</code>中, 会陆续看到其它几个阶段的方法</p>
<p>再来看返回, 是通过<code>handleBindResult()</code>和<code>handleBindError()</code>来处理的.</p>
<p>点开这两个handleBindXXX()能看到在里面进行了onSuccess, onFinish, onFailure的调用</p>
<ul>
<li>handleBindResult() 源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">handleBindResult</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, Object result, <span class="keyword">boolean</span> create)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = handler.onSuccess(name, target, context, result);</span><br><span class="line">        result = context.getConverter().convert(result, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; create) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.create(target, context);</span><br><span class="line">        result = handler.onCreate(name, target, context, result);</span><br><span class="line">        result = context.getConverter().convert(result, target);</span><br><span class="line">        Assert.state(result != <span class="keyword">null</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unable to create instance for "</span> + target.getType();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler.onFinish(name, target, context, result);</span><br><span class="line">    <span class="keyword">return</span> context.getConverter().convert(result, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>handleBindError() 源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">handleBindError</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, Exception error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object result = handler.onFailure(name, target, context, error);</span><br><span class="line">        <span class="keyword">return</span> context.getConverter().convert(result, target);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var7 <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BindException)var7;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindException(name, target, context.getConfigurationProperty(), var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来看 <strong><em>bindObject()</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Object <span class="title">bindObject</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">    ConfigurationProperty property = <span class="keyword">this</span>.findProperty(name, context);</span><br><span class="line">    <span class="keyword">if</span> (property == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsNoDescendantOf(context.getSources(), name) &amp;&amp; context.depth != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AggregateBinder&lt;?&gt; aggregateBinder = <span class="keyword">this</span>.getAggregateBinder(target, context);</span><br><span class="line">        <span class="keyword">if</span> (aggregateBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bindAggregate(name, target, handler, context, aggregateBinder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.bindProperty(target, context, property);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConverterNotFoundException var10) &#123;</span><br><span class="line">                Object instance = <span class="keyword">this</span>.bindDataObject(name, target, handler, context, allowRecursiveBinding);</span><br><span class="line">                <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bindDataObject(name, target, handler, context, allowRecursiveBinding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里过程比较多，可以分为 2 个部分</p>
<p><strong>Part1</strong>：寻找属性和匹配的过程</p>
<p>开头的<code>findProperty()</code>和一个匹配方法:<code>containsNoDescendantOf()</code>, 它们的参数都有<code>context</code></p>
<p>上面说过了–&gt;提供绑定的上下文信息</p>
<p><strong>Part2</strong>：绑定过程</p>
<p>接下来是 bindXXX 这三个私有方法：</p>
<ul>
<li><p><code>bindAggregate()</code>: 从注释上看出, 主要是负责处理Map, Collections, Array的绑定策略, 及完成多层属性的递归</p>
</li>
<li><p><code>bindProperty()</code>: 是返回属性值的过程(其中包含类型转换)</p>
<p>例如属性资源文件中配置的<code>name=thank</code> -&gt; <code>java.lang.String thank</code></p>
</li>
<li><p><code>bindBean()</code>: 会继续调用另外一个私有的重载函数<code>bindBean()</code></p>
</li>
</ul>
<p>重点看看这个方法 — bindDataObject()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">bindDataObject</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target, BindHandler handler, Binder.Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isUnbindableBean(name, target, context)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; type = target.getType().resolve(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!allowRecursiveBinding &amp;&amp; context.isBindingDataObject(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DataObjectPropertyBinder propertyBinder = (propertyName, propertyTarget) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.bind(name.append(propertyName), propertyTarget, handler, context, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> context.withDataObject(type, () -&gt; &#123;</span><br><span class="line">                Iterator var5 = <span class="keyword">this</span>.dataObjectBinders.iterator();</span><br><span class="line"></span><br><span class="line">                Object instance;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!var5.hasNext()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DataObjectBinder dataObjectBinder = (DataObjectBinder)var5.next();</span><br><span class="line">                    instance = dataObjectBinder.bind(name, target, context, propertyBinder);</span><br><span class="line">                &#125; <span class="keyword">while</span>(instance == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面又调用了上层的<code>Binder.bind()</code>, 递归完成绑定</p>
<p>终止条件是上面提到过的<code>containsNoDescendantOf()</code>和另外一个判断<code>isUnbindableBean()</code></p>
<p>关注一下最终的返回结果, 是调用了另外一个类: <code>JavaBeanBinder</code>的<code>bind</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;BeanBinder&gt; BEAN_BINDERS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        List&lt;BeanBinder&gt; binders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        binders.add(<span class="keyword">new</span> JavaBeanBinder());</span><br><span class="line">        BEAN_BINDERS = Collections.unmodifiableList(binders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="bind">bind()</span></h5><p>进入<code>JavaBeanBinder#bind()</code>之后看到继续调用了另一个私有的重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">bind</span><span class="params">(BeanPropertyBinder propertyBinder, Bean&lt;T&gt; bean, BeanSupplier&lt;T&gt; beanSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BeanProperty&gt; entry : bean.getProperties().entrySet()) &#123;</span><br><span class="line">        bound |= bind(beanSupplier, propertyBinder, entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面会迭代该配置bean中的所有属性, 调试模式下随便取一个来看看:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">0 = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7470</span>&#125; <span class="string">"name"</span> -&gt; </span><br><span class="line">  key = <span class="string">"name"</span></span><br><span class="line">  value = &#123;JavaBeanBinder<span class="variable">$BeanProperty</span><span class="variable">@7475</span>&#125; </span><br><span class="line">    name = <span class="string">"name"</span></span><br><span class="line">    declaringClassType = &#123;ResolvableType<span class="variable">@7481</span>&#125; <span class="string">"com.example.cache.config.CustomProperties"</span></span><br><span class="line">    getter = &#123;Method<span class="variable">@7482</span>&#125; <span class="string">"public java.lang.String com.example.cache.config.CustomProperties.getName()"</span></span><br><span class="line">    setter = &#123;Method<span class="variable">@7483</span>&#125; <span class="string">"public void com.example.cache.config.CustomProperties.setName(java.lang.String)"</span></span><br><span class="line">    field = &#123;Field<span class="variable">@7484</span>&#125; <span class="string">"private java.lang.String com.example.cache.config.CustomProperties.name"</span></span><br><span class="line"><span class="number">1</span> = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7471</span>&#125; <span class="string">"age"</span> -&gt; </span><br><span class="line"><span class="number">2</span> = &#123;LinkedHashMap<span class="variable">$Entry</span><span class="variable">@7472</span>&#125; <span class="string">"email"</span> -&gt;</span><br></pre></td></tr></table></figure>

<p>没错, 配置bean中: 的属性名, Setter和Getter 该有的都有了</p>
<p>下面来到<code>JavaBeanBinder</code>的最后一个重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">bind</span><span class="params">(BeanSupplier&lt;T&gt; beanSupplier, </span></span></span><br><span class="line"><span class="function"><span class="params">                         BeanPropertyBinder propertyBinder, BeanProperty property)</span> </span>&#123;</span><br><span class="line">    String propertyName = property.getName();</span><br><span class="line">    ResolvableType type = property.getType();</span><br><span class="line">    Supplier&lt;Object&gt; value = property.getValue(beanSupplier);</span><br><span class="line">    Annotation[] annotations = property.getAnnotations();</span><br><span class="line">    Object bound = propertyBinder.bindProperty(</span><br><span class="line">        propertyName, Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (bound == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (property.isSettable()) &#123;</span><br><span class="line">        property.setValue(beanSupplier, bound);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="keyword">null</span> || !bound.equals(value.get())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No setter found for property: "</span> + property.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就比较简单了, 分步拿到了配置Bean属性的定义和值:</p>
<ul>
<li><p>field: 即propertyName, e.g. <code>name</code></p>
</li>
<li><p>属性类型: type, e.g. <code>java.lang.String</code></p>
</li>
<li><p>getter and setter</p>
<p>e.g.<code>public void com.example.cache.config.CustomProperties.setName(java.lang.String)</code></p>
</li>
<li><p>以及调用<code>propertyBinder.bindProperty()</code>拿到了资源属性文件中的属性值<code>bound</code></p>
<p>该方法的作用前面也提到过(e.g. <code>thank</code> )</p>
</li>
</ul>
<p>然后调用了属性的<code>setValue()</code>方法: 执行<code>property.setValue(beanSupplier, bound);</code></p>
<p>至此, 看到了调用属性的set方法, 终于可以放心了!</p>
<p>从<code>ConfigurationPropertiesBindingPostProcessor</code>开始到调用setter结束, 完整的调用栈如下:</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">bind:85, JavaBeanBinder &#123;<span class="attribute">org.springframework.boot.context.properties.bind&#125;</span></span><br><span class="line"><span class="attribute">bind</span>:62, JavaBeanBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:54, JavaBeanBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">lambda$null$5:341, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">apply:-1, 1445225850 &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span><span class="variable">.Binder</span>$$Lambda$267&#125;</span><br><span class="line">accept:193, ReferencePipeline$3$1 &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">tryAdvance:1351, ArrayList$ArrayListSpliterator &#123;java<span class="variable">.util</span>&#125;</span><br><span class="line">forEachWithCancel:126, ReferencePipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">copyIntoWithCancel:498, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">copyInto:485, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">wrapAndCopyInto:471, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">evaluateSequential:152, FindOps$FindOp &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">evaluate:234, AbstractPipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">findFirst:464, ReferencePipeline &#123;java<span class="variable">.util</span><span class="variable">.stream</span>&#125;</span><br><span class="line">lambda$bindBean$6:342, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">get:-1, 2008619427 &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span><span class="variable">.Binder</span>$$Lambda$266&#125;</span><br><span class="line">withIncreasedDepth:441, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">withBean:427, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">access$400:381, Binder$Context &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bindBean:339, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bindObject:278, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:221, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:210, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:192, Binder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span><span class="variable">.bind</span>&#125;</span><br><span class="line">bind:82, ConfigurationPropertiesBinder &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br><span class="line">bind:107, ConfigurationPropertiesBindingPostProcessor &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br><span class="line">postProcessBeforeInitialization:93, ConfigurationPropertiesBindingPostProcessor &#123;org<span class="variable">.springframework</span><span class="variable">.boot</span><span class="variable">.context</span><span class="variable">.properties</span>&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="import">@Import</span></h2><p>参考：</p>
<p><a href="https://blog.csdn.net/pange1991/article/details/81356594" target="_blank" rel="noopener">Spring @Import注解 —— 导入资源</a></p>
<p><a href="https://blog.csdn.net/tuoni123/article/details/80213050" target="_blank" rel="noopener">SpringBoot @Import 详解</a></p>
<p><a href="https://juejin.im/post/5c761c096fb9a049b41d2299" target="_blank" rel="noopener">Spring Boot 自动配置之@Enable* 与@Import注解</a></p>
<p>SpringBoot 的 @Import 用于将指定的类示例注入到 Spring IOC Container 中。</p>
<p>提供了三种方法：</p>
<ul>
<li>直接注入(@Import)</li>
<li>实现 ImportBeanDefinitionRegistrar 接口 注入</li>
<li>实现 ImportSelector 注入</li>
</ul>
<h2><span id="流程图">流程图</span></h2><p><img src="https://img-blog.csdnimg.cn/20200307165337725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pa2VsdjAx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>多数据源</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之BeanDefinitionRegistry</title>
    <url>/2020/03/04/Spring%E4%B9%8BBeanDefinitionRegistry/</url>
    <content><![CDATA[<p>Spring 的 Bean 是以 BeanDefinition 的形式存在的</p>
<h2><span id="beandefinitionregistry-源码"><em>BeanDefinitionRegistry 源码</em></span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否存在 BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition 名称</span></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 BeanDefinition 的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bean 的名字是否被使用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>BeanDefinitionRegistry 是 BeanDefnition 的注册中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父子关系</span></span><br><span class="line">BeanDefinitionRegistry</span><br><span class="line">|</span><br><span class="line">--- SimpleBeanDefinitionRegistry</span><br><span class="line">|</span><br><span class="line">--- DefaultListableBeanFactory(核心)</span><br><span class="line">|</span><br><span class="line">--- GenericApplicationContext(核心)</span><br></pre></td></tr></table></figure>

<h2><span id="simplebeandefinitionregistry-源码"><em>SimpleBeanDefinitionRegistry 源码</em></span></h2><p>SimpleBeanDefinitionRegistry 的源码看起来比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.hasText(beanName, <span class="string">"'beanName' must not be empty"</span>);</span><br><span class="line">        Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanDefinitionMap.remove(beanName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAlias(beanName) || containsBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="defaultlistablebeanfactory-源码"><em>DefaultListableBeanFactory 源码</em></span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; javaxInjectProviderClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaxInjectProviderClass =</span><br><span class="line">                ClassUtils.forName(<span class="string">"javax.inject.Provider"</span>, DefaultListableBeanFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// JSR-330 API not available - Provider interface simply not supported then.</span></span><br><span class="line">            javaxInjectProviderClass = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map from serialized id to factory instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Optional id for this factory, for serialization purposes. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> String serializationId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether to allow re-registration of a different definition with the same name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowBeanDefinitionOverriding = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether to allow eager class loading even for lazy-init beans. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowEagerClassLoading = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Optional OrderComparator for dependency Lists and arrays. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;Object&gt; dependencyComparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resolver to use for checking if a bean definition is an autowire candidate. */</span></span><br><span class="line">    <span class="keyword">private</span> AutowireCandidateResolver autowireCandidateResolver = <span class="keyword">new</span> SimpleAutowireCandidateResolver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map from dependency type to corresponding autowired value. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of singleton and non-singleton bean names, keyed by dependency type. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map of singleton-only bean names, keyed by dependency type. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of bean definition names, in registration order. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of names of manually registered singletons, in registration order. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cached array of bean definition names in case of frozen configuration. */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String[] frozenBeanDefinitionNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether bean definition metadata may be cached for all beans. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> configurationFrozen = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new DefaultListableBeanFactory with the given parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parentBeanFactory the parent BeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Specify an id for serialization purposes, allowing this BeanFactory to be</span></span><br><span class="line"><span class="comment">	 * deserialized from this id back into the BeanFactory object, if needed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSerializationId</span><span class="params">(@Nullable String serializationId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            serializableFactories.put(serializationId, <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            serializableFactories.remove(<span class="keyword">this</span>.serializationId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.serializationId = serializationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an id for serialization purposes, if specified, allowing this BeanFactory</span></span><br><span class="line"><span class="comment">	 * to be deserialized from this id back into the BeanFactory object, if needed.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSerializationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serializationId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * If not, an exception will be thrown. This also applies to overriding aliases.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowBeanDefinitionOverriding</span><span class="params">(<span class="keyword">boolean</span> allowBeanDefinitionOverriding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowBeanDefinitionOverriding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowBeanDefinitionOverriding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether the factory is allowed to eagerly load bean classes</span></span><br><span class="line"><span class="comment">	 * even for bean definitions that are marked as "lazy-init".</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true". Turn this flag off to suppress class loading</span></span><br><span class="line"><span class="comment">	 * for lazy-init beans unless such a bean is explicitly requested.</span></span><br><span class="line"><span class="comment">	 * In particular, by-type lookups will then simply ignore bean definitions</span></span><br><span class="line"><span class="comment">	 * without resolved class name, instead of loading the bean classes on</span></span><br><span class="line"><span class="comment">	 * demand just to perform a type check.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> AbstractBeanDefinition#setLazyInit</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowEagerClassLoading</span><span class="params">(<span class="keyword">boolean</span> allowEagerClassLoading)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allowEagerClassLoading = allowEagerClassLoading;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether the factory is allowed to eagerly load bean classes</span></span><br><span class="line"><span class="comment">	 * even for bean definitions that are marked as "lazy-init".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.1.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowEagerClassLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowEagerClassLoading;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a &#123;<span class="doctag">@link</span> java.util.Comparator&#125; for dependency Lists and arrays.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.OrderComparator</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.annotation.AnnotationAwareOrderComparator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependencyComparator</span><span class="params">(@Nullable Comparator&lt;Object&gt; dependencyComparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependencyComparator = dependencyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the dependency comparator for this BeanFactory (may be &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparator&lt;Object&gt; <span class="title">getDependencyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dependencyComparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a custom autowire candidate resolver for this BeanFactory to use</span></span><br><span class="line"><span class="comment">	 * when deciding whether a bean definition should be considered as a</span></span><br><span class="line"><span class="comment">	 * candidate for autowiring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutowireCandidateResolver</span><span class="params">(<span class="keyword">final</span> AutowireCandidateResolver autowireCandidateResolver)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(autowireCandidateResolver, <span class="string">"AutowireCandidateResolver must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (autowireCandidateResolver <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(DefaultListableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.autowireCandidateResolver = autowireCandidateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the autowire candidate resolver for this BeanFactory (never &#123;<span class="doctag">@code</span> null&#125;).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AutowireCandidateResolver <span class="title">getAutowireCandidateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autowireCandidateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyConfigurationFrom</span><span class="params">(ConfigurableBeanFactory otherFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.copyConfigurationFrom(otherFactory);</span><br><span class="line">        <span class="keyword">if</span> (otherFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            DefaultListableBeanFactory otherListableFactory = (DefaultListableBeanFactory) otherFactory;</span><br><span class="line">            <span class="keyword">this</span>.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;</span><br><span class="line">            <span class="keyword">this</span>.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;</span><br><span class="line">            <span class="keyword">this</span>.dependencyComparator = otherListableFactory.dependencyComparator;</span><br><span class="line">            <span class="comment">// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware...</span></span><br><span class="line">            setAutowireCandidateResolver(BeanUtils.instantiateClass(getAutowireCandidateResolver().getClass()));</span><br><span class="line">            <span class="comment">// Make resolvable dependencies (e.g. ResourceLoader) available here as well...</span></span><br><span class="line">            <span class="keyword">this</span>.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of remaining BeanFactory methods</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBean(requiredType, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, @Nullable Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) resolved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanProvider(ResolvableType.forRawClass(requiredType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanObjectProvider&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                T resolved = resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resolved;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                T resolved = resolveBean(requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resolved;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> resolveBean(requiredType, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.stream(getBeanNamesForTypedStream(requiredType))</span><br><span class="line">                    .map(name -&gt; (T) getBean(name))</span><br><span class="line">                    .filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Stream&lt;T&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String[] beanNames = getBeanNamesForTypedStream(requiredType);</span><br><span class="line">                Map&lt;String, T&gt; matchingBeans = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    Object beanInstance = getBean(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                        matchingBeans.put(beanName, (T) beanInstance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Stream&lt;T&gt; stream = matchingBeans.values().stream();</span><br><span class="line">                <span class="keyword">return</span> stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">resolveBean</span><span class="params">(ResolvableType requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> </span>&#123;</span><br><span class="line">        NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">        <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> namedBean.getBeanInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((DefaultListableBeanFactory) parent).resolveBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ObjectProvider&lt;T&gt; parentProvider = parent.getBeanProvider(requiredType);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> parentProvider.getObject(args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] getBeanNamesForTypedStream(ResolvableType requiredType) &#123;</span><br><span class="line">        <span class="keyword">return</span> BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of ListableBeanFactory interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        String[] frozenNames = <span class="keyword">this</span>.frozenBeanDefinitionNames;</span><br><span class="line">        <span class="keyword">if</span> (frozenNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> frozenNames.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(ResolvableType type) &#123;</span><br><span class="line">        Class&lt;?&gt; resolved = type.resolve();</span><br><span class="line">        <span class="keyword">if</span> (resolved != <span class="keyword">null</span> &amp;&amp; !type.hasGenerics()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getBeanNamesForType(resolved, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doGetBeanNamesForType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanNamesForType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isConfigurationFrozen() || type == <span class="keyword">null</span> || !allowEagerInit) &#123;</span><br><span class="line">            <span class="keyword">return</span> doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, String[]&gt; cache =</span><br><span class="line">            (includeNonSingletons ? <span class="keyword">this</span>.allBeanNamesByType : <span class="keyword">this</span>.singletonBeanNamesByType);</span><br><span class="line">        String[] resolvedBeanNames = cache.get(type);</span><br><span class="line">        <span class="keyword">if</span> (resolvedBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">        &#125;</span><br><span class="line">        resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCacheSafe(type, getBeanClassLoader())) &#123;</span><br><span class="line">            cache.put(type, resolvedBeanNames);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] doGetBeanNamesForType(ResolvableType type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check all bean definitions.</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            <span class="comment">// Only consider bean as eligible if the bean name</span></span><br><span class="line">            <span class="comment">// is not defined as alias for some other bean.</span></span><br><span class="line">            <span class="keyword">if</span> (!isAlias(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                    <span class="comment">// Only check bean definition if it is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">                                              (mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">                                              !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">                        <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">                        <span class="keyword">boolean</span> isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">                        BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">                        <span class="keyword">boolean</span> matchFound =</span><br><span class="line">                            (allowEagerInit || !isFactoryBean ||</span><br><span class="line">                             (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">                            (includeNonSingletons ||</span><br><span class="line">                             (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">                            isTypeMatch(beanName, type);</span><br><span class="line">                        <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">                            <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line">                            beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">                            matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">                            result.add(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (CannotLoadBeanClassException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (allowEagerInit) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Probably a class name with a placeholder: let's ignore it for type matching purposes.</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignoring bean class loading failure for bean '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    onSuppressedException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (allowEagerInit) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Probably some metadata with a placeholder: let's ignore it for type matching purposes.</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignoring unresolvable metadata in bean definition '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    onSuppressedException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check manually registered singletons too.</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.manualSingletonNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((includeNonSingletons || isSingleton(beanName)) &amp;&amp; isTypeMatch(beanName, type)) &#123;</span><br><span class="line">                        result.add(beanName);</span><br><span class="line">                        <span class="comment">// Match found for this bean: do not match FactoryBean itself anymore.</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// In case of FactoryBean, try to match FactoryBean itself next.</span></span><br><span class="line">                    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Match raw bean instance (might be raw FactoryBean).</span></span><br><span class="line">                <span class="keyword">if</span> (isTypeMatch(beanName, type)) &#123;</span><br><span class="line">                    result.add(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                <span class="comment">// Shouldn't happen - probably a result of circular reference resolution...</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Failed to check manually registered singleton with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether the specified bean would need to be eagerly initialized</span></span><br><span class="line"><span class="comment">	 * in order to determine its type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> factoryBeanName a factory-bean reference that the bean definition</span></span><br><span class="line"><span class="comment">	 * defines a factory method for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether eager initialization is necessary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requiresEagerInitForType</span><span class="params">(@Nullable String factoryBeanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (factoryBeanName != <span class="keyword">null</span> &amp;&amp; isFactoryBean(factoryBeanName) &amp;&amp; !containsSingleton(factoryBeanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBeansOfType(type, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">        Map&lt;String, T&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object beanInstance = getBean(beanName);</span><br><span class="line">                <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                    result.put(beanName, (T) beanInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">                <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                    BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">                    String exBeanName = bce.getBeanName();</span><br><span class="line">                    <span class="keyword">if</span> (exBeanName != <span class="keyword">null</span> &amp;&amp; isCurrentlyInCreation(exBeanName)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                            logger.trace(<span class="string">"Ignoring match to currently created bean '"</span> + exBeanName + <span class="string">"': "</span> +</span><br><span class="line">                                         ex.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        onSuppressedException(ex);</span><br><span class="line">                        <span class="comment">// Ignore: indicates a circular reference when autowiring constructors.</span></span><br><span class="line">                        <span class="comment">// We want to find matches other than the currently created bean itself.</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!beanDefinition.isAbstract() &amp;&amp; findAnnotationOnBean(beanName, annotationType) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.manualSingletonNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.contains(beanName) &amp;&amp; findAnnotationOnBean(beanName, annotationType) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">        String[] beanNames = getBeanNamesForAnnotation(annotationType);</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            Object beanInstance = getBean(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                result.put(beanName, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Find a &#123;<span class="doctag">@link</span> Annotation&#125; of &#123;<span class="doctag">@code</span> annotationType&#125; on the specified</span></span><br><span class="line"><span class="comment">	 * bean, traversing its interfaces and super classes if no annotation can be</span></span><br><span class="line"><span class="comment">	 * found on the given class itself, as well as checking its raw bean class</span></span><br><span class="line"><span class="comment">	 * if not found on the exposed bean reference (e.g. in case of a proxy).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        A ann = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; beanType = getType(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ann = AnnotationUtils.findAnnotation(beanType, annotationType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ann == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            BeanDefinition bd = getMergedBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                AbstractBeanDefinition abd = (AbstractBeanDefinition) bd;</span><br><span class="line">                <span class="keyword">if</span> (abd.hasBeanClass()) &#123;</span><br><span class="line">                    Class&lt;?&gt; beanClass = abd.getBeanClass();</span><br><span class="line">                    <span class="keyword">if</span> (beanClass != beanType) &#123;</span><br><span class="line">                        ann = AnnotationUtils.findAnnotation(beanClass, annotationType);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ann;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of ConfigurableListableBeanFactory interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerResolvableDependency</span><span class="params">(Class&lt;?&gt; dependencyType, @Nullable Object autowiredValue)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(dependencyType, <span class="string">"Dependency type must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (autowiredValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(autowiredValue <span class="keyword">instanceof</span> ObjectFactory || dependencyType.isInstance(autowiredValue))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Value ["</span> + autowiredValue +</span><br><span class="line">                                                   <span class="string">"] does not implement specified dependency type ["</span> + dependencyType.getName() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.resolvableDependencies.put(dependencyType, autowiredValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, DependencyDescriptor descriptor)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span></span><br><span class="line"><span class="comment">	 * to be injected into other beans which declare a dependency of matching type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the bean should be considered as autowire candidate</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">        <span class="keyword">if</span> (containsBeanDefinition(beanDefinitionName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isAutowireCandidate(beanName, <span class="keyword">new</span> RootBeanDefinition(getType(beanName)), descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            <span class="comment">// No bean definition found in this factory -&gt; delegate to parent.</span></span><br><span class="line">            <span class="keyword">return</span> ((DefaultListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            <span class="comment">// If no DefaultListableBeanFactory, can't pass the resolver along.</span></span><br><span class="line">            <span class="keyword">return</span> ((ConfigurableListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span></span><br><span class="line"><span class="comment">	 * to be injected into other beans which declare a dependency of matching type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mbd the merged bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the bean should be considered as autowire candidate</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">        resolveBeanClass(mbd, beanDefinitionName);</span><br><span class="line">        <span class="keyword">if</span> (mbd.isFactoryMethodUnique &amp;&amp; mbd.factoryMethodToIntrospect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).resolveFactoryMethodIfPossible(mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolver.isAutowireCandidate(</span><br><span class="line">            <span class="keyword">new</span> BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">getBeanNamesIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompositeIterator&lt;String&gt; iterator = <span class="keyword">new</span> CompositeIterator&lt;&gt;();</span><br><span class="line">        iterator.add(<span class="keyword">this</span>.beanDefinitionNames.iterator());</span><br><span class="line">        iterator.add(<span class="keyword">this</span>.manualSingletonNames.iterator());</span><br><span class="line">        <span class="keyword">return</span> iterator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMetadataCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clearMetadataCache();</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configurationFrozen = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConfigurationFrozen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configurationFrozen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Considers all beans as eligible for metadata caching</span></span><br><span class="line"><span class="comment">	 * if the factory's configuration has been marked as frozen.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #freezeConfiguration()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isBeanEligibleForMetadataCaching</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.configurationFrozen || <span class="keyword">super</span>.isBeanEligibleForMetadataCaching(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">        <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                        <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                        <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                                        ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                                        getAccessControlContext());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                           ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                            getBean(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            Object singletonInstance = getSingleton(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">                <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of BeanDefinitionRegistry interface</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">        Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                       <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">                <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                                <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                                existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                                 <span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                                 <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                                 <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                                 <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">                <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                    List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                    updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                    updatedDefinitions.add(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                        Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                        updatedSingletons.remove(beanName);</span><br><span class="line">                        <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Still in startup registration phase</span></span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">            resetBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        Assert.hasText(beanName, <span class="string">"'beanName' must not be empty"</span>);</span><br><span class="line"></span><br><span class="line">        BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.remove(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.remove(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset all bean definition caches for the given bean,</span></span><br><span class="line"><span class="comment">	 * including the caches of beans that are derived from it.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Called after an existing bean definition has been replaced or removed,</span></span><br><span class="line"><span class="comment">	 * triggering &#123;<span class="doctag">@link</span> #clearMergedBeanDefinition&#125;, &#123;<span class="doctag">@link</span> #destroySingleton&#125;</span></span><br><span class="line"><span class="comment">	 * and &#123;<span class="doctag">@link</span> MergedBeanDefinitionPostProcessor#resetBeanDefinition&#125; on the</span></span><br><span class="line"><span class="comment">	 * given bean and on all bean definitions that have the given bean as parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean to reset</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #removeBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove the merged bean definition for the given bean, if already created.</span></span><br><span class="line">        clearMergedBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove corresponding bean from singleton cache, if any. Shouldn't usually</span></span><br><span class="line">        <span class="comment">// be necessary, rather just meant for overriding a context's default beans</span></span><br><span class="line">        <span class="comment">// (e.g. the default StaticMessageSource in a StaticApplicationContext).</span></span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify all post-processors that the specified bean definition has been reset.</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processor <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset all bean definitions that have the given bean as parent (recursively).</span></span><br><span class="line">        <span class="keyword">for</span> (String bdName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beanName.equals(bdName)) &#123;</span><br><span class="line">                BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(bdName);</span><br><span class="line">                <span class="keyword">if</span> (beanName.equals(bd.getParentName())) &#123;</span><br><span class="line">                    resetBeanDefinition(bdName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Only allows alias overriding if bean definition overriding is allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">allowAliasOverriding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAllowBeanDefinitionOverriding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.registerSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames.size() + <span class="number">1</span>);</span><br><span class="line">                    updatedSingletons.addAll(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.add(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.manualSingletonNames.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroySingletons();</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames.clear();</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Remove any assumptions about by-type mappings.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearByTypeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allBeanNamesByType.clear();</span><br><span class="line">        <span class="keyword">this</span>.singletonBeanNamesByType.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Dependency resolution functionality</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> namedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AutowireCapableBeanFactory) parent).resolveNamedBean(requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ResolvableType requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(requiredType, <span class="string">"Required type must not be null"</span>);</span><br><span class="line">        String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateNames.length);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">                    autowireCandidates.add(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">                candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">            String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object beanInstance = getBean(beanName);</span><br><span class="line">                    candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    candidates.put(beanName, getType(beanName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line">            <span class="keyword">if</span> (candidateName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidateName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object beanInstance = candidates.get(candidateName);</span><br><span class="line">                <span class="keyword">if</span> (beanInstance == <span class="keyword">null</span> || beanInstance <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!nonUniqueAsNull) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">        <span class="keyword">if</span> (Optional<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType() ||</span><br><span class="line">                 ObjectProvider<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">                descriptor, requestingBeanName);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> shortcut;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">            Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">                    BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">                                         getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">                    value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">                &#125;</span><br><span class="line">                TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">                    <span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">                    <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">                            converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                            converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">            <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> multipleBeans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String autowiredBeanName;</span><br><span class="line">            Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">                <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">                        <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">                        <span class="comment">// (before 4.3 in particular when we didn't even look for collection beans).</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We have exactly one match.</span></span><br><span class="line">                Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">                autowiredBeanName = entry.getKey();</span><br><span class="line">                instanceCandidate = entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result = instanceCandidate;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">                &#125;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            Stream&lt;Object&gt; stream = matchingBeans.keySet().stream()</span><br><span class="line">                .map(name -&gt; descriptor.resolveCandidate(name, type, <span class="keyword">this</span>))</span><br><span class="line">                .filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">            <span class="keyword">if</span> (((StreamDependencyDescriptor) descriptor).isOrdered()) &#123;</span><br><span class="line">                stream = stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = type.getComponentType();</span><br><span class="line">            ResolvableType resolvableType = descriptor.getResolvableType();</span><br><span class="line">            Class&lt;?&gt; resolvedArrayType = resolvableType.resolve(type);</span><br><span class="line">            <span class="keyword">if</span> (resolvedArrayType != type) &#123;</span><br><span class="line">                componentType = resolvableType.getComponentType().resolve();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (componentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">                Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">                <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Arrays.sort((Object[]) result, comparator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) &amp;&amp; <span class="title">type</span>.<span class="title">isInterface</span>()) </span>&#123;</span><br><span class="line">            Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</span><br><span class="line">            <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            Object result = converter.convertIfNecessary(matchingBeans.values(), type);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">                Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">                <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ((List&lt;?&gt;) result).sort(comparator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Map<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            ResolvableType mapType = descriptor.getResolvableType().asMap();</span><br><span class="line">            Class&lt;?&gt; keyType = mapType.resolveGeneric(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (String<span class="class">.<span class="keyword">class</span> !</span>= keyType) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; valueType = mapType.resolveGeneric(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (valueType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType,</span><br><span class="line">                                                                       <span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">            <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> matchingBeans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">(DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAutowireCandidateResolver().isRequired(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">indicatesMultipleBeans</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (type.isArray() || (type.isInterface() &amp;&amp;</span><br><span class="line">                                   (Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) || <span class="title">Map</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>))))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Comparator&lt;Object&gt; <span class="title">adaptDependencyComparator</span><span class="params">(Map&lt;String, ?&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = getDependencyComparator();</span><br><span class="line">        <span class="keyword">if</span> (comparator <span class="keyword">instanceof</span> OrderComparator) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((OrderComparator) comparator).withSourceProvider(</span><br><span class="line">                createFactoryAwareOrderSourceProvider(matchingBeans));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> comparator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Comparator&lt;Object&gt; <span class="title">adaptOrderComparator</span><span class="params">(Map&lt;String, ?&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; dependencyComparator = getDependencyComparator();</span><br><span class="line">        OrderComparator comparator = (dependencyComparator <span class="keyword">instanceof</span> OrderComparator ?</span><br><span class="line">                                      (OrderComparator) dependencyComparator : OrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">return</span> comparator.withSourceProvider(createFactoryAwareOrderSourceProvider(matchingBeans));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderComparator.<span class="function">OrderSourceProvider <span class="title">createFactoryAwareOrderSourceProvider</span><span class="params">(Map&lt;String, ?&gt; beans)</span> </span>&#123;</span><br><span class="line">        IdentityHashMap&lt;Object, String&gt; instancesToBeanNames = <span class="keyword">new</span> IdentityHashMap&lt;&gt;();</span><br><span class="line">        beans.forEach((beanName, instance) -&gt; instancesToBeanNames.put(instance, beanName));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FactoryAwareOrderSourceProvider(instancesToBeanNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Find bean instances that match the required type.</span></span><br><span class="line"><span class="comment">	 * Called during autowiring for the specified bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean that is about to be wired</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the actual type of bean to look for</span></span><br><span class="line"><span class="comment">	 * (may be an array component type or collection element type)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the descriptor of the dependency to resolve</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a Map of candidate names and candidate instances that match</span></span><br><span class="line"><span class="comment">	 * the required type (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #autowireByType</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">findAutowireCandidates</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">            <span class="keyword">this</span>, requiredType, <span class="keyword">true</span>, descriptor.isEager());</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; classObjectEntry : <span class="keyword">this</span>.resolvableDependencies.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; autowiringType = classObjectEntry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">                Object autowiringValue = classObjectEntry.getValue();</span><br><span class="line">                autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">                <span class="keyword">if</span> (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">                    result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">                addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> multiple = indicatesMultipleBeans(requiredType);</span><br><span class="line">            <span class="comment">// Consider fallback matches if the first pass failed to find anything...</span></span><br><span class="line">            DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();</span><br><span class="line">            <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, fallbackDescriptor) &amp;&amp;</span><br><span class="line">                    (!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) &#123;</span><br><span class="line">                    addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.isEmpty() &amp;&amp; !multiple) &#123;</span><br><span class="line">                <span class="comment">// Consider self references as a final pass...</span></span><br><span class="line">                <span class="comment">// but in the case of a dependency collection, not the very same bean itself.</span></span><br><span class="line">                <span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isSelfReference(beanName, candidate) &amp;&amp;</span><br><span class="line">                        (!(descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) || !beanName.equals(candidate)) &amp;&amp;</span><br><span class="line">                        isAutowireCandidate(candidate, fallbackDescriptor)) &#123;</span><br><span class="line">                        addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Add an entry to the candidate map: a bean instance if available or just the resolved</span></span><br><span class="line"><span class="comment">	 * type, preventing early bean initialization ahead of primary candidate selection.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCandidateEntry</span><span class="params">(Map&lt;String, Object&gt; candidates, String candidateName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   DependencyDescriptor descriptor, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) &#123;</span><br><span class="line">            Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> NullBean)) &#123;</span><br><span class="line">                candidates.put(candidateName, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (containsSingleton(candidateName) || (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor &amp;&amp;</span><br><span class="line">                                                      ((StreamDependencyDescriptor) descriptor).isOrdered())) &#123;</span><br><span class="line">            Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, <span class="keyword">this</span>);</span><br><span class="line">            candidates.put(candidateName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            candidates.put(candidateName, getType(candidateName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the autowire candidate in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Looks for &#123;<span class="doctag">@code</span> <span class="doctag">@Primary</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@Priority</span>&#125; (in that order).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * that match the required type, as returned by &#123;<span class="doctag">@link</span> #findAutowireCandidates&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> descriptor the target dependency to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the autowire candidate, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineAutowireCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; requiredType = descriptor.getDependencyType();</span><br><span class="line">        String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (primaryCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryCandidate;</span><br><span class="line">        &#125;</span><br><span class="line">        String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (priorityCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> priorityCandidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fallback</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> ((beanInstance != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.resolvableDependencies.containsValue(beanInstance)) ||</span><br><span class="line">                matchesBeanName(candidateName, descriptor.getDependencyName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidateName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the primary candidate in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * (or candidate classes if not created yet) that match the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the target dependency type to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the primary candidate, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isPrimary(String, Object)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determinePrimaryCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        String primaryBeanName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateBeanName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (isPrimary(candidateBeanName, beanInstance)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (primaryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> candidateLocal = containsBeanDefinition(candidateBeanName);</span><br><span class="line">                    <span class="keyword">boolean</span> primaryLocal = containsBeanDefinition(primaryBeanName);</span><br><span class="line">                    <span class="keyword">if</span> (candidateLocal &amp;&amp; primaryLocal) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                                                                  <span class="string">"more than one 'primary' bean found among candidates: "</span> + candidates.keySet());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (candidateLocal) &#123;</span><br><span class="line">                        primaryBeanName = candidateBeanName;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    primaryBeanName = candidateBeanName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primaryBeanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the candidate with the highest priority in the given set of beans.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Based on &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.annotation.Priority&#125;. As defined by the related</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered&#125; interface, the lowest value has</span></span><br><span class="line"><span class="comment">	 * the highest priority.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> candidates a Map of candidate names and candidate instances</span></span><br><span class="line"><span class="comment">	 * (or candidate classes if not created yet) that match the required type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> requiredType the target dependency type to match against</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the name of the candidate with the highest priority,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPriority(Object)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineHighestPriorityCandidate</span><span class="params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        String highestPriorityBeanName = <span class="keyword">null</span>;</span><br><span class="line">        Integer highestPriority = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">            String candidateBeanName = entry.getKey();</span><br><span class="line">            Object beanInstance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Integer candidatePriority = getPriority(beanInstance);</span><br><span class="line">                <span class="keyword">if</span> (candidatePriority != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (highestPriorityBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (candidatePriority.equals(highestPriority)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line">                                                                      <span class="string">"Multiple beans found with the same priority ('"</span> + highestPriority +</span><br><span class="line">                                                                      <span class="string">"') among candidates: "</span> + candidates.keySet());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (candidatePriority &lt; highestPriority) &#123;</span><br><span class="line">                            highestPriorityBeanName = candidateBeanName;</span><br><span class="line">                            highestPriority = candidatePriority;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        highestPriorityBeanName = candidateBeanName;</span><br><span class="line">                        highestPriority = candidatePriority;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> highestPriorityBeanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether the bean definition for the given bean name has been</span></span><br><span class="line"><span class="comment">	 * marked as a primary bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanInstance the corresponding bean instance (can be null)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the given bean qualifies as primary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">(String beanName, Object beanInstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getMergedLocalBeanDefinition(beanName).isPrimary();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">return</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory &amp;&amp;</span><br><span class="line">                ((DefaultListableBeanFactory) parent).isPrimary(beanName, beanInstance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the priority assigned for the given bean instance by</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@code</span> javax.annotation.Priority&#125; annotation.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation delegates to the specified</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> #setDependencyComparator dependency comparator&#125;, checking its</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> OrderComparator#getPriority method&#125; if it is an extension of</span></span><br><span class="line"><span class="comment">	 * Spring's common &#123;<span class="doctag">@link</span> OrderComparator&#125; - typically, an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.AnnotationAwareOrderComparator&#125;.</span></span><br><span class="line"><span class="comment">	 * If no such comparator is present, this implementation returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanInstance the bean instance to check (can be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the priority assigned to that bean or &#123;<span class="doctag">@code</span> null&#125; if none is set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">getPriority</span><span class="params">(Object beanInstance)</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Object&gt; comparator = getDependencyComparator();</span><br><span class="line">        <span class="keyword">if</span> (comparator <span class="keyword">instanceof</span> OrderComparator) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((OrderComparator) comparator).getPriority(beanInstance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given candidate name matches the bean name or the aliases</span></span><br><span class="line"><span class="comment">	 * stored in this bean definition.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesBeanName</span><span class="params">(String beanName, @Nullable String candidateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (candidateName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given beanName/candidateName pair indicates a self reference,</span></span><br><span class="line"><span class="comment">	 * i.e. whether the candidate points back to the original bean or to a factory method</span></span><br><span class="line"><span class="comment">	 * on the original bean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSelfReference</span><span class="params">(@Nullable String beanName, @Nullable String candidateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (beanName != <span class="keyword">null</span> &amp;&amp; candidateName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (beanName.equals(candidateName) || (containsBeanDefinition(candidateName) &amp;&amp;</span><br><span class="line">                                                    beanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName()))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException</span></span><br><span class="line"><span class="comment">	 * for an unresolvable dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">raiseNoMatchingBeanFound</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; type, ResolvableType resolvableType, DependencyDescriptor descriptor)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        checkBeanNotOfRequiredType(type, descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(resolvableType,</span><br><span class="line">                                                <span class="string">"expected at least 1 bean which qualifies as autowire candidate. "</span> +</span><br><span class="line">                                                <span class="string">"Dependency annotations: "</span> + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,</span></span><br><span class="line"><span class="comment">	 * i.e. if the target type of the bean would match but an exposed proxy doesn't.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkBeanNotOfRequiredType</span><span class="params">(Class&lt;?&gt; type, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            Class&lt;?&gt; targetType = mbd.getTargetType();</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; type.isAssignableFrom(targetType) &amp;&amp;</span><br><span class="line">                isAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) &#123;</span><br><span class="line">                <span class="comment">// Probably a proxy interfering with target type match -&gt; throw meaningful exception.</span></span><br><span class="line">                Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">                Class&lt;?&gt; beanType = (beanInstance != <span class="keyword">null</span> &amp;&amp; beanInstance.getClass() != NullBean<span class="class">.<span class="keyword">class</span> ?</span></span><br><span class="line">                                     beanInstance.getClass() : predictBeanType(beanName, mbd));</span><br><span class="line">                <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; !type.isAssignableFrom(beanType)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(beanName, type, beanType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">            ((DefaultListableBeanFactory) parent).checkBeanNotOfRequiredType(type, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an &#123;<span class="doctag">@link</span> Optional&#125; wrapper for the specified dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;?&gt; createOptionalDependency(</span><br><span class="line">        DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName, <span class="keyword">final</span> Object... args) &#123;</span><br><span class="line"></span><br><span class="line">        DependencyDescriptor descriptorToUse = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :</span><br><span class="line">                        <span class="keyword">super</span>.resolveCandidate(beanName, requiredType, beanFactory));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object result = doResolveDependency(descriptorToUse, beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Optional ? (Optional&lt;?&gt;) result : Optional.ofNullable(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(ObjectUtils.identityToString(<span class="keyword">this</span>));</span><br><span class="line">        sb.append(<span class="string">": defining beans ["</span>);</span><br><span class="line">        sb.append(StringUtils.collectionToCommaDelimitedString(<span class="keyword">this</span>.beanDefinitionNames));</span><br><span class="line">        sb.append(<span class="string">"]; "</span>);</span><br><span class="line">        BeanFactory parent = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"root of factory hierarchy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(<span class="string">"parent: "</span>).append(ObjectUtils.identityToString(parent));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Serialization support</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(<span class="string">"DefaultListableBeanFactory itself is not deserializable - "</span> +</span><br><span class="line">                                           <span class="string">"just a SerializedBeanFactoryReference is"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.serializationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SerializedBeanFactoryReference(<span class="keyword">this</span>.serializationId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(<span class="string">"DefaultListableBeanFactory has no serialization id"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Minimal id reference to the factory.</span></span><br><span class="line"><span class="comment">	 * Resolved to the actual factory instance on deserialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedBeanFactoryReference</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SerializedBeanFactoryReference</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Reference&lt;?&gt; ref = serializableFactories.get(<span class="keyword">this</span>.id);</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object result = ref.get();</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lenient fallback: dummy factory in case of original factory not found...</span></span><br><span class="line">            DefaultListableBeanFactory dummyFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">            dummyFactory.serializationId = <span class="keyword">this</span>.id;</span><br><span class="line">            <span class="keyword">return</span> dummyFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor marker for nested elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedDependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">DependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NestedDependencyDescriptor</span><span class="params">(DependencyDescriptor original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">            increaseNestingLevel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor for a multi-element declaration with nested elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiElementDescriptor</span> <span class="keyword">extends</span> <span class="title">NestedDependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiElementDescriptor</span><span class="params">(DependencyDescriptor original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A dependency descriptor marker for stream access to multiple elements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">DependencyDescriptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StreamDependencyDescriptor</span><span class="params">(DependencyDescriptor original, <span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">            <span class="keyword">this</span>.ordered = ordered;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.ordered;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanObjectProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ObjectProvider</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyObjectProvider</span> <span class="keyword">implements</span> <span class="title">BeanObjectProvider</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DependencyDescriptor descriptor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> optional;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DependencyObjectProvider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor);</span><br><span class="line">            <span class="keyword">this</span>.optional = (<span class="keyword">this</span>.descriptor.getDependencyType() == Optional<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Object result = doResolveDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="keyword">this</span>.descriptor.getResolvableType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> beanFactory.getBean(beanName, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                Object result = doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="keyword">this</span>.descriptor.getResolvableType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            DependencyDescriptor descriptorToUse = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">this</span>.descriptor) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@Nullable</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">resolveNotUnique</span><span class="params">(ResolvableType type, Map&lt;String, Object&gt; matchingBeans)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(descriptorToUse, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.optional) &#123;</span><br><span class="line">                <span class="keyword">return</span> createOptionalDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doResolveDependency(<span class="keyword">this</span>.descriptor, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Stream&lt;Object&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolveStream(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Stream&lt;Object&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolveStream(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Stream&lt;Object&gt; <span class="title">resolveStream</span><span class="params">(<span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">            DependencyDescriptor descriptorToUse = <span class="keyword">new</span> StreamDependencyDescriptor(<span class="keyword">this</span>.descriptor, ordered);</span><br><span class="line">            Object result = doResolveDependency(descriptorToUse, <span class="keyword">this</span>.beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Stream ? (Stream&lt;Object&gt;) result : Stream.of(result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Separate inner class for avoiding a hard dependency on the &#123;<span class="doctag">@code</span> javax.inject&#125; API.</span></span><br><span class="line"><span class="comment">	 * Actual &#123;<span class="doctag">@code</span> javax.inject.Provider&#125; implementation is nested here in order to make it</span></span><br><span class="line"><span class="comment">	 * invisible for Graal's introspection of DefaultListableBeanFactory's nested classes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Jsr330Factory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">createDependencyProvider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Provider(descriptor, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Jsr330Provider</span> <span class="keyword">extends</span> <span class="title">DependencyObjectProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Jsr330Provider</span><span class="params">(DependencyDescriptor descriptor, @Nullable String beanName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(descriptor, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * An &#123;<span class="doctag">@link</span> org.springframework.core.OrderComparator.OrderSourceProvider&#125; implementation</span></span><br><span class="line"><span class="comment">	 * that is aware of the bean metadata of the instances to sort.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Lookup for the method factory of an instance to sort, if any, and let the</span></span><br><span class="line"><span class="comment">	 * comparator retrieve the &#123;<span class="doctag">@link</span> org.springframework.core.annotation.Order&#125;</span></span><br><span class="line"><span class="comment">	 * value defined on it. This essentially allows for the following construct:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryAwareOrderSourceProvider</span> <span class="keyword">implements</span> <span class="title">OrderComparator</span>.<span class="title">OrderSourceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, String&gt; instancesToBeanNames;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FactoryAwareOrderSourceProvider</span><span class="params">(Map&lt;Object, String&gt; instancesToBeanNames)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.instancesToBeanNames = instancesToBeanNames;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getOrderSource</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            RootBeanDefinition beanDefinition = getRootBeanDefinition(<span class="keyword">this</span>.instancesToBeanNames.get(obj));</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Object&gt; sources = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            Method factoryMethod = beanDefinition.getResolvedFactoryMethod();</span><br><span class="line">            <span class="keyword">if</span> (factoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sources.add(factoryMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; targetType = beanDefinition.getTargetType();</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType != obj.getClass()) &#123;</span><br><span class="line">                sources.add(targetType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sources.toArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> RootBeanDefinition <span class="title">getRootBeanDefinition</span><span class="params">(@Nullable String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                BeanDefinition bd = getMergedBeanDefinition(beanName);</span><br><span class="line">                <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (RootBeanDefinition) bd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="genericapplicationcontext-源码"><em>GenericApplicationContext 源码</em></span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> customClassLoader = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean refreshed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the DefaultListableBeanFactory instance to use for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanFactory, <span class="string">"BeanFactory must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given parent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent the parent application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext with the given DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the DefaultListableBeanFactory instance to use for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parent the parent application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory, ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(beanFactory);</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set the parent of this application context, also setting</span></span><br><span class="line"><span class="comment">	 * the parent of the internal BeanFactory accordingly.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setParent(parent);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setParentBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether it should be allowed to override bean definitions by registering</span></span><br><span class="line"><span class="comment">	 * a different definition with the same name, automatically replacing the former.</span></span><br><span class="line"><span class="comment">	 * If not, an exception will be thrown. Default is "true".</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowBeanDefinitionOverriding</span><span class="params">(<span class="keyword">boolean</span> allowBeanDefinitionOverriding)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set whether to allow circular references between beans - and automatically</span></span><br><span class="line"><span class="comment">	 * try to resolve them.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is "true". Turn this off to throw an exception when encountering</span></span><br><span class="line"><span class="comment">	 * a circular reference, disallowing them completely.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowCircularReferences</span><span class="params">(<span class="keyword">boolean</span> allowCircularReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setAllowCircularReferences(allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set a ResourceLoader to use for this context. If set, the context will</span></span><br><span class="line"><span class="comment">	 * delegate all &#123;<span class="doctag">@code</span> getResource&#125; calls to the given ResourceLoader.</span></span><br><span class="line"><span class="comment">	 * If not set, default resource loading will apply.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The main reason to specify a custom ResourceLoader is to resolve</span></span><br><span class="line"><span class="comment">	 * resource paths (without URL prefix) in a specific fashion.</span></span><br><span class="line"><span class="comment">	 * The default behavior is to resolve such paths as class path locations.</span></span><br><span class="line"><span class="comment">	 * To resolve resource paths as file system locations, specify a</span></span><br><span class="line"><span class="comment">	 * FileSystemResourceLoader here.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;You can also pass in a full ResourcePatternResolver, which will</span></span><br><span class="line"><span class="comment">	 * be autodetected by the context and used for &#123;<span class="doctag">@code</span> getResources&#125;</span></span><br><span class="line"><span class="comment">	 * calls as well. Else, default resource pattern matching will apply.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getResource</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.DefaultResourceLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.FileSystemResourceLoader</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.core.io.support.ResourcePatternResolver</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getResources</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ResourceLoader / ResourcePatternResolver override if necessary</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation delegates to this context's ResourceLoader if set,</span></span><br><span class="line"><span class="comment">	 * falling back to the default superclass behavior else.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getResource(location);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResource(location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation delegates to this context's ResourceLoader if it</span></span><br><span class="line"><span class="comment">	 * implements the ResourcePatternResolver interface, falling back to the</span></span><br><span class="line"><span class="comment">	 * default superclass behavior else.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ResourcePatternResolver) <span class="keyword">this</span>.resourceLoader).getResources(locationPattern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassLoader</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">this</span>.customClassLoader = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.customClassLoader) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementations of AbstractApplicationContext's template methods</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Do nothing: We hold a single internal BeanFactory and rely on callers</span></span><br><span class="line"><span class="comment">	 * to register beans through our public methods (or the BeanFactory's).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cancelRefresh</span><span class="params">(BeansException ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">super</span>.cancelRefresh(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Not much to do: We hold a single internal BeanFactory that will never</span></span><br><span class="line"><span class="comment">	 * get released.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.setSerializationId(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the single internal BeanFactory held by this context</span></span><br><span class="line"><span class="comment">	 * (as ConfigurableListableBeanFactory).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the underlying bean factory of this context,</span></span><br><span class="line"><span class="comment">	 * available for registering bean definitions.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; You need to call &#123;<span class="doctag">@link</span> #refresh()&#125; to initialize the</span></span><br><span class="line"><span class="comment">	 * bean factory and its contained beans with application context semantics</span></span><br><span class="line"><span class="comment">	 * (autodetecting BeanFactoryPostProcessors, etc).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the internal bean factory (as DefaultListableBeanFactory)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> DefaultListableBeanFactory <span class="title">getDefaultListableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Implementation of BeanDefinitionRegistry</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.removeBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.isBeanNameInUse(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String beanName, String alias)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAlias</span><span class="params">(String alias)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory.removeAlias(alias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlias</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.isAlias(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Convenient methods for registering individual beans</span></span><br><span class="line">    <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, optionally customizing its</span></span><br><span class="line"><span class="comment">	 * bean definition metadata (typically declared as a lambda expression</span></span><br><span class="line"><span class="comment">	 * or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean (resolving a public constructor</span></span><br><span class="line"><span class="comment">	 * to be autowired, possibly simply the default constructor)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; beanClass, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line">        registerBean(<span class="keyword">null</span>, beanClass, <span class="keyword">null</span>, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean (resolving a public constructor</span></span><br><span class="line"><span class="comment">	 * to be autowired, possibly simply the default constructor)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String beanName, Class&lt;T&gt; beanClass, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registerBean(beanName, beanClass, <span class="keyword">null</span>, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> supplier a callback for creating an instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;T&gt; beanClass, Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registerBean(<span class="keyword">null</span>, beanClass, supplier, customizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a bean from the given bean class, using the given supplier for</span></span><br><span class="line"><span class="comment">	 * obtaining a new instance (typically declared as a lambda expression or</span></span><br><span class="line"><span class="comment">	 * method reference), optionally customizing its bean definition metadata</span></span><br><span class="line"><span class="comment">	 * (again typically declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method can be overridden to adapt the registration mechanism for</span></span><br><span class="line"><span class="comment">	 * all &#123;<span class="doctag">@code</span> registerBean&#125; methods (since they all delegate to this one).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> supplier a callback for creating an instance of the bean (in case</span></span><br><span class="line"><span class="comment">	 * of &#123;<span class="doctag">@code</span> null&#125;, resolving a public constructor to be autowired instead)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customizers one or more callbacks for customizing the factory's</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(@Nullable String beanName, Class&lt;T&gt; beanClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassDerivedBeanDefinition beanDefinition = <span class="keyword">new</span> ClassDerivedBeanDefinition(beanClass);</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanDefinition.setInstanceSupplier(supplier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">            customizer.customize(beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String nameToUse = (beanName != <span class="keyword">null</span> ? beanName : beanClass.getName());</span><br><span class="line">        registerBeanDefinition(nameToUse, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> RootBeanDefinition&#125; marker subclass for &#123;<span class="doctag">@code</span> #registerBean&#125; based</span></span><br><span class="line"><span class="comment">	 * registrations with flexible autowiring for public constructors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDerivedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">RootBeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClassDerivedBeanDefinition</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(beanClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClassDerivedBeanDefinition</span><span class="params">(ClassDerivedBeanDefinition original)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(original);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> Constructor&lt;?&gt;[] getPreferredConstructors() &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = getBeanClass();</span><br><span class="line">            Constructor&lt;?&gt; primaryCtor = BeanUtils.findPrimaryConstructor(clazz);</span><br><span class="line">            <span class="keyword">if</span> (primaryCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryCtor&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            Constructor&lt;?&gt;[] publicCtors = clazz.getConstructors();</span><br><span class="line">            <span class="keyword">if</span> (publicCtors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> publicCtors;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RootBeanDefinition <span class="title">cloneBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ClassDerivedBeanDefinition(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>todo: 未完待续…</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant知识点</title>
    <url>/2020/03/04/Vagrant%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2><span id="1什么是vagrant"><strong>1.什么是vagrant</strong></span></h2><p>  vagrant 是一个通过命令行，来管理虚拟机的工具，vagrant 本身并没有提供虚拟化的功能，vagrant 可以用来管理virtualbox，可以通过vagrant 提供的命令创建，启动和关闭virtualbox里面的虚拟机</p>
<h2><span id="2为什么要使用vagrant">2.<strong>为什么要使用vagrant</strong></span></h2><p> vagrant提供一个配置文件 vagrantfile,可以通过该配置文件快速创建或者复制一个虚拟机，同时是用命令行来管理虚拟机非常简单</p>
<h2><span id="3必须要有virtualbox才能正常安装vagrant">3.<strong>必须要有virtualbox才能正常安装vagrant</strong></span></h2><a id="more"></a>

<h2><span id="4vagrant常用命令">4.<strong>vagrant常用命令</strong></span></h2><ul>
<li><p>初始化vagrant工程</p>
<p>vagrant init ubuntu/trusty64：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">该命令会在当前目录下创建vagrantfile,并且指定所使用的<span class="built_in">box</span>为ubuntu/trusty64，该<span class="built_in">box</span>由Hashicorp官网提供。此时，vagrant发现<span class="built_in">box</span>的名字的格式为<span class="string">"用户名/box名"</span>,则会使用<span class="string">"https://atlas.hashicorp.com/用户名/box名"</span>来下载该<span class="built_in">box</span>.</span><br><span class="line">对于非官网提供的<span class="built_in">box</span>，可以通过以下命令创建：</span><br><span class="line">vagrant init my-<span class="built_in">box</span> https://boxes.company.com/my.<span class="built_in">box</span>(其中，my-<span class="built_in">box</span>为该<span class="built_in">box</span>的名字，后面的URL为该<span class="built_in">box</span>的下载地址。)</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant halt</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂起虚拟机(非常实用，节省内存)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant suspend</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒虚拟机</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vagrant resume</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看虚拟机状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant status</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant destroy</span><br><span class="line"></span><br><span class="line">注：vagrant destroy只会删除虚拟机本身，也即你在Virtualbox将看不到该虚拟机，但是不会删除该虚拟机所使用的box。</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出本地所有的box</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant box list</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除某个box</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant box remove boxname</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2><span id="4provision">4.provision</span></h2><p>Provisioner 是 Vagrant 中的一个概念，表示用户在 Vagrantfile 中所提供的自动或手动执行的虚拟机任务。任务的类型也有很多种，比如执行 Shell 脚本，文件拷贝等等。</p>
<p>vagrant 执行特定任务的通用语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant provision --provision-with &lt;provisioner&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Oracle VM VirtualBox + vagrant</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>shell</tag>
        <tag>vagrant</tag>
        <tag>快速部署</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2020/03/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1><span id="2020-03-03-2217">2020-03-03 22:17</span></h1><p>我的博客系统上线啦！</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
